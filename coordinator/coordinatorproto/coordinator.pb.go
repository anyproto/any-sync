// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: coordinator/coordinatorproto/protos/coordinator.proto

package coordinatorproto

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ErrorCodes int32

const (
	ErrorCodes_Unexpected           ErrorCodes = 0
	ErrorCodes_SpaceDeleted         ErrorCodes = 1
	ErrorCodes_SpaceDeletionPending ErrorCodes = 2
	ErrorCodes_SpaceCreated         ErrorCodes = 3
	ErrorCodes_SpaceNotExists       ErrorCodes = 4
	ErrorCodes_SpaceLimitReached    ErrorCodes = 5
	ErrorCodes_AccountDeleted       ErrorCodes = 6
	ErrorCodes_Forbidden            ErrorCodes = 7
	ErrorCodes_AclHeadIsMissing     ErrorCodes = 8
	ErrorCodes_AclNonEmpty          ErrorCodes = 9
	ErrorCodes_SpaceNotShareable    ErrorCodes = 10
	ErrorCodes_ErrorOffset          ErrorCodes = 300
)

var ErrorCodes_name = map[int32]string{
	0:   "Unexpected",
	1:   "SpaceDeleted",
	2:   "SpaceDeletionPending",
	3:   "SpaceCreated",
	4:   "SpaceNotExists",
	5:   "SpaceLimitReached",
	6:   "AccountDeleted",
	7:   "Forbidden",
	8:   "AclHeadIsMissing",
	9:   "AclNonEmpty",
	10:  "SpaceNotShareable",
	300: "ErrorOffset",
}

var ErrorCodes_value = map[string]int32{
	"Unexpected":           0,
	"SpaceDeleted":         1,
	"SpaceDeletionPending": 2,
	"SpaceCreated":         3,
	"SpaceNotExists":       4,
	"SpaceLimitReached":    5,
	"AccountDeleted":       6,
	"Forbidden":            7,
	"AclHeadIsMissing":     8,
	"AclNonEmpty":          9,
	"SpaceNotShareable":    10,
	"ErrorOffset":          300,
}

func (x ErrorCodes) String() string {
	return proto.EnumName(ErrorCodes_name, int32(x))
}

func (ErrorCodes) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{0}
}

type SpaceStatus int32

const (
	SpaceStatus_SpaceStatusCreated         SpaceStatus = 0
	SpaceStatus_SpaceStatusPendingDeletion SpaceStatus = 1
	SpaceStatus_SpaceStatusDeletionStarted SpaceStatus = 2
	SpaceStatus_SpaceStatusDeleted         SpaceStatus = 3
	SpaceStatus_SpaceStatusNotExists       SpaceStatus = 4
)

var SpaceStatus_name = map[int32]string{
	0: "SpaceStatusCreated",
	1: "SpaceStatusPendingDeletion",
	2: "SpaceStatusDeletionStarted",
	3: "SpaceStatusDeleted",
	4: "SpaceStatusNotExists",
}

var SpaceStatus_value = map[string]int32{
	"SpaceStatusCreated":         0,
	"SpaceStatusPendingDeletion": 1,
	"SpaceStatusDeletionStarted": 2,
	"SpaceStatusDeleted":         3,
	"SpaceStatusNotExists":       4,
}

func (x SpaceStatus) String() string {
	return proto.EnumName(SpaceStatus_name, int32(x))
}

func (SpaceStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{1}
}

type SpacePermissions int32

const (
	SpacePermissions_SpacePermissionsUnknown SpacePermissions = 0
	SpacePermissions_SpacePermissionsOwner   SpacePermissions = 1
)

var SpacePermissions_name = map[int32]string{
	0: "SpacePermissionsUnknown",
	1: "SpacePermissionsOwner",
}

var SpacePermissions_value = map[string]int32{
	"SpacePermissionsUnknown": 0,
	"SpacePermissionsOwner":   1,
}

func (x SpacePermissions) String() string {
	return proto.EnumName(SpacePermissions_name, int32(x))
}

func (SpacePermissions) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{2}
}

// NodeType determines the type of API that a node supports
type NodeType int32

const (
	// TreeAPI supports space/tree sync api
	NodeType_TreeAPI NodeType = 0
	// FileAPI support file api
	NodeType_FileAPI NodeType = 1
	// CoordinatorAPI supports coordinator api
	NodeType_CoordinatorAPI NodeType = 2
	// ConsensusAPI supports consensus api
	NodeType_ConsensusAPI NodeType = 3
	// NamingNodeAPI supports naming node api
	// (see any-ns-node repository)
	NodeType_NamingNodeAPI NodeType = 4
	// PaymentProcessingAPI supports payment processing api
	// (see any-pp-node repository)
	NodeType_PaymentProcessingAPI NodeType = 5
)

var NodeType_name = map[int32]string{
	0: "TreeAPI",
	1: "FileAPI",
	2: "CoordinatorAPI",
	3: "ConsensusAPI",
	4: "NamingNodeAPI",
	5: "PaymentProcessingAPI",
}

var NodeType_value = map[string]int32{
	"TreeAPI":              0,
	"FileAPI":              1,
	"CoordinatorAPI":       2,
	"ConsensusAPI":         3,
	"NamingNodeAPI":        4,
	"PaymentProcessingAPI": 5,
}

func (x NodeType) String() string {
	return proto.EnumName(NodeType_name, int32(x))
}

func (NodeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{3}
}

// DeletionChangeType determines the type of deletion payload
type DeletionPayloadType int32

const (
	DeletionPayloadType_Tree    DeletionPayloadType = 0
	DeletionPayloadType_Confirm DeletionPayloadType = 1
	DeletionPayloadType_Account DeletionPayloadType = 2
)

var DeletionPayloadType_name = map[int32]string{
	0: "Tree",
	1: "Confirm",
	2: "Account",
}

var DeletionPayloadType_value = map[string]int32{
	"Tree":    0,
	"Confirm": 1,
	"Account": 2,
}

func (x DeletionPayloadType) String() string {
	return proto.EnumName(DeletionPayloadType_name, int32(x))
}

func (DeletionPayloadType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{4}
}

type DeletionLogRecordStatus int32

const (
	// Ok means space should operate in a normal
	DeletionLogRecordStatus_Ok DeletionLogRecordStatus = 0
	// RemovePrepare means space prepared to remove, sync should be disabled
	DeletionLogRecordStatus_RemovePrepare DeletionLogRecordStatus = 1
	// Remove means space should be removed
	DeletionLogRecordStatus_Remove DeletionLogRecordStatus = 2
)

var DeletionLogRecordStatus_name = map[int32]string{
	0: "Ok",
	1: "RemovePrepare",
	2: "Remove",
}

var DeletionLogRecordStatus_value = map[string]int32{
	"Ok":            0,
	"RemovePrepare": 1,
	"Remove":        2,
}

func (x DeletionLogRecordStatus) String() string {
	return proto.EnumName(DeletionLogRecordStatus_name, int32(x))
}

func (DeletionLogRecordStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{5}
}

type AclEventLogRecordType int32

const (
	AclEventLogRecordType_RecordTypeSpaceReceipt      AclEventLogRecordType = 0
	AclEventLogRecordType_RecordTypeSpaceShared       AclEventLogRecordType = 1
	AclEventLogRecordType_RecordTypeSpaceUnshared     AclEventLogRecordType = 2
	AclEventLogRecordType_RecordTypeSpaceAclAddRecord AclEventLogRecordType = 3
)

var AclEventLogRecordType_name = map[int32]string{
	0: "RecordTypeSpaceReceipt",
	1: "RecordTypeSpaceShared",
	2: "RecordTypeSpaceUnshared",
	3: "RecordTypeSpaceAclAddRecord",
}

var AclEventLogRecordType_value = map[string]int32{
	"RecordTypeSpaceReceipt":      0,
	"RecordTypeSpaceShared":       1,
	"RecordTypeSpaceUnshared":     2,
	"RecordTypeSpaceAclAddRecord": 3,
}

func (x AclEventLogRecordType) String() string {
	return proto.EnumName(AclEventLogRecordType_name, int32(x))
}

func (AclEventLogRecordType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{6}
}

type SpaceSignRequest struct {
	// SpaceId is the id of the signed space
	SpaceId string `protobuf:"bytes,1,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
	// Header is the header of the signed space
	Header []byte `protobuf:"bytes,2,opt,name=header,proto3" json:"header,omitempty"`
	// OldIdentity is the old identity of the space owner
	OldIdentity []byte `protobuf:"bytes,3,opt,name=oldIdentity,proto3" json:"oldIdentity,omitempty"`
	// NewIdentitySignature is the new identity signed by the old one
	NewIdentitySignature []byte `protobuf:"bytes,4,opt,name=newIdentitySignature,proto3" json:"newIdentitySignature,omitempty"`
	// ForceRequest if true, forces the creating space receipt even if the space is deleted before
	ForceRequest bool `protobuf:"varint,5,opt,name=forceRequest,proto3" json:"forceRequest,omitempty"`
}

func (m *SpaceSignRequest) Reset()         { *m = SpaceSignRequest{} }
func (m *SpaceSignRequest) String() string { return proto.CompactTextString(m) }
func (*SpaceSignRequest) ProtoMessage()    {}
func (*SpaceSignRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{0}
}
func (m *SpaceSignRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceSignRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceSignRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceSignRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceSignRequest.Merge(m, src)
}
func (m *SpaceSignRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpaceSignRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceSignRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceSignRequest proto.InternalMessageInfo

func (m *SpaceSignRequest) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

func (m *SpaceSignRequest) GetHeader() []byte {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *SpaceSignRequest) GetOldIdentity() []byte {
	if m != nil {
		return m.OldIdentity
	}
	return nil
}

func (m *SpaceSignRequest) GetNewIdentitySignature() []byte {
	if m != nil {
		return m.NewIdentitySignature
	}
	return nil
}

func (m *SpaceSignRequest) GetForceRequest() bool {
	if m != nil {
		return m.ForceRequest
	}
	return false
}

type SpaceLimits struct {
	ReadMembers  uint32 `protobuf:"varint,1,opt,name=readMembers,proto3" json:"readMembers,omitempty"`
	WriteMembers uint32 `protobuf:"varint,2,opt,name=writeMembers,proto3" json:"writeMembers,omitempty"`
}

func (m *SpaceLimits) Reset()         { *m = SpaceLimits{} }
func (m *SpaceLimits) String() string { return proto.CompactTextString(m) }
func (*SpaceLimits) ProtoMessage()    {}
func (*SpaceLimits) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{1}
}
func (m *SpaceLimits) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceLimits) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceLimits.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceLimits) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceLimits.Merge(m, src)
}
func (m *SpaceLimits) XXX_Size() int {
	return m.Size()
}
func (m *SpaceLimits) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceLimits.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceLimits proto.InternalMessageInfo

func (m *SpaceLimits) GetReadMembers() uint32 {
	if m != nil {
		return m.ReadMembers
	}
	return 0
}

func (m *SpaceLimits) GetWriteMembers() uint32 {
	if m != nil {
		return m.WriteMembers
	}
	return 0
}

type SpaceStatusPayload struct {
	Status            SpaceStatus      `protobuf:"varint,1,opt,name=status,proto3,enum=coordinator.SpaceStatus" json:"status,omitempty"`
	DeletionTimestamp int64            `protobuf:"varint,2,opt,name=deletionTimestamp,proto3" json:"deletionTimestamp,omitempty"`
	Permissions       SpacePermissions `protobuf:"varint,3,opt,name=permissions,proto3,enum=coordinator.SpacePermissions" json:"permissions,omitempty"`
	Limits            *SpaceLimits     `protobuf:"bytes,4,opt,name=limits,proto3" json:"limits,omitempty"`
	IsShared          bool             `protobuf:"varint,5,opt,name=isShared,proto3" json:"isShared,omitempty"`
}

func (m *SpaceStatusPayload) Reset()         { *m = SpaceStatusPayload{} }
func (m *SpaceStatusPayload) String() string { return proto.CompactTextString(m) }
func (*SpaceStatusPayload) ProtoMessage()    {}
func (*SpaceStatusPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{2}
}
func (m *SpaceStatusPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceStatusPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceStatusPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceStatusPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceStatusPayload.Merge(m, src)
}
func (m *SpaceStatusPayload) XXX_Size() int {
	return m.Size()
}
func (m *SpaceStatusPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceStatusPayload.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceStatusPayload proto.InternalMessageInfo

func (m *SpaceStatusPayload) GetStatus() SpaceStatus {
	if m != nil {
		return m.Status
	}
	return SpaceStatus_SpaceStatusCreated
}

func (m *SpaceStatusPayload) GetDeletionTimestamp() int64 {
	if m != nil {
		return m.DeletionTimestamp
	}
	return 0
}

func (m *SpaceStatusPayload) GetPermissions() SpacePermissions {
	if m != nil {
		return m.Permissions
	}
	return SpacePermissions_SpacePermissionsUnknown
}

func (m *SpaceStatusPayload) GetLimits() *SpaceLimits {
	if m != nil {
		return m.Limits
	}
	return nil
}

func (m *SpaceStatusPayload) GetIsShared() bool {
	if m != nil {
		return m.IsShared
	}
	return false
}

type SpaceSignResponse struct {
	Receipt *SpaceReceiptWithSignature `protobuf:"bytes,1,opt,name=receipt,proto3" json:"receipt,omitempty"`
}

func (m *SpaceSignResponse) Reset()         { *m = SpaceSignResponse{} }
func (m *SpaceSignResponse) String() string { return proto.CompactTextString(m) }
func (*SpaceSignResponse) ProtoMessage()    {}
func (*SpaceSignResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{3}
}
func (m *SpaceSignResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceSignResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceSignResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceSignResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceSignResponse.Merge(m, src)
}
func (m *SpaceSignResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpaceSignResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceSignResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceSignResponse proto.InternalMessageInfo

func (m *SpaceSignResponse) GetReceipt() *SpaceReceiptWithSignature {
	if m != nil {
		return m.Receipt
	}
	return nil
}

// SpaceReceiptWithSignature contains protobuf encoded receipt and its signature
type SpaceReceiptWithSignature struct {
	SpaceReceiptPayload []byte `protobuf:"bytes,1,opt,name=spaceReceiptPayload,proto3" json:"spaceReceiptPayload,omitempty"`
	Signature           []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *SpaceReceiptWithSignature) Reset()         { *m = SpaceReceiptWithSignature{} }
func (m *SpaceReceiptWithSignature) String() string { return proto.CompactTextString(m) }
func (*SpaceReceiptWithSignature) ProtoMessage()    {}
func (*SpaceReceiptWithSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{4}
}
func (m *SpaceReceiptWithSignature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceReceiptWithSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceReceiptWithSignature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceReceiptWithSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceReceiptWithSignature.Merge(m, src)
}
func (m *SpaceReceiptWithSignature) XXX_Size() int {
	return m.Size()
}
func (m *SpaceReceiptWithSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceReceiptWithSignature.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceReceiptWithSignature proto.InternalMessageInfo

func (m *SpaceReceiptWithSignature) GetSpaceReceiptPayload() []byte {
	if m != nil {
		return m.SpaceReceiptPayload
	}
	return nil
}

func (m *SpaceReceiptWithSignature) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// SpaceReceipt contains permission to SpacePush operation
type SpaceReceipt struct {
	// SpaceId is the identifier of space
	SpaceId string `protobuf:"bytes,1,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
	// PeerId of receipt requester
	PeerId string `protobuf:"bytes,2,opt,name=peerId,proto3" json:"peerId,omitempty"`
	// AccountIdentity is an identity of a space owner
	AccountIdentity []byte `protobuf:"bytes,3,opt,name=accountIdentity,proto3" json:"accountIdentity,omitempty"`
	// NetworkId is the id of a network where the receipt is issued
	NetworkId string `protobuf:"bytes,4,opt,name=networkId,proto3" json:"networkId,omitempty"`
	// ValidUntil is a unix-timestamp with a deadline time of receipt validity
	ValidUntil uint64 `protobuf:"varint,5,opt,name=validUntil,proto3" json:"validUntil,omitempty"`
}

func (m *SpaceReceipt) Reset()         { *m = SpaceReceipt{} }
func (m *SpaceReceipt) String() string { return proto.CompactTextString(m) }
func (*SpaceReceipt) ProtoMessage()    {}
func (*SpaceReceipt) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{5}
}
func (m *SpaceReceipt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceReceipt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceReceipt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceReceipt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceReceipt.Merge(m, src)
}
func (m *SpaceReceipt) XXX_Size() int {
	return m.Size()
}
func (m *SpaceReceipt) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceReceipt.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceReceipt proto.InternalMessageInfo

func (m *SpaceReceipt) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

func (m *SpaceReceipt) GetPeerId() string {
	if m != nil {
		return m.PeerId
	}
	return ""
}

func (m *SpaceReceipt) GetAccountIdentity() []byte {
	if m != nil {
		return m.AccountIdentity
	}
	return nil
}

func (m *SpaceReceipt) GetNetworkId() string {
	if m != nil {
		return m.NetworkId
	}
	return ""
}

func (m *SpaceReceipt) GetValidUntil() uint64 {
	if m != nil {
		return m.ValidUntil
	}
	return 0
}

// SpaceStatusCheckRequest contains the spaceId of requested space
type SpaceStatusCheckRequest struct {
	SpaceId string `protobuf:"bytes,1,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
}

func (m *SpaceStatusCheckRequest) Reset()         { *m = SpaceStatusCheckRequest{} }
func (m *SpaceStatusCheckRequest) String() string { return proto.CompactTextString(m) }
func (*SpaceStatusCheckRequest) ProtoMessage()    {}
func (*SpaceStatusCheckRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{6}
}
func (m *SpaceStatusCheckRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceStatusCheckRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceStatusCheckRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceStatusCheckRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceStatusCheckRequest.Merge(m, src)
}
func (m *SpaceStatusCheckRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpaceStatusCheckRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceStatusCheckRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceStatusCheckRequest proto.InternalMessageInfo

func (m *SpaceStatusCheckRequest) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

// SpaceStatusCheckResponse contains the current status of space
type SpaceStatusCheckResponse struct {
	Payload *SpaceStatusPayload `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *SpaceStatusCheckResponse) Reset()         { *m = SpaceStatusCheckResponse{} }
func (m *SpaceStatusCheckResponse) String() string { return proto.CompactTextString(m) }
func (*SpaceStatusCheckResponse) ProtoMessage()    {}
func (*SpaceStatusCheckResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{7}
}
func (m *SpaceStatusCheckResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceStatusCheckResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceStatusCheckResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceStatusCheckResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceStatusCheckResponse.Merge(m, src)
}
func (m *SpaceStatusCheckResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpaceStatusCheckResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceStatusCheckResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceStatusCheckResponse proto.InternalMessageInfo

func (m *SpaceStatusCheckResponse) GetPayload() *SpaceStatusPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

// SpaceStatusCheckManyRequest contains the spaceIds of requested spaces
type SpaceStatusCheckManyRequest struct {
	SpaceIds []string `protobuf:"bytes,1,rep,name=spaceIds,proto3" json:"spaceIds,omitempty"`
}

func (m *SpaceStatusCheckManyRequest) Reset()         { *m = SpaceStatusCheckManyRequest{} }
func (m *SpaceStatusCheckManyRequest) String() string { return proto.CompactTextString(m) }
func (*SpaceStatusCheckManyRequest) ProtoMessage()    {}
func (*SpaceStatusCheckManyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{8}
}
func (m *SpaceStatusCheckManyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceStatusCheckManyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceStatusCheckManyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceStatusCheckManyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceStatusCheckManyRequest.Merge(m, src)
}
func (m *SpaceStatusCheckManyRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpaceStatusCheckManyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceStatusCheckManyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceStatusCheckManyRequest proto.InternalMessageInfo

func (m *SpaceStatusCheckManyRequest) GetSpaceIds() []string {
	if m != nil {
		return m.SpaceIds
	}
	return nil
}

// SpaceStatusCheckManyResponse contains the current statuses of spaces
type SpaceStatusCheckManyResponse struct {
	Payloads      []*SpaceStatusPayload `protobuf:"bytes,1,rep,name=payloads,proto3" json:"payloads,omitempty"`
	AccountLimits *AccountLimits        `protobuf:"bytes,2,opt,name=accountLimits,proto3" json:"accountLimits,omitempty"`
}

func (m *SpaceStatusCheckManyResponse) Reset()         { *m = SpaceStatusCheckManyResponse{} }
func (m *SpaceStatusCheckManyResponse) String() string { return proto.CompactTextString(m) }
func (*SpaceStatusCheckManyResponse) ProtoMessage()    {}
func (*SpaceStatusCheckManyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{9}
}
func (m *SpaceStatusCheckManyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceStatusCheckManyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceStatusCheckManyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceStatusCheckManyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceStatusCheckManyResponse.Merge(m, src)
}
func (m *SpaceStatusCheckManyResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpaceStatusCheckManyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceStatusCheckManyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceStatusCheckManyResponse proto.InternalMessageInfo

func (m *SpaceStatusCheckManyResponse) GetPayloads() []*SpaceStatusPayload {
	if m != nil {
		return m.Payloads
	}
	return nil
}

func (m *SpaceStatusCheckManyResponse) GetAccountLimits() *AccountLimits {
	if m != nil {
		return m.AccountLimits
	}
	return nil
}

// AccountLimits describes account level limit
type AccountLimits struct {
	SharedSpacesLimit uint32 `protobuf:"varint,1,opt,name=sharedSpacesLimit,proto3" json:"sharedSpacesLimit,omitempty"`
}

func (m *AccountLimits) Reset()         { *m = AccountLimits{} }
func (m *AccountLimits) String() string { return proto.CompactTextString(m) }
func (*AccountLimits) ProtoMessage()    {}
func (*AccountLimits) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{10}
}
func (m *AccountLimits) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountLimits) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountLimits.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountLimits) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountLimits.Merge(m, src)
}
func (m *AccountLimits) XXX_Size() int {
	return m.Size()
}
func (m *AccountLimits) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountLimits.DiscardUnknown(m)
}

var xxx_messageInfo_AccountLimits proto.InternalMessageInfo

func (m *AccountLimits) GetSharedSpacesLimit() uint32 {
	if m != nil {
		return m.SharedSpacesLimit
	}
	return 0
}

// SpaceStatusChangeRequest contains the deletionChange if we want to delete space, or it is empty otherwise
type SpaceStatusChangeRequest struct {
	SpaceId             string              `protobuf:"bytes,1,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
	DeletionPayloadId   string              `protobuf:"bytes,2,opt,name=deletionPayloadId,proto3" json:"deletionPayloadId,omitempty"`
	DeletionPayload     []byte              `protobuf:"bytes,3,opt,name=deletionPayload,proto3" json:"deletionPayload,omitempty"`
	DeletionPayloadType DeletionPayloadType `protobuf:"varint,4,opt,name=deletionPayloadType,proto3,enum=coordinator.DeletionPayloadType" json:"deletionPayloadType,omitempty"`
}

func (m *SpaceStatusChangeRequest) Reset()         { *m = SpaceStatusChangeRequest{} }
func (m *SpaceStatusChangeRequest) String() string { return proto.CompactTextString(m) }
func (*SpaceStatusChangeRequest) ProtoMessage()    {}
func (*SpaceStatusChangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{11}
}
func (m *SpaceStatusChangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceStatusChangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceStatusChangeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceStatusChangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceStatusChangeRequest.Merge(m, src)
}
func (m *SpaceStatusChangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpaceStatusChangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceStatusChangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceStatusChangeRequest proto.InternalMessageInfo

func (m *SpaceStatusChangeRequest) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

func (m *SpaceStatusChangeRequest) GetDeletionPayloadId() string {
	if m != nil {
		return m.DeletionPayloadId
	}
	return ""
}

func (m *SpaceStatusChangeRequest) GetDeletionPayload() []byte {
	if m != nil {
		return m.DeletionPayload
	}
	return nil
}

func (m *SpaceStatusChangeRequest) GetDeletionPayloadType() DeletionPayloadType {
	if m != nil {
		return m.DeletionPayloadType
	}
	return DeletionPayloadType_Tree
}

// SpaceStatusChangeResponse contains changed status of space
type SpaceStatusChangeResponse struct {
	Payload *SpaceStatusPayload `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *SpaceStatusChangeResponse) Reset()         { *m = SpaceStatusChangeResponse{} }
func (m *SpaceStatusChangeResponse) String() string { return proto.CompactTextString(m) }
func (*SpaceStatusChangeResponse) ProtoMessage()    {}
func (*SpaceStatusChangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{12}
}
func (m *SpaceStatusChangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceStatusChangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceStatusChangeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceStatusChangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceStatusChangeResponse.Merge(m, src)
}
func (m *SpaceStatusChangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpaceStatusChangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceStatusChangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceStatusChangeResponse proto.InternalMessageInfo

func (m *SpaceStatusChangeResponse) GetPayload() *SpaceStatusPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

type SpaceMakeShareableRequest struct {
	SpaceId string `protobuf:"bytes,1,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
}

func (m *SpaceMakeShareableRequest) Reset()         { *m = SpaceMakeShareableRequest{} }
func (m *SpaceMakeShareableRequest) String() string { return proto.CompactTextString(m) }
func (*SpaceMakeShareableRequest) ProtoMessage()    {}
func (*SpaceMakeShareableRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{13}
}
func (m *SpaceMakeShareableRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceMakeShareableRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceMakeShareableRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceMakeShareableRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceMakeShareableRequest.Merge(m, src)
}
func (m *SpaceMakeShareableRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpaceMakeShareableRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceMakeShareableRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceMakeShareableRequest proto.InternalMessageInfo

func (m *SpaceMakeShareableRequest) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

type SpaceMakeShareableResponse struct {
}

func (m *SpaceMakeShareableResponse) Reset()         { *m = SpaceMakeShareableResponse{} }
func (m *SpaceMakeShareableResponse) String() string { return proto.CompactTextString(m) }
func (*SpaceMakeShareableResponse) ProtoMessage()    {}
func (*SpaceMakeShareableResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{14}
}
func (m *SpaceMakeShareableResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceMakeShareableResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceMakeShareableResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceMakeShareableResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceMakeShareableResponse.Merge(m, src)
}
func (m *SpaceMakeShareableResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpaceMakeShareableResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceMakeShareableResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceMakeShareableResponse proto.InternalMessageInfo

type SpaceMakeUnshareableRequest struct {
	SpaceId string `protobuf:"bytes,1,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
	AclHead string `protobuf:"bytes,2,opt,name=aclHead,proto3" json:"aclHead,omitempty"`
}

func (m *SpaceMakeUnshareableRequest) Reset()         { *m = SpaceMakeUnshareableRequest{} }
func (m *SpaceMakeUnshareableRequest) String() string { return proto.CompactTextString(m) }
func (*SpaceMakeUnshareableRequest) ProtoMessage()    {}
func (*SpaceMakeUnshareableRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{15}
}
func (m *SpaceMakeUnshareableRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceMakeUnshareableRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceMakeUnshareableRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceMakeUnshareableRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceMakeUnshareableRequest.Merge(m, src)
}
func (m *SpaceMakeUnshareableRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpaceMakeUnshareableRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceMakeUnshareableRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceMakeUnshareableRequest proto.InternalMessageInfo

func (m *SpaceMakeUnshareableRequest) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

func (m *SpaceMakeUnshareableRequest) GetAclHead() string {
	if m != nil {
		return m.AclHead
	}
	return ""
}

type SpaceMakeUnshareableResponse struct {
}

func (m *SpaceMakeUnshareableResponse) Reset()         { *m = SpaceMakeUnshareableResponse{} }
func (m *SpaceMakeUnshareableResponse) String() string { return proto.CompactTextString(m) }
func (*SpaceMakeUnshareableResponse) ProtoMessage()    {}
func (*SpaceMakeUnshareableResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{16}
}
func (m *SpaceMakeUnshareableResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceMakeUnshareableResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceMakeUnshareableResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceMakeUnshareableResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceMakeUnshareableResponse.Merge(m, src)
}
func (m *SpaceMakeUnshareableResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpaceMakeUnshareableResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceMakeUnshareableResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceMakeUnshareableResponse proto.InternalMessageInfo

// NetworkConfigurationRequest contains currenId of the client configuration, it can be empty
type NetworkConfigurationRequest struct {
	// currenId of the client configuration
	// if the currentId is equal to the latest configuration id then the response will not contain a nodes list
	CurrentId string `protobuf:"bytes,1,opt,name=currentId,proto3" json:"currentId,omitempty"`
}

func (m *NetworkConfigurationRequest) Reset()         { *m = NetworkConfigurationRequest{} }
func (m *NetworkConfigurationRequest) String() string { return proto.CompactTextString(m) }
func (*NetworkConfigurationRequest) ProtoMessage()    {}
func (*NetworkConfigurationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{17}
}
func (m *NetworkConfigurationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkConfigurationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkConfigurationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkConfigurationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkConfigurationRequest.Merge(m, src)
}
func (m *NetworkConfigurationRequest) XXX_Size() int {
	return m.Size()
}
func (m *NetworkConfigurationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkConfigurationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkConfigurationRequest proto.InternalMessageInfo

func (m *NetworkConfigurationRequest) GetCurrentId() string {
	if m != nil {
		return m.CurrentId
	}
	return ""
}

// NetworkConfigurationResponse contains list of nodes
type NetworkConfigurationResponse struct {
	// id of current configuration
	ConfigurationId string `protobuf:"bytes,1,opt,name=configurationId,proto3" json:"configurationId,omitempty"`
	// network id
	NetworkId string `protobuf:"bytes,2,opt,name=networkId,proto3" json:"networkId,omitempty"`
	// nodes list - it will be empty if the client's currentId is equal configurationId
	Nodes []*Node `protobuf:"bytes,3,rep,name=nodes,proto3" json:"nodes,omitempty"`
	// unix timestamp of the creation time of configuration
	CreationTimeUnix uint64 `protobuf:"varint,4,opt,name=creationTimeUnix,proto3" json:"creationTimeUnix,omitempty"`
}

func (m *NetworkConfigurationResponse) Reset()         { *m = NetworkConfigurationResponse{} }
func (m *NetworkConfigurationResponse) String() string { return proto.CompactTextString(m) }
func (*NetworkConfigurationResponse) ProtoMessage()    {}
func (*NetworkConfigurationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{18}
}
func (m *NetworkConfigurationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkConfigurationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkConfigurationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkConfigurationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkConfigurationResponse.Merge(m, src)
}
func (m *NetworkConfigurationResponse) XXX_Size() int {
	return m.Size()
}
func (m *NetworkConfigurationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkConfigurationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkConfigurationResponse proto.InternalMessageInfo

func (m *NetworkConfigurationResponse) GetConfigurationId() string {
	if m != nil {
		return m.ConfigurationId
	}
	return ""
}

func (m *NetworkConfigurationResponse) GetNetworkId() string {
	if m != nil {
		return m.NetworkId
	}
	return ""
}

func (m *NetworkConfigurationResponse) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *NetworkConfigurationResponse) GetCreationTimeUnix() uint64 {
	if m != nil {
		return m.CreationTimeUnix
	}
	return 0
}

// Node describes one node in the network
type Node struct {
	// peerId - it's a peer identifier (libp2p format string) so it's an encoded publicKey
	PeerId string `protobuf:"bytes,1,opt,name=peerId,proto3" json:"peerId,omitempty"`
	// list of node addresses
	Addresses []string `protobuf:"bytes,2,rep,name=addresses,proto3" json:"addresses,omitempty"`
	// list of supported APIs
	Types []NodeType `protobuf:"varint,3,rep,packed,name=types,proto3,enum=coordinator.NodeType" json:"types,omitempty"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{19}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetPeerId() string {
	if m != nil {
		return m.PeerId
	}
	return ""
}

func (m *Node) GetAddresses() []string {
	if m != nil {
		return m.Addresses
	}
	return nil
}

func (m *Node) GetTypes() []NodeType {
	if m != nil {
		return m.Types
	}
	return nil
}

// DeletionConfirmPayloadWithSignature contains protobuf encoded deletion payload and its signature
type DeletionConfirmPayloadWithSignature struct {
	DeletionPayload []byte `protobuf:"bytes,1,opt,name=deletionPayload,proto3" json:"deletionPayload,omitempty"`
	Signature       []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *DeletionConfirmPayloadWithSignature) Reset()         { *m = DeletionConfirmPayloadWithSignature{} }
func (m *DeletionConfirmPayloadWithSignature) String() string { return proto.CompactTextString(m) }
func (*DeletionConfirmPayloadWithSignature) ProtoMessage()    {}
func (*DeletionConfirmPayloadWithSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{20}
}
func (m *DeletionConfirmPayloadWithSignature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeletionConfirmPayloadWithSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeletionConfirmPayloadWithSignature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeletionConfirmPayloadWithSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeletionConfirmPayloadWithSignature.Merge(m, src)
}
func (m *DeletionConfirmPayloadWithSignature) XXX_Size() int {
	return m.Size()
}
func (m *DeletionConfirmPayloadWithSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_DeletionConfirmPayloadWithSignature.DiscardUnknown(m)
}

var xxx_messageInfo_DeletionConfirmPayloadWithSignature proto.InternalMessageInfo

func (m *DeletionConfirmPayloadWithSignature) GetDeletionPayload() []byte {
	if m != nil {
		return m.DeletionPayload
	}
	return nil
}

func (m *DeletionConfirmPayloadWithSignature) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// DeletionConfirmPayload contains payload for deletion confirmation
type DeletionConfirmPayload struct {
	// SpaceId is the identifier of space
	SpaceId string `protobuf:"bytes,1,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
	// PeerId of receipt requester
	PeerId string `protobuf:"bytes,2,opt,name=peerId,proto3" json:"peerId,omitempty"`
	// AccountIdentity is an identity of a space owner
	AccountIdentity []byte `protobuf:"bytes,3,opt,name=accountIdentity,proto3" json:"accountIdentity,omitempty"`
	// NetworkId is the id of a network where the deletion was requested
	NetworkId string `protobuf:"bytes,4,opt,name=networkId,proto3" json:"networkId,omitempty"`
	// Timestamp is a timestamp when the deletion was requested
	Timestamp int64 `protobuf:"varint,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *DeletionConfirmPayload) Reset()         { *m = DeletionConfirmPayload{} }
func (m *DeletionConfirmPayload) String() string { return proto.CompactTextString(m) }
func (*DeletionConfirmPayload) ProtoMessage()    {}
func (*DeletionConfirmPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{21}
}
func (m *DeletionConfirmPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeletionConfirmPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeletionConfirmPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeletionConfirmPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeletionConfirmPayload.Merge(m, src)
}
func (m *DeletionConfirmPayload) XXX_Size() int {
	return m.Size()
}
func (m *DeletionConfirmPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_DeletionConfirmPayload.DiscardUnknown(m)
}

var xxx_messageInfo_DeletionConfirmPayload proto.InternalMessageInfo

func (m *DeletionConfirmPayload) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

func (m *DeletionConfirmPayload) GetPeerId() string {
	if m != nil {
		return m.PeerId
	}
	return ""
}

func (m *DeletionConfirmPayload) GetAccountIdentity() []byte {
	if m != nil {
		return m.AccountIdentity
	}
	return nil
}

func (m *DeletionConfirmPayload) GetNetworkId() string {
	if m != nil {
		return m.NetworkId
	}
	return ""
}

func (m *DeletionConfirmPayload) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

type DeletionLogRequest struct {
	// AfterId is the last known logId to request records after this id. If it is empty will be returned a list from the beginning.
	AfterId string `protobuf:"bytes,1,opt,name=afterId,proto3" json:"afterId,omitempty"`
	// Limit is a desired record count in response
	Limit uint32 `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *DeletionLogRequest) Reset()         { *m = DeletionLogRequest{} }
func (m *DeletionLogRequest) String() string { return proto.CompactTextString(m) }
func (*DeletionLogRequest) ProtoMessage()    {}
func (*DeletionLogRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{22}
}
func (m *DeletionLogRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeletionLogRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeletionLogRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeletionLogRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeletionLogRequest.Merge(m, src)
}
func (m *DeletionLogRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeletionLogRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeletionLogRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeletionLogRequest proto.InternalMessageInfo

func (m *DeletionLogRequest) GetAfterId() string {
	if m != nil {
		return m.AfterId
	}
	return ""
}

func (m *DeletionLogRequest) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type DeletionLogResponse struct {
	// DeletionLogRecord list of records, if there are no new records will be empty
	Records []*DeletionLogRecord `protobuf:"bytes,1,rep,name=records,proto3" json:"records,omitempty"`
	// HasMore indicates if there are records left
	HasMore bool `protobuf:"varint,2,opt,name=hasMore,proto3" json:"hasMore,omitempty"`
}

func (m *DeletionLogResponse) Reset()         { *m = DeletionLogResponse{} }
func (m *DeletionLogResponse) String() string { return proto.CompactTextString(m) }
func (*DeletionLogResponse) ProtoMessage()    {}
func (*DeletionLogResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{23}
}
func (m *DeletionLogResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeletionLogResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeletionLogResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeletionLogResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeletionLogResponse.Merge(m, src)
}
func (m *DeletionLogResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeletionLogResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeletionLogResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeletionLogResponse proto.InternalMessageInfo

func (m *DeletionLogResponse) GetRecords() []*DeletionLogRecord {
	if m != nil {
		return m.Records
	}
	return nil
}

func (m *DeletionLogResponse) GetHasMore() bool {
	if m != nil {
		return m.HasMore
	}
	return false
}

type DeletionLogRecord struct {
	// Id is a record id
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// SpaceId is a space identifier
	SpaceId string `protobuf:"bytes,2,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
	// DeletionLogRecordStatus is a space status
	Status DeletionLogRecordStatus `protobuf:"varint,3,opt,name=status,proto3,enum=coordinator.DeletionLogRecordStatus" json:"status,omitempty"`
	// Timestamp is a unixtimestamp of record creation
	Timestamp int64 `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// FileGroup is a key of group for file nodes
	FileGroup string `protobuf:"bytes,5,opt,name=fileGroup,proto3" json:"fileGroup,omitempty"`
}

func (m *DeletionLogRecord) Reset()         { *m = DeletionLogRecord{} }
func (m *DeletionLogRecord) String() string { return proto.CompactTextString(m) }
func (*DeletionLogRecord) ProtoMessage()    {}
func (*DeletionLogRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{24}
}
func (m *DeletionLogRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeletionLogRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeletionLogRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeletionLogRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeletionLogRecord.Merge(m, src)
}
func (m *DeletionLogRecord) XXX_Size() int {
	return m.Size()
}
func (m *DeletionLogRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_DeletionLogRecord.DiscardUnknown(m)
}

var xxx_messageInfo_DeletionLogRecord proto.InternalMessageInfo

func (m *DeletionLogRecord) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DeletionLogRecord) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

func (m *DeletionLogRecord) GetStatus() DeletionLogRecordStatus {
	if m != nil {
		return m.Status
	}
	return DeletionLogRecordStatus_Ok
}

func (m *DeletionLogRecord) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *DeletionLogRecord) GetFileGroup() string {
	if m != nil {
		return m.FileGroup
	}
	return ""
}

// SpaceDeleteRequest contains the deletion confirmation for the space to be deleted
type SpaceDeleteRequest struct {
	SpaceId           string `protobuf:"bytes,1,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
	DeletionPayloadId string `protobuf:"bytes,2,opt,name=deletionPayloadId,proto3" json:"deletionPayloadId,omitempty"`
	DeletionPayload   []byte `protobuf:"bytes,3,opt,name=deletionPayload,proto3" json:"deletionPayload,omitempty"`
	DeletionDuration  int64  `protobuf:"varint,4,opt,name=deletionDuration,proto3" json:"deletionDuration,omitempty"`
}

func (m *SpaceDeleteRequest) Reset()         { *m = SpaceDeleteRequest{} }
func (m *SpaceDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*SpaceDeleteRequest) ProtoMessage()    {}
func (*SpaceDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{25}
}
func (m *SpaceDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceDeleteRequest.Merge(m, src)
}
func (m *SpaceDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpaceDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceDeleteRequest proto.InternalMessageInfo

func (m *SpaceDeleteRequest) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

func (m *SpaceDeleteRequest) GetDeletionPayloadId() string {
	if m != nil {
		return m.DeletionPayloadId
	}
	return ""
}

func (m *SpaceDeleteRequest) GetDeletionPayload() []byte {
	if m != nil {
		return m.DeletionPayload
	}
	return nil
}

func (m *SpaceDeleteRequest) GetDeletionDuration() int64 {
	if m != nil {
		return m.DeletionDuration
	}
	return 0
}

// SpaceDeleteResponse contains timestamp when the space is finally deleted
type SpaceDeleteResponse struct {
	ToBeDeletedTimestamp int64 `protobuf:"varint,1,opt,name=toBeDeletedTimestamp,proto3" json:"toBeDeletedTimestamp,omitempty"`
}

func (m *SpaceDeleteResponse) Reset()         { *m = SpaceDeleteResponse{} }
func (m *SpaceDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*SpaceDeleteResponse) ProtoMessage()    {}
func (*SpaceDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{26}
}
func (m *SpaceDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceDeleteResponse.Merge(m, src)
}
func (m *SpaceDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpaceDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceDeleteResponse proto.InternalMessageInfo

func (m *SpaceDeleteResponse) GetToBeDeletedTimestamp() int64 {
	if m != nil {
		return m.ToBeDeletedTimestamp
	}
	return 0
}

// AccountDeleteRequest contains payload for account deletion
type AccountDeleteRequest struct {
	DeletionPayloadId string `protobuf:"bytes,1,opt,name=deletionPayloadId,proto3" json:"deletionPayloadId,omitempty"`
	DeletionPayload   []byte `protobuf:"bytes,2,opt,name=deletionPayload,proto3" json:"deletionPayload,omitempty"`
}

func (m *AccountDeleteRequest) Reset()         { *m = AccountDeleteRequest{} }
func (m *AccountDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*AccountDeleteRequest) ProtoMessage()    {}
func (*AccountDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{27}
}
func (m *AccountDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountDeleteRequest.Merge(m, src)
}
func (m *AccountDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *AccountDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AccountDeleteRequest proto.InternalMessageInfo

func (m *AccountDeleteRequest) GetDeletionPayloadId() string {
	if m != nil {
		return m.DeletionPayloadId
	}
	return ""
}

func (m *AccountDeleteRequest) GetDeletionPayload() []byte {
	if m != nil {
		return m.DeletionPayload
	}
	return nil
}

// AccountDeletionConfirmPayload contains payload for deletion confirmation
type AccountDeletionConfirmPayload struct {
	// PeerId of receipt requester
	PeerId string `protobuf:"bytes,1,opt,name=peerId,proto3" json:"peerId,omitempty"`
	// AccountIdentity is an identity of a space owner
	AccountIdentity []byte `protobuf:"bytes,2,opt,name=accountIdentity,proto3" json:"accountIdentity,omitempty"`
	// NetworkId is the id of a network where the deletion was requested
	NetworkId string `protobuf:"bytes,3,opt,name=networkId,proto3" json:"networkId,omitempty"`
	// Timestamp is a timestamp when the deletion was requested
	Timestamp int64 `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *AccountDeletionConfirmPayload) Reset()         { *m = AccountDeletionConfirmPayload{} }
func (m *AccountDeletionConfirmPayload) String() string { return proto.CompactTextString(m) }
func (*AccountDeletionConfirmPayload) ProtoMessage()    {}
func (*AccountDeletionConfirmPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{28}
}
func (m *AccountDeletionConfirmPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountDeletionConfirmPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountDeletionConfirmPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountDeletionConfirmPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountDeletionConfirmPayload.Merge(m, src)
}
func (m *AccountDeletionConfirmPayload) XXX_Size() int {
	return m.Size()
}
func (m *AccountDeletionConfirmPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountDeletionConfirmPayload.DiscardUnknown(m)
}

var xxx_messageInfo_AccountDeletionConfirmPayload proto.InternalMessageInfo

func (m *AccountDeletionConfirmPayload) GetPeerId() string {
	if m != nil {
		return m.PeerId
	}
	return ""
}

func (m *AccountDeletionConfirmPayload) GetAccountIdentity() []byte {
	if m != nil {
		return m.AccountIdentity
	}
	return nil
}

func (m *AccountDeletionConfirmPayload) GetNetworkId() string {
	if m != nil {
		return m.NetworkId
	}
	return ""
}

func (m *AccountDeletionConfirmPayload) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

// AccountDeleteResponse contains timestamp when the account is finally deleted
type AccountDeleteResponse struct {
	ToBeDeletedTimestamp int64 `protobuf:"varint,1,opt,name=toBeDeletedTimestamp,proto3" json:"toBeDeletedTimestamp,omitempty"`
}

func (m *AccountDeleteResponse) Reset()         { *m = AccountDeleteResponse{} }
func (m *AccountDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*AccountDeleteResponse) ProtoMessage()    {}
func (*AccountDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{29}
}
func (m *AccountDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountDeleteResponse.Merge(m, src)
}
func (m *AccountDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *AccountDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AccountDeleteResponse proto.InternalMessageInfo

func (m *AccountDeleteResponse) GetToBeDeletedTimestamp() int64 {
	if m != nil {
		return m.ToBeDeletedTimestamp
	}
	return 0
}

// AccountRevertDeletionRequest is a request to revert an account deletion
type AccountRevertDeletionRequest struct {
}

func (m *AccountRevertDeletionRequest) Reset()         { *m = AccountRevertDeletionRequest{} }
func (m *AccountRevertDeletionRequest) String() string { return proto.CompactTextString(m) }
func (*AccountRevertDeletionRequest) ProtoMessage()    {}
func (*AccountRevertDeletionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{30}
}
func (m *AccountRevertDeletionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountRevertDeletionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountRevertDeletionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountRevertDeletionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountRevertDeletionRequest.Merge(m, src)
}
func (m *AccountRevertDeletionRequest) XXX_Size() int {
	return m.Size()
}
func (m *AccountRevertDeletionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountRevertDeletionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AccountRevertDeletionRequest proto.InternalMessageInfo

// AccountRevertDeletionResponse is an empty response confirming that the deletion is reverted
type AccountRevertDeletionResponse struct {
}

func (m *AccountRevertDeletionResponse) Reset()         { *m = AccountRevertDeletionResponse{} }
func (m *AccountRevertDeletionResponse) String() string { return proto.CompactTextString(m) }
func (*AccountRevertDeletionResponse) ProtoMessage()    {}
func (*AccountRevertDeletionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{31}
}
func (m *AccountRevertDeletionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountRevertDeletionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountRevertDeletionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountRevertDeletionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountRevertDeletionResponse.Merge(m, src)
}
func (m *AccountRevertDeletionResponse) XXX_Size() int {
	return m.Size()
}
func (m *AccountRevertDeletionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountRevertDeletionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AccountRevertDeletionResponse proto.InternalMessageInfo

// AclAddRecordRequest contains marshaled consensusproto.RawRecord
type AclAddRecordRequest struct {
	SpaceId string `protobuf:"bytes,1,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
	Payload []byte `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *AclAddRecordRequest) Reset()         { *m = AclAddRecordRequest{} }
func (m *AclAddRecordRequest) String() string { return proto.CompactTextString(m) }
func (*AclAddRecordRequest) ProtoMessage()    {}
func (*AclAddRecordRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{32}
}
func (m *AclAddRecordRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AclAddRecordRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AclAddRecordRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AclAddRecordRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AclAddRecordRequest.Merge(m, src)
}
func (m *AclAddRecordRequest) XXX_Size() int {
	return m.Size()
}
func (m *AclAddRecordRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AclAddRecordRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AclAddRecordRequest proto.InternalMessageInfo

func (m *AclAddRecordRequest) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

func (m *AclAddRecordRequest) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

// AclAddRecordResponse contains created record id and marshaled consensusproto.RawRecord
type AclAddRecordResponse struct {
	RecordId string `protobuf:"bytes,1,opt,name=recordId,proto3" json:"recordId,omitempty"`
	Payload  []byte `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *AclAddRecordResponse) Reset()         { *m = AclAddRecordResponse{} }
func (m *AclAddRecordResponse) String() string { return proto.CompactTextString(m) }
func (*AclAddRecordResponse) ProtoMessage()    {}
func (*AclAddRecordResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{33}
}
func (m *AclAddRecordResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AclAddRecordResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AclAddRecordResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AclAddRecordResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AclAddRecordResponse.Merge(m, src)
}
func (m *AclAddRecordResponse) XXX_Size() int {
	return m.Size()
}
func (m *AclAddRecordResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AclAddRecordResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AclAddRecordResponse proto.InternalMessageInfo

func (m *AclAddRecordResponse) GetRecordId() string {
	if m != nil {
		return m.RecordId
	}
	return ""
}

func (m *AclAddRecordResponse) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

// AclGetRecordsRequest can optionally contain the last known aclHead, the server will return only new records or an empty list if there are no new records.
// If aclHead is not provided the whole list will be returned.
type AclGetRecordsRequest struct {
	SpaceId string `protobuf:"bytes,1,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
	AclHead string `protobuf:"bytes,2,opt,name=aclHead,proto3" json:"aclHead,omitempty"`
}

func (m *AclGetRecordsRequest) Reset()         { *m = AclGetRecordsRequest{} }
func (m *AclGetRecordsRequest) String() string { return proto.CompactTextString(m) }
func (*AclGetRecordsRequest) ProtoMessage()    {}
func (*AclGetRecordsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{34}
}
func (m *AclGetRecordsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AclGetRecordsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AclGetRecordsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AclGetRecordsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AclGetRecordsRequest.Merge(m, src)
}
func (m *AclGetRecordsRequest) XXX_Size() int {
	return m.Size()
}
func (m *AclGetRecordsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AclGetRecordsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AclGetRecordsRequest proto.InternalMessageInfo

func (m *AclGetRecordsRequest) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

func (m *AclGetRecordsRequest) GetAclHead() string {
	if m != nil {
		return m.AclHead
	}
	return ""
}

// AclGetRecordsResponse contains list of marshaled consensusproto.RawRecordWithId
type AclGetRecordsResponse struct {
	Records [][]byte `protobuf:"bytes,1,rep,name=records,proto3" json:"records,omitempty"`
}

func (m *AclGetRecordsResponse) Reset()         { *m = AclGetRecordsResponse{} }
func (m *AclGetRecordsResponse) String() string { return proto.CompactTextString(m) }
func (*AclGetRecordsResponse) ProtoMessage()    {}
func (*AclGetRecordsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{35}
}
func (m *AclGetRecordsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AclGetRecordsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AclGetRecordsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AclGetRecordsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AclGetRecordsResponse.Merge(m, src)
}
func (m *AclGetRecordsResponse) XXX_Size() int {
	return m.Size()
}
func (m *AclGetRecordsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AclGetRecordsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AclGetRecordsResponse proto.InternalMessageInfo

func (m *AclGetRecordsResponse) GetRecords() [][]byte {
	if m != nil {
		return m.Records
	}
	return nil
}

type AccountLimitsSetRequest struct {
	Identity              string `protobuf:"bytes,1,opt,name=identity,proto3" json:"identity,omitempty"`
	Reason                string `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	FileStorageLimitBytes uint64 `protobuf:"varint,3,opt,name=fileStorageLimitBytes,proto3" json:"fileStorageLimitBytes,omitempty"`
	SpaceMembersRead      uint32 `protobuf:"varint,4,opt,name=spaceMembersRead,proto3" json:"spaceMembersRead,omitempty"`
	SpaceMembersWrite     uint32 `protobuf:"varint,5,opt,name=spaceMembersWrite,proto3" json:"spaceMembersWrite,omitempty"`
	SharedSpacesLimit     uint32 `protobuf:"varint,6,opt,name=sharedSpacesLimit,proto3" json:"sharedSpacesLimit,omitempty"`
}

func (m *AccountLimitsSetRequest) Reset()         { *m = AccountLimitsSetRequest{} }
func (m *AccountLimitsSetRequest) String() string { return proto.CompactTextString(m) }
func (*AccountLimitsSetRequest) ProtoMessage()    {}
func (*AccountLimitsSetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{36}
}
func (m *AccountLimitsSetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountLimitsSetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountLimitsSetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountLimitsSetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountLimitsSetRequest.Merge(m, src)
}
func (m *AccountLimitsSetRequest) XXX_Size() int {
	return m.Size()
}
func (m *AccountLimitsSetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountLimitsSetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AccountLimitsSetRequest proto.InternalMessageInfo

func (m *AccountLimitsSetRequest) GetIdentity() string {
	if m != nil {
		return m.Identity
	}
	return ""
}

func (m *AccountLimitsSetRequest) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *AccountLimitsSetRequest) GetFileStorageLimitBytes() uint64 {
	if m != nil {
		return m.FileStorageLimitBytes
	}
	return 0
}

func (m *AccountLimitsSetRequest) GetSpaceMembersRead() uint32 {
	if m != nil {
		return m.SpaceMembersRead
	}
	return 0
}

func (m *AccountLimitsSetRequest) GetSpaceMembersWrite() uint32 {
	if m != nil {
		return m.SpaceMembersWrite
	}
	return 0
}

func (m *AccountLimitsSetRequest) GetSharedSpacesLimit() uint32 {
	if m != nil {
		return m.SharedSpacesLimit
	}
	return 0
}

type AccountLimitsSetResponse struct {
}

func (m *AccountLimitsSetResponse) Reset()         { *m = AccountLimitsSetResponse{} }
func (m *AccountLimitsSetResponse) String() string { return proto.CompactTextString(m) }
func (*AccountLimitsSetResponse) ProtoMessage()    {}
func (*AccountLimitsSetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{37}
}
func (m *AccountLimitsSetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountLimitsSetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountLimitsSetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountLimitsSetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountLimitsSetResponse.Merge(m, src)
}
func (m *AccountLimitsSetResponse) XXX_Size() int {
	return m.Size()
}
func (m *AccountLimitsSetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountLimitsSetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AccountLimitsSetResponse proto.InternalMessageInfo

type AclEventLogRequest struct {
	AccountIdentity string `protobuf:"bytes,1,opt,name=accountIdentity,proto3" json:"accountIdentity,omitempty"`
	// AfterId is the last known logId to request records after this id. If it is empty will be returned a list from the beginning.
	AfterId string `protobuf:"bytes,2,opt,name=afterId,proto3" json:"afterId,omitempty"`
	// Limit is a desired record count in response
	Limit uint32 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *AclEventLogRequest) Reset()         { *m = AclEventLogRequest{} }
func (m *AclEventLogRequest) String() string { return proto.CompactTextString(m) }
func (*AclEventLogRequest) ProtoMessage()    {}
func (*AclEventLogRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{38}
}
func (m *AclEventLogRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AclEventLogRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AclEventLogRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AclEventLogRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AclEventLogRequest.Merge(m, src)
}
func (m *AclEventLogRequest) XXX_Size() int {
	return m.Size()
}
func (m *AclEventLogRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AclEventLogRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AclEventLogRequest proto.InternalMessageInfo

func (m *AclEventLogRequest) GetAccountIdentity() string {
	if m != nil {
		return m.AccountIdentity
	}
	return ""
}

func (m *AclEventLogRequest) GetAfterId() string {
	if m != nil {
		return m.AfterId
	}
	return ""
}

func (m *AclEventLogRequest) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type AclEventLogResponse struct {
	// AclEventLogRecord list of records, if there are no new records will be empty
	Records []*AclEventLogRecord `protobuf:"bytes,1,rep,name=records,proto3" json:"records,omitempty"`
	// HasMore indicates if there are records left
	HasMore bool `protobuf:"varint,2,opt,name=hasMore,proto3" json:"hasMore,omitempty"`
}

func (m *AclEventLogResponse) Reset()         { *m = AclEventLogResponse{} }
func (m *AclEventLogResponse) String() string { return proto.CompactTextString(m) }
func (*AclEventLogResponse) ProtoMessage()    {}
func (*AclEventLogResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{39}
}
func (m *AclEventLogResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AclEventLogResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AclEventLogResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AclEventLogResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AclEventLogResponse.Merge(m, src)
}
func (m *AclEventLogResponse) XXX_Size() int {
	return m.Size()
}
func (m *AclEventLogResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AclEventLogResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AclEventLogResponse proto.InternalMessageInfo

func (m *AclEventLogResponse) GetRecords() []*AclEventLogRecord {
	if m != nil {
		return m.Records
	}
	return nil
}

func (m *AclEventLogResponse) GetHasMore() bool {
	if m != nil {
		return m.HasMore
	}
	return false
}

type AclEventLogRecord struct {
	// Id is a record id
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// SpaceId is a space identifier
	SpaceId string `protobuf:"bytes,2,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
	// Timestamp is a unixtimestamp of record creation
	Timestamp int64 `protobuf:"varint,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Type of current event
	Type AclEventLogRecordType `protobuf:"varint,4,opt,name=type,proto3,enum=coordinator.AclEventLogRecordType" json:"type,omitempty"`
	// only for RecordTypeSpaceAclAddRecord
	AclChangeId string `protobuf:"bytes,5,opt,name=aclChangeId,proto3" json:"aclChangeId,omitempty"`
}

func (m *AclEventLogRecord) Reset()         { *m = AclEventLogRecord{} }
func (m *AclEventLogRecord) String() string { return proto.CompactTextString(m) }
func (*AclEventLogRecord) ProtoMessage()    {}
func (*AclEventLogRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{40}
}
func (m *AclEventLogRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AclEventLogRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AclEventLogRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AclEventLogRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AclEventLogRecord.Merge(m, src)
}
func (m *AclEventLogRecord) XXX_Size() int {
	return m.Size()
}
func (m *AclEventLogRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_AclEventLogRecord.DiscardUnknown(m)
}

var xxx_messageInfo_AclEventLogRecord proto.InternalMessageInfo

func (m *AclEventLogRecord) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AclEventLogRecord) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

func (m *AclEventLogRecord) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *AclEventLogRecord) GetType() AclEventLogRecordType {
	if m != nil {
		return m.Type
	}
	return AclEventLogRecordType_RecordTypeSpaceReceipt
}

func (m *AclEventLogRecord) GetAclChangeId() string {
	if m != nil {
		return m.AclChangeId
	}
	return ""
}

func init() {
	proto.RegisterEnum("coordinator.ErrorCodes", ErrorCodes_name, ErrorCodes_value)
	proto.RegisterEnum("coordinator.SpaceStatus", SpaceStatus_name, SpaceStatus_value)
	proto.RegisterEnum("coordinator.SpacePermissions", SpacePermissions_name, SpacePermissions_value)
	proto.RegisterEnum("coordinator.NodeType", NodeType_name, NodeType_value)
	proto.RegisterEnum("coordinator.DeletionPayloadType", DeletionPayloadType_name, DeletionPayloadType_value)
	proto.RegisterEnum("coordinator.DeletionLogRecordStatus", DeletionLogRecordStatus_name, DeletionLogRecordStatus_value)
	proto.RegisterEnum("coordinator.AclEventLogRecordType", AclEventLogRecordType_name, AclEventLogRecordType_value)
	proto.RegisterType((*SpaceSignRequest)(nil), "coordinator.SpaceSignRequest")
	proto.RegisterType((*SpaceLimits)(nil), "coordinator.SpaceLimits")
	proto.RegisterType((*SpaceStatusPayload)(nil), "coordinator.SpaceStatusPayload")
	proto.RegisterType((*SpaceSignResponse)(nil), "coordinator.SpaceSignResponse")
	proto.RegisterType((*SpaceReceiptWithSignature)(nil), "coordinator.SpaceReceiptWithSignature")
	proto.RegisterType((*SpaceReceipt)(nil), "coordinator.SpaceReceipt")
	proto.RegisterType((*SpaceStatusCheckRequest)(nil), "coordinator.SpaceStatusCheckRequest")
	proto.RegisterType((*SpaceStatusCheckResponse)(nil), "coordinator.SpaceStatusCheckResponse")
	proto.RegisterType((*SpaceStatusCheckManyRequest)(nil), "coordinator.SpaceStatusCheckManyRequest")
	proto.RegisterType((*SpaceStatusCheckManyResponse)(nil), "coordinator.SpaceStatusCheckManyResponse")
	proto.RegisterType((*AccountLimits)(nil), "coordinator.AccountLimits")
	proto.RegisterType((*SpaceStatusChangeRequest)(nil), "coordinator.SpaceStatusChangeRequest")
	proto.RegisterType((*SpaceStatusChangeResponse)(nil), "coordinator.SpaceStatusChangeResponse")
	proto.RegisterType((*SpaceMakeShareableRequest)(nil), "coordinator.SpaceMakeShareableRequest")
	proto.RegisterType((*SpaceMakeShareableResponse)(nil), "coordinator.SpaceMakeShareableResponse")
	proto.RegisterType((*SpaceMakeUnshareableRequest)(nil), "coordinator.SpaceMakeUnshareableRequest")
	proto.RegisterType((*SpaceMakeUnshareableResponse)(nil), "coordinator.SpaceMakeUnshareableResponse")
	proto.RegisterType((*NetworkConfigurationRequest)(nil), "coordinator.NetworkConfigurationRequest")
	proto.RegisterType((*NetworkConfigurationResponse)(nil), "coordinator.NetworkConfigurationResponse")
	proto.RegisterType((*Node)(nil), "coordinator.Node")
	proto.RegisterType((*DeletionConfirmPayloadWithSignature)(nil), "coordinator.DeletionConfirmPayloadWithSignature")
	proto.RegisterType((*DeletionConfirmPayload)(nil), "coordinator.DeletionConfirmPayload")
	proto.RegisterType((*DeletionLogRequest)(nil), "coordinator.DeletionLogRequest")
	proto.RegisterType((*DeletionLogResponse)(nil), "coordinator.DeletionLogResponse")
	proto.RegisterType((*DeletionLogRecord)(nil), "coordinator.DeletionLogRecord")
	proto.RegisterType((*SpaceDeleteRequest)(nil), "coordinator.SpaceDeleteRequest")
	proto.RegisterType((*SpaceDeleteResponse)(nil), "coordinator.SpaceDeleteResponse")
	proto.RegisterType((*AccountDeleteRequest)(nil), "coordinator.AccountDeleteRequest")
	proto.RegisterType((*AccountDeletionConfirmPayload)(nil), "coordinator.AccountDeletionConfirmPayload")
	proto.RegisterType((*AccountDeleteResponse)(nil), "coordinator.AccountDeleteResponse")
	proto.RegisterType((*AccountRevertDeletionRequest)(nil), "coordinator.AccountRevertDeletionRequest")
	proto.RegisterType((*AccountRevertDeletionResponse)(nil), "coordinator.AccountRevertDeletionResponse")
	proto.RegisterType((*AclAddRecordRequest)(nil), "coordinator.AclAddRecordRequest")
	proto.RegisterType((*AclAddRecordResponse)(nil), "coordinator.AclAddRecordResponse")
	proto.RegisterType((*AclGetRecordsRequest)(nil), "coordinator.AclGetRecordsRequest")
	proto.RegisterType((*AclGetRecordsResponse)(nil), "coordinator.AclGetRecordsResponse")
	proto.RegisterType((*AccountLimitsSetRequest)(nil), "coordinator.AccountLimitsSetRequest")
	proto.RegisterType((*AccountLimitsSetResponse)(nil), "coordinator.AccountLimitsSetResponse")
	proto.RegisterType((*AclEventLogRequest)(nil), "coordinator.AclEventLogRequest")
	proto.RegisterType((*AclEventLogResponse)(nil), "coordinator.AclEventLogResponse")
	proto.RegisterType((*AclEventLogRecord)(nil), "coordinator.AclEventLogRecord")
}

func init() {
	proto.RegisterFile("coordinator/coordinatorproto/protos/coordinator.proto", fileDescriptor_d94f6f99586adae2)
}

var fileDescriptor_d94f6f99586adae2 = []byte{
	// 2031 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x19, 0x3d, 0x73, 0x1b, 0xc7,
	0x95, 0x77, 0x00, 0x49, 0xe0, 0x81, 0xa4, 0x8e, 0x4b, 0x52, 0x82, 0x21, 0x18, 0x82, 0x2f, 0x8e,
	0x4d, 0x23, 0x19, 0xdb, 0x81, 0x63, 0x4f, 0x34, 0x4e, 0x26, 0xa2, 0x28, 0xd9, 0x81, 0x22, 0x52,
	0xcc, 0x51, 0xb4, 0x67, 0xd2, 0x78, 0x8e, 0x77, 0x4b, 0xf2, 0x86, 0xc0, 0x1e, 0xb2, 0xb7, 0x24,
	0xc5, 0x3a, 0x65, 0x52, 0xa4, 0x4b, 0x9a, 0xf4, 0x29, 0x52, 0x64, 0x32, 0x93, 0x49, 0x91, 0x99,
	0xd4, 0x29, 0x5d, 0xa6, 0xf4, 0x48, 0x7f, 0x22, 0x65, 0x66, 0xf7, 0xf6, 0x0e, 0xbb, 0x7b, 0x07,
	0x10, 0x1e, 0x15, 0x6e, 0x48, 0xee, 0xfb, 0xde, 0x77, 0xef, 0x6b, 0x1f, 0xe1, 0xe3, 0x20, 0x8e,
	0x69, 0x18, 0x11, 0x9f, 0xc5, 0xf4, 0x03, 0xe5, 0xef, 0x31, 0x8d, 0x59, 0xfc, 0x81, 0xf8, 0x99,
	0xa8, 0xf0, 0xf7, 0x05, 0x08, 0x35, 0x14, 0x90, 0xfb, 0x6f, 0x0b, 0x9c, 0xc3, 0xb1, 0x1f, 0xe0,
	0xc3, 0xe8, 0x94, 0x78, 0xf8, 0x37, 0x17, 0x38, 0x61, 0xa8, 0x09, 0xcb, 0x09, 0x87, 0x0d, 0xc2,
	0xa6, 0xd5, 0xb5, 0xb6, 0xeb, 0x5e, 0x76, 0x44, 0xb7, 0x61, 0xe9, 0x0c, 0xfb, 0x21, 0xa6, 0x4d,
	0xbb, 0x6b, 0x6d, 0xaf, 0x78, 0xf2, 0x84, 0xba, 0xd0, 0x88, 0x87, 0xe1, 0x20, 0xc4, 0x84, 0x45,
	0xec, 0xba, 0x59, 0x11, 0x48, 0x15, 0x84, 0xfa, 0xb0, 0x49, 0xf0, 0x55, 0x76, 0xe4, 0xda, 0x7c,
	0x76, 0x41, 0x71, 0xb3, 0x2a, 0x48, 0x4b, 0x71, 0xc8, 0x85, 0x95, 0x93, 0x98, 0x06, 0x58, 0xda,
	0xd5, 0x5c, 0xec, 0x5a, 0xdb, 0x35, 0x4f, 0x83, 0xb9, 0x87, 0xd0, 0x10, 0xf6, 0x3f, 0x8d, 0x46,
	0x11, 0x4b, 0xb8, 0x21, 0x14, 0xfb, 0xe1, 0x1e, 0x1e, 0x1d, 0x63, 0x9a, 0x08, 0xf3, 0x57, 0x3d,
	0x15, 0xc4, 0x85, 0x5e, 0xd1, 0x88, 0xe1, 0x8c, 0xc4, 0x16, 0x24, 0x1a, 0xcc, 0xfd, 0xad, 0x0d,
	0x28, 0xf5, 0x0a, 0xf3, 0xd9, 0x45, 0x72, 0xe0, 0x5f, 0x0f, 0x63, 0x3f, 0x44, 0x1f, 0xc2, 0x52,
	0x22, 0x00, 0x42, 0xee, 0x5a, 0xbf, 0xf9, 0xbe, 0xea, 0x5d, 0x85, 0xc1, 0x93, 0x74, 0xe8, 0x87,
	0xb0, 0x1e, 0xe2, 0x21, 0x66, 0x51, 0x4c, 0x9e, 0x47, 0x23, 0x9c, 0x30, 0x7f, 0x34, 0x16, 0x1a,
	0x2b, 0x5e, 0x11, 0x81, 0x7e, 0x0e, 0x8d, 0x31, 0xa6, 0xa3, 0x28, 0x49, 0xa2, 0x98, 0x24, 0xc2,
	0x8b, 0x6b, 0xfd, 0x37, 0x8b, 0x4a, 0x0e, 0x26, 0x44, 0x9e, 0xca, 0xc1, 0x0d, 0x1c, 0x0a, 0x3f,
	0x08, 0xb7, 0x36, 0xca, 0x0c, 0x4c, 0xfd, 0xe4, 0x49, 0x3a, 0xd4, 0x82, 0x5a, 0x94, 0x1c, 0x9e,
	0xf9, 0x14, 0x87, 0xd2, 0xbd, 0xf9, 0xd9, 0x3d, 0x82, 0x75, 0x25, 0x34, 0x92, 0x71, 0x4c, 0x12,
	0x8c, 0x1e, 0xc0, 0x32, 0xc5, 0x01, 0x8e, 0xc6, 0x4c, 0x38, 0xa1, 0xd1, 0x7f, 0xa7, 0xa8, 0xc3,
	0x4b, 0x09, 0xbe, 0x8c, 0xd8, 0x59, 0xfe, 0x31, 0xbd, 0x8c, 0xcd, 0x3d, 0x87, 0x37, 0xa6, 0x52,
	0xa1, 0x0f, 0x61, 0x23, 0x51, 0x90, 0xd2, 0xf3, 0x42, 0xd5, 0x8a, 0x57, 0x86, 0x42, 0x6d, 0xa8,
	0x27, 0x79, 0x34, 0xa5, 0x51, 0x39, 0x01, 0xb8, 0x7f, 0xb1, 0x60, 0x45, 0xd5, 0x36, 0x3b, 0xb6,
	0xc7, 0x18, 0xd3, 0x41, 0x28, 0xa4, 0xd4, 0x3d, 0x79, 0x42, 0xdb, 0x70, 0xcb, 0x0f, 0x82, 0xf8,
	0x82, 0x30, 0x23, 0xbe, 0x4d, 0x30, 0x37, 0x85, 0x60, 0x76, 0x15, 0xd3, 0xf3, 0x41, 0x28, 0xbe,
	0x40, 0xdd, 0x9b, 0x00, 0x50, 0x07, 0xe0, 0xd2, 0x1f, 0x46, 0xe1, 0x11, 0x61, 0xd1, 0x50, 0x38,
	0xbb, 0xea, 0x29, 0x10, 0xf7, 0x23, 0xb8, 0xa3, 0x84, 0xd0, 0xee, 0x19, 0x0e, 0xce, 0x6f, 0x4c,
	0x48, 0xf7, 0x08, 0x9a, 0x45, 0x26, 0xf9, 0xa9, 0xee, 0xc3, 0xf2, 0x58, 0xf1, 0x5f, 0xa3, 0x7f,
	0x6f, 0x5a, 0xbc, 0x4a, 0x5f, 0x7a, 0x19, 0xbd, 0x7b, 0x1f, 0xee, 0x9a, 0x62, 0xf7, 0x7c, 0x72,
	0x9d, 0xd9, 0xd3, 0x82, 0x9a, 0x34, 0x80, 0xa7, 0x42, 0x65, 0xbb, 0xee, 0xe5, 0x67, 0xf7, 0xcf,
	0x16, 0xb4, 0xcb, 0x79, 0xa5, 0x59, 0x9f, 0x42, 0x4d, 0xaa, 0x49, 0x99, 0xe7, 0xb0, 0x2b, 0x67,
	0x40, 0x0f, 0x60, 0x55, 0x7a, 0x3d, 0x0d, 0x64, 0xf1, 0xad, 0x1a, 0xfd, 0x96, 0x26, 0x61, 0x47,
	0xa5, 0xf0, 0x74, 0x06, 0xf7, 0x67, 0xb0, 0xaa, 0xe1, 0x79, 0x8e, 0x26, 0x22, 0xe0, 0x85, 0xe2,
	0x44, 0x40, 0x65, 0xe1, 0x28, 0x22, 0xdc, 0x6f, 0x2c, 0xc3, 0xe3, 0x3e, 0x39, 0xc5, 0x37, 0x17,
	0x4e, 0xa5, 0x10, 0xc8, 0x4b, 0xe5, 0x71, 0x56, 0x44, 0xf0, 0x90, 0x33, 0x80, 0x59, 0xc8, 0x19,
	0x60, 0xe4, 0xc1, 0x86, 0x01, 0x7a, 0x7e, 0x3d, 0x4e, 0xab, 0xea, 0x5a, 0xbf, 0xab, 0x79, 0xe5,
	0x51, 0x91, 0xce, 0x2b, 0x63, 0x76, 0xbf, 0x90, 0x09, 0xaa, 0xdf, 0xf0, 0xf5, 0x83, 0xea, 0x63,
	0x29, 0x77, 0xcf, 0x3f, 0xc7, 0xa2, 0xc4, 0xf8, 0xc7, 0xc3, 0x9b, 0x5d, 0xe7, 0xb6, 0xa1, 0x55,
	0xc6, 0x96, 0xda, 0xe3, 0xfe, 0x4a, 0x46, 0x2a, 0xc7, 0x1e, 0x91, 0x64, 0x6e, 0xb1, 0x1c, 0xe3,
	0x07, 0xc3, 0x5f, 0x60, 0x3f, 0xfb, 0x0e, 0xd9, 0xd1, 0xed, 0xc8, 0x00, 0x2e, 0x88, 0x94, 0x2a,
	0x3f, 0x85, 0xbb, 0xfb, 0x69, 0x56, 0xef, 0xc6, 0xe4, 0x24, 0x3a, 0xbd, 0xa0, 0x3e, 0x77, 0x61,
	0xa6, 0xb2, 0x0d, 0xf5, 0xe0, 0x82, 0x52, 0xcc, 0x0b, 0x83, 0x54, 0x3a, 0x01, 0xb8, 0xff, 0xb2,
	0xa0, 0x5d, 0xce, 0x2d, 0x1d, 0xbc, 0x0d, 0xb7, 0x02, 0x15, 0x91, 0x0b, 0x31, 0xc1, 0x7a, 0xb9,
	0xb1, 0xcd, 0x72, 0xf3, 0x2e, 0x2c, 0x92, 0x38, 0xc4, 0xbc, 0x8d, 0xf0, 0x1c, 0x5b, 0xd7, 0x3e,
	0xd3, 0x7e, 0x1c, 0x62, 0x2f, 0xc5, 0xa3, 0x1e, 0x38, 0x01, 0xc5, 0x7e, 0xd6, 0x8a, 0x8e, 0x48,
	0xf4, 0x42, 0xc4, 0x4f, 0xd5, 0x2b, 0xc0, 0xdd, 0x08, 0xaa, 0x9c, 0x55, 0xa9, 0x95, 0x96, 0x56,
	0x2b, 0xdb, 0x50, 0xf7, 0xc3, 0x90, 0xe2, 0x24, 0xc1, 0x3c, 0x35, 0x79, 0x65, 0x98, 0x00, 0xd0,
	0x0f, 0x60, 0x91, 0x5d, 0x8f, 0xa5, 0x49, 0x6b, 0xfd, 0xad, 0x82, 0x49, 0x22, 0x26, 0x53, 0x1a,
	0x77, 0x04, 0xdf, 0xcb, 0x22, 0x56, 0x38, 0x8a, 0x8e, 0x64, 0x40, 0xe9, 0x0d, 0xa3, 0x24, 0x55,
	0xac, 0xf2, 0x54, 0x99, 0xdd, 0x28, 0xfe, 0x66, 0xc1, 0xed, 0x72, 0x7d, 0xdf, 0x61, 0xcb, 0x68,
	0x43, 0x9d, 0xe5, 0x63, 0xc3, 0xa2, 0x18, 0x1b, 0x26, 0x00, 0xf7, 0x11, 0xa0, 0xcc, 0xe2, 0xa7,
	0xf1, 0xa9, 0x12, 0xf1, 0xfe, 0x09, 0x53, 0xbe, 0x4d, 0x76, 0x44, 0x9b, 0xb0, 0x28, 0xba, 0xbe,
	0x1c, 0x79, 0xd2, 0x83, 0x1b, 0xc1, 0x86, 0x26, 0x45, 0x86, 0xe1, 0x4f, 0x44, 0x9f, 0x8f, 0x69,
	0x5e, 0xa4, 0x3b, 0xa5, 0xc5, 0x44, 0xb0, 0x70, 0x32, 0x2f, 0x23, 0xe7, 0x06, 0x9c, 0xf9, 0xc9,
	0x5e, 0x2c, 0xbd, 0x5c, 0xf3, 0xb2, 0xa3, 0xfb, 0x4f, 0x0b, 0xd6, 0x0b, 0x8c, 0x68, 0x0d, 0xec,
	0x28, 0xb3, 0xd5, 0x8e, 0x34, 0x77, 0xdb, 0xba, 0xbb, 0x7f, 0x9a, 0xcf, 0x5f, 0xe9, 0x68, 0xf4,
	0xf6, 0x6c, 0x93, 0x8c, 0x59, 0x4c, 0x73, 0x66, 0xd5, 0x70, 0x26, 0xc7, 0x9e, 0x44, 0x43, 0xfc,
	0x39, 0x8d, 0x2f, 0x52, 0x57, 0xd7, 0xbd, 0x09, 0xc0, 0xfd, 0xbb, 0x25, 0x07, 0x42, 0xa1, 0xe4,
	0x3b, 0xac, 0xf7, 0x3d, 0x70, 0x32, 0xd0, 0x23, 0x59, 0x09, 0xe4, 0x5d, 0x0a, 0x70, 0x77, 0x00,
	0x1b, 0x9a, 0xcd, 0xf2, 0xcb, 0xf6, 0x61, 0x93, 0xc5, 0x0f, 0x25, 0x34, 0x9c, 0x8c, 0xa5, 0x96,
	0x10, 0x53, 0x8a, 0x73, 0x09, 0x6c, 0xca, 0xa6, 0xa9, 0x3b, 0xa0, 0xf4, 0x9a, 0xd6, 0xb7, 0xb8,
	0xa6, 0x5d, 0x7a, 0x4d, 0x3e, 0x44, 0xbc, 0xa9, 0x2a, 0x2c, 0x26, 0xe5, 0xb4, 0x0a, 0x54, 0x92,
	0x7a, 0xf6, 0x1c, 0xa9, 0x57, 0x99, 0x99, 0x7a, 0x66, 0xb4, 0xb8, 0xbf, 0x84, 0x2d, 0xc3, 0x1f,
	0xaf, 0xe1, 0xdc, 0x0e, 0xb4, 0xa5, 0x30, 0x0f, 0x5f, 0x62, 0x9a, 0xdf, 0x38, 0x7b, 0xe2, 0xdc,
	0xcb, 0x7d, 0x61, 0xe2, 0x65, 0x43, 0x1a, 0xc0, 0xc6, 0x4e, 0x30, 0xdc, 0x09, 0x43, 0x99, 0x8a,
	0xf3, 0xf4, 0xbe, 0xb1, 0xf6, 0x01, 0xf2, 0x1e, 0xfd, 0x94, 0x7f, 0x68, 0x55, 0x94, 0xbc, 0x57,
	0x0b, 0x6a, 0x69, 0x7e, 0xe7, 0xc2, 0xf2, 0xf3, 0x0c, 0x69, 0x4f, 0x84, 0xb4, 0xcf, 0x31, 0x4b,
	0xa5, 0x25, 0xaf, 0xd3, 0x95, 0x7f, 0xc4, 0x5d, 0xae, 0xc9, 0x92, 0xa6, 0x35, 0xf5, 0x4a, 0xb5,
	0x92, 0x57, 0x22, 0xf7, 0x77, 0x36, 0xdc, 0xd1, 0x66, 0xbd, 0x43, 0xce, 0x9d, 0x8f, 0xb0, 0x51,
	0x16, 0x20, 0xf2, 0x42, 0xd9, 0x99, 0xc7, 0x16, 0xc5, 0x7e, 0x12, 0x93, 0xac, 0xac, 0xa7, 0x27,
	0xf4, 0x63, 0xd8, 0xe2, 0x25, 0xe1, 0x90, 0xc5, 0xd4, 0x3f, 0x4d, 0x5f, 0x52, 0x0f, 0xaf, 0x19,
	0x4e, 0xcb, 0x51, 0xd5, 0x2b, 0x47, 0xf2, 0x94, 0x15, 0xb7, 0x93, 0x8f, 0x4b, 0x8f, 0xdf, 0xad,
	0x2a, 0x2a, 0x70, 0x01, 0x2e, 0x66, 0x51, 0x05, 0xf6, 0x25, 0x7f, 0x94, 0x8a, 0x6a, 0xc4, 0x67,
	0x51, 0x13, 0x51, 0x3e, 0xb9, 0x2e, 0x4d, 0x9b, 0x5c, 0x5b, 0xd0, 0x2c, 0x3a, 0x43, 0x46, 0x10,
	0x01, 0xb4, 0x13, 0x0c, 0x1f, 0x5f, 0x62, 0xc2, 0x94, 0x56, 0x52, 0x92, 0x4b, 0x72, 0x14, 0x31,
	0x73, 0x49, 0x69, 0x3a, 0xf6, 0x94, 0xa6, 0x53, 0x31, 0x9a, 0x8e, 0xa6, 0x6f, 0xbe, 0xa6, 0xa3,
	0xb1, 0xcc, 0xdb, 0x74, 0xfe, 0x61, 0xc1, 0x7a, 0x81, 0xf1, 0x5b, 0x34, 0x1d, 0xad, 0x10, 0x54,
	0xcc, 0xb6, 0xf1, 0x09, 0x54, 0xd9, 0x64, 0xe0, 0x76, 0x67, 0x9b, 0x2b, 0xc6, 0x1b, 0x41, 0x8f,
	0xba, 0xd0, 0xf0, 0x83, 0x61, 0x3a, 0x5b, 0x0f, 0x42, 0xd9, 0x70, 0x54, 0x50, 0xef, 0x7f, 0x16,
	0xc0, 0x63, 0x4a, 0x63, 0xba, 0x2b, 0xa6, 0xb4, 0x35, 0x80, 0x23, 0x82, 0x5f, 0x8c, 0x71, 0xc0,
	0x70, 0xe8, 0x2c, 0x20, 0x47, 0xbe, 0x6b, 0x65, 0x35, 0x71, 0x2c, 0xd4, 0x84, 0xcd, 0x09, 0x84,
	0xd7, 0x52, 0x4c, 0xc2, 0x88, 0x9c, 0x3a, 0x76, 0x4e, 0xbb, 0xcb, 0xc7, 0x39, 0x1c, 0x3a, 0x15,
	0x84, 0x60, 0x4d, 0x40, 0xf6, 0x63, 0xf6, 0xf8, 0x45, 0x94, 0xb0, 0xc4, 0xa9, 0xa2, 0x2d, 0xf9,
	0xdc, 0x17, 0xd1, 0xe1, 0x61, 0x3f, 0x38, 0xc3, 0xa1, 0xb3, 0xc8, 0x49, 0xb5, 0x52, 0x17, 0x3a,
	0x4b, 0x68, 0x15, 0xea, 0x9f, 0xc5, 0xf4, 0x38, 0x0a, 0x43, 0x4c, 0x9c, 0x65, 0xb4, 0x09, 0xce,
	0x4e, 0x9a, 0xa5, 0x83, 0x64, 0x2f, 0x4a, 0x12, 0xae, 0xb5, 0x86, 0x6e, 0x41, 0x63, 0x27, 0x18,
	0xee, 0xc7, 0xe4, 0xf1, 0x68, 0xcc, 0xae, 0x9d, 0x7a, 0xae, 0x60, 0x3f, 0x66, 0xf9, 0x1c, 0xef,
	0x00, 0x72, 0xa0, 0x21, 0xee, 0xf9, 0xec, 0xe4, 0x24, 0xc1, 0xcc, 0xf9, 0xab, 0xdd, 0xfb, 0xa3,
	0x25, 0x97, 0x3a, 0x69, 0x07, 0x47, 0xb7, 0xb5, 0x6d, 0x4c, 0x76, 0x8b, 0x05, 0xd4, 0x91, 0x2f,
	0x03, 0xf9, 0xde, 0x48, 0xef, 0x9b, 0x5d, 0xdf, 0xb1, 0x0c, 0x7c, 0x86, 0x38, 0x64, 0x3e, 0xe5,
	0xfc, 0xb6, 0x21, 0x37, 0xbb, 0x5e, 0x25, 0xf7, 0x64, 0x0a, 0x57, 0x7c, 0xd4, 0x7b, 0x22, 0xb7,
	0x65, 0xca, 0x06, 0x06, 0xdd, 0x95, 0xef, 0x76, 0x05, 0x76, 0x44, 0xce, 0x49, 0x7c, 0x45, 0x9c,
	0x05, 0xf4, 0x06, 0x6c, 0x99, 0xc8, 0x67, 0x57, 0x04, 0x53, 0xc7, 0xea, 0x5d, 0x41, 0x2d, 0x9b,
	0x79, 0x51, 0x03, 0x96, 0x9f, 0x53, 0x8c, 0x77, 0x0e, 0x06, 0xce, 0x02, 0x3f, 0x7c, 0x16, 0x0d,
	0xc5, 0xc1, 0xe2, 0xee, 0xdf, 0x9d, 0xc4, 0x14, 0x87, 0x89, 0xef, 0xb9, 0xcb, 0xf3, 0x85, 0x24,
	0x17, 0x09, 0x87, 0x54, 0xd0, 0x3a, 0xac, 0xee, 0xfb, 0xa3, 0x88, 0x9c, 0x72, 0x89, 0x1c, 0x54,
	0xe5, 0x97, 0x38, 0xf0, 0xaf, 0x47, 0x98, 0xb0, 0x03, 0x1a, 0x07, 0x58, 0x7c, 0x15, 0x8e, 0x59,
	0xec, 0xdd, 0x9f, 0x4c, 0x7c, 0xca, 0xb3, 0x0f, 0xd5, 0xa0, 0xca, 0x6d, 0x48, 0x0d, 0x90, 0xdd,
	0xd6, 0xb1, 0xf8, 0x41, 0x7e, 0x7f, 0xc7, 0xee, 0x3d, 0x80, 0x3b, 0x53, 0xc6, 0x2c, 0xb4, 0x04,
	0xf6, 0xb3, 0x73, 0x67, 0x81, 0x9b, 0xe2, 0xe1, 0x51, 0x7c, 0x89, 0x0f, 0x28, 0x1e, 0xfb, 0x14,
	0x3b, 0x16, 0x02, 0x58, 0x4a, 0x41, 0x8e, 0xdd, 0xfb, 0xbd, 0x25, 0xea, 0x78, 0x31, 0x31, 0x50,
	0x0b, 0x6e, 0x4f, 0x4e, 0xea, 0xce, 0x26, 0x75, 0xa3, 0x81, 0x4b, 0x77, 0x54, 0x8e, 0xc5, 0xdd,
	0x6f, 0xa0, 0xe4, 0x9b, 0x8d, 0x7f, 0xe1, 0x7b, 0x70, 0xd7, 0x40, 0xaa, 0xdd, 0xcd, 0xa9, 0xf4,
	0xff, 0xd4, 0x80, 0x86, 0xe2, 0x5f, 0xf4, 0x04, 0xea, 0xf9, 0xce, 0x0b, 0x95, 0xac, 0xde, 0x94,
	0x35, 0x69, 0xab, 0x33, 0x0d, 0x2d, 0xab, 0xd9, 0x57, 0xd9, 0x6a, 0x75, 0xb2, 0x08, 0x41, 0x6f,
	0x4f, 0x7b, 0x2d, 0xab, 0xfb, 0x9e, 0xd6, 0xf7, 0x6f, 0xa0, 0x92, 0x0a, 0xce, 0xb5, 0x38, 0xcd,
	0x37, 0x2d, 0x68, 0x7b, 0x26, 0xbb, 0xb2, 0xc8, 0x69, 0xbd, 0x37, 0x07, 0xa5, 0x54, 0x76, 0x9c,
	0x6d, 0x03, 0x95, 0xad, 0x00, 0x9a, 0x61, 0xa8, 0xb2, 0x17, 0x69, 0xbd, 0x73, 0x13, 0x99, 0xd4,
	0x81, 0x65, 0x42, 0x6a, 0x4f, 0x7d, 0x54, 0xc2, 0x5d, 0xb6, 0x42, 0x68, 0xbd, 0x7b, 0x23, 0x9d,
	0xe1, 0x37, 0xe3, 0x81, 0x5f, 0xe6, 0xb7, 0xf2, 0xb5, 0x42, 0x99, 0xdf, 0xa6, 0x6c, 0x0b, 0xb8,
	0xb2, 0xb2, 0xf7, 0xbe, 0xa1, 0x6c, 0xc6, 0x42, 0xc1, 0x50, 0x36, 0x73, 0x79, 0x70, 0x00, 0x0d,
	0x25, 0x3f, 0xd1, 0xbd, 0xe9, 0x0f, 0xa4, 0x54, 0x74, 0x77, 0x3a, 0xc1, 0x44, 0xa2, 0xd2, 0x67,
	0x50, 0xc9, 0xb6, 0x47, 0x7b, 0x11, 0x18, 0x12, 0xcb, 0xde, 0x1f, 0x5f, 0xe4, 0x0b, 0x38, 0x29,
	0xf3, 0xad, 0xb2, 0xe5, 0x9d, 0x2e, 0xd5, 0x9d, 0x45, 0x22, 0xe5, 0x92, 0x7c, 0x26, 0xd7, 0xc7,
	0x64, 0xf4, 0x5e, 0x19, 0x73, 0xe9, 0xa8, 0xdd, 0xea, 0xcd, 0x43, 0x2a, 0xf5, 0x1d, 0xc2, 0x8a,
	0x5a, 0x4c, 0x50, 0xd7, 0x6c, 0xfe, 0xe6, 0x40, 0xde, 0x7a, 0x6b, 0x06, 0x85, 0xea, 0x1c, 0x65,
	0xca, 0x2d, 0x38, 0xa7, 0x38, 0x4d, 0x17, 0x9c, 0x53, 0x36, 0x24, 0x7f, 0xc5, 0x5b, 0xb4, 0x3e,
	0xfc, 0x19, 0xb5, 0x68, 0xca, 0xa0, 0x6c, 0xd4, 0xa2, 0x69, 0x13, 0x24, 0x8f, 0x13, 0xa5, 0xac,
	0x1b, 0x71, 0x52, 0x9c, 0x2d, 0x5b, 0xdd, 0xe9, 0x04, 0xa9, 0xc4, 0x87, 0x9f, 0xfc, 0xe7, 0x65,
	0xc7, 0xfa, 0xfa, 0x65, 0xc7, 0xfa, 0xe6, 0x65, 0xc7, 0xfa, 0xc3, 0xab, 0xce, 0xc2, 0xd7, 0xaf,
	0x3a, 0x0b, 0xff, 0x7d, 0xd5, 0x59, 0xf8, 0x75, 0x7b, 0xd6, 0x3f, 0xbe, 0x8e, 0x97, 0xc4, 0xaf,
	0x8f, 0xfe, 0x1f, 0x00, 0x00, 0xff, 0xff, 0xe7, 0xd7, 0x91, 0xfa, 0x1f, 0x1b, 0x00, 0x00,
}

func (m *SpaceSignRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceSignRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceSignRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForceRequest {
		i--
		if m.ForceRequest {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.NewIdentitySignature) > 0 {
		i -= len(m.NewIdentitySignature)
		copy(dAtA[i:], m.NewIdentitySignature)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.NewIdentitySignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OldIdentity) > 0 {
		i -= len(m.OldIdentity)
		copy(dAtA[i:], m.OldIdentity)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.OldIdentity)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Header) > 0 {
		i -= len(m.Header)
		copy(dAtA[i:], m.Header)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.Header)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceLimits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceLimits) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceLimits) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WriteMembers != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.WriteMembers))
		i--
		dAtA[i] = 0x10
	}
	if m.ReadMembers != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.ReadMembers))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpaceStatusPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceStatusPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceStatusPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsShared {
		i--
		if m.IsShared {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Limits != nil {
		{
			size, err := m.Limits.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCoordinator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Permissions != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.Permissions))
		i--
		dAtA[i] = 0x18
	}
	if m.DeletionTimestamp != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.DeletionTimestamp))
		i--
		dAtA[i] = 0x10
	}
	if m.Status != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpaceSignResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceSignResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceSignResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Receipt != nil {
		{
			size, err := m.Receipt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCoordinator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceReceiptWithSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceReceiptWithSignature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceReceiptWithSignature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpaceReceiptPayload) > 0 {
		i -= len(m.SpaceReceiptPayload)
		copy(dAtA[i:], m.SpaceReceiptPayload)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceReceiptPayload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceReceipt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceReceipt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceReceipt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValidUntil != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.ValidUntil))
		i--
		dAtA[i] = 0x28
	}
	if len(m.NetworkId) > 0 {
		i -= len(m.NetworkId)
		copy(dAtA[i:], m.NetworkId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.NetworkId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AccountIdentity) > 0 {
		i -= len(m.AccountIdentity)
		copy(dAtA[i:], m.AccountIdentity)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.AccountIdentity)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PeerId) > 0 {
		i -= len(m.PeerId)
		copy(dAtA[i:], m.PeerId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.PeerId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceStatusCheckRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceStatusCheckRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceStatusCheckRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceStatusCheckResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceStatusCheckResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceStatusCheckResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCoordinator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceStatusCheckManyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceStatusCheckManyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceStatusCheckManyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SpaceIds) > 0 {
		for iNdEx := len(m.SpaceIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SpaceIds[iNdEx])
			copy(dAtA[i:], m.SpaceIds[iNdEx])
			i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SpaceStatusCheckManyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceStatusCheckManyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceStatusCheckManyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AccountLimits != nil {
		{
			size, err := m.AccountLimits.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCoordinator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Payloads) > 0 {
		for iNdEx := len(m.Payloads) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Payloads[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCoordinator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AccountLimits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountLimits) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountLimits) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SharedSpacesLimit != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.SharedSpacesLimit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpaceStatusChangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceStatusChangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceStatusChangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeletionPayloadType != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.DeletionPayloadType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DeletionPayload) > 0 {
		i -= len(m.DeletionPayload)
		copy(dAtA[i:], m.DeletionPayload)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.DeletionPayload)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DeletionPayloadId) > 0 {
		i -= len(m.DeletionPayloadId)
		copy(dAtA[i:], m.DeletionPayloadId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.DeletionPayloadId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceStatusChangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceStatusChangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceStatusChangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCoordinator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceMakeShareableRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceMakeShareableRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceMakeShareableRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceMakeShareableResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceMakeShareableResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceMakeShareableResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SpaceMakeUnshareableRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceMakeUnshareableRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceMakeUnshareableRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AclHead) > 0 {
		i -= len(m.AclHead)
		copy(dAtA[i:], m.AclHead)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.AclHead)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceMakeUnshareableResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceMakeUnshareableResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceMakeUnshareableResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *NetworkConfigurationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkConfigurationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkConfigurationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CurrentId) > 0 {
		i -= len(m.CurrentId)
		copy(dAtA[i:], m.CurrentId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.CurrentId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkConfigurationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkConfigurationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkConfigurationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreationTimeUnix != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.CreationTimeUnix))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCoordinator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.NetworkId) > 0 {
		i -= len(m.NetworkId)
		copy(dAtA[i:], m.NetworkId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.NetworkId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ConfigurationId) > 0 {
		i -= len(m.ConfigurationId)
		copy(dAtA[i:], m.ConfigurationId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.ConfigurationId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Types) > 0 {
		dAtA7 := make([]byte, len(m.Types)*10)
		var j6 int
		for _, num := range m.Types {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintCoordinator(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Addresses) > 0 {
		for iNdEx := len(m.Addresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Addresses[iNdEx])
			copy(dAtA[i:], m.Addresses[iNdEx])
			i = encodeVarintCoordinator(dAtA, i, uint64(len(m.Addresses[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PeerId) > 0 {
		i -= len(m.PeerId)
		copy(dAtA[i:], m.PeerId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.PeerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeletionConfirmPayloadWithSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeletionConfirmPayloadWithSignature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeletionConfirmPayloadWithSignature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DeletionPayload) > 0 {
		i -= len(m.DeletionPayload)
		copy(dAtA[i:], m.DeletionPayload)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.DeletionPayload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeletionConfirmPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeletionConfirmPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeletionConfirmPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x28
	}
	if len(m.NetworkId) > 0 {
		i -= len(m.NetworkId)
		copy(dAtA[i:], m.NetworkId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.NetworkId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AccountIdentity) > 0 {
		i -= len(m.AccountIdentity)
		copy(dAtA[i:], m.AccountIdentity)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.AccountIdentity)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PeerId) > 0 {
		i -= len(m.PeerId)
		copy(dAtA[i:], m.PeerId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.PeerId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeletionLogRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeletionLogRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeletionLogRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AfterId) > 0 {
		i -= len(m.AfterId)
		copy(dAtA[i:], m.AfterId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.AfterId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeletionLogResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeletionLogResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeletionLogResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HasMore {
		i--
		if m.HasMore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Records) > 0 {
		for iNdEx := len(m.Records) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Records[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCoordinator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeletionLogRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeletionLogRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeletionLogRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FileGroup) > 0 {
		i -= len(m.FileGroup)
		copy(dAtA[i:], m.FileGroup)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.FileGroup)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Timestamp != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x20
	}
	if m.Status != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeletionDuration != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.DeletionDuration))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DeletionPayload) > 0 {
		i -= len(m.DeletionPayload)
		copy(dAtA[i:], m.DeletionPayload)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.DeletionPayload)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DeletionPayloadId) > 0 {
		i -= len(m.DeletionPayloadId)
		copy(dAtA[i:], m.DeletionPayloadId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.DeletionPayloadId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ToBeDeletedTimestamp != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.ToBeDeletedTimestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AccountDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DeletionPayload) > 0 {
		i -= len(m.DeletionPayload)
		copy(dAtA[i:], m.DeletionPayload)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.DeletionPayload)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DeletionPayloadId) > 0 {
		i -= len(m.DeletionPayloadId)
		copy(dAtA[i:], m.DeletionPayloadId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.DeletionPayloadId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccountDeletionConfirmPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountDeletionConfirmPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountDeletionConfirmPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x20
	}
	if len(m.NetworkId) > 0 {
		i -= len(m.NetworkId)
		copy(dAtA[i:], m.NetworkId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.NetworkId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AccountIdentity) > 0 {
		i -= len(m.AccountIdentity)
		copy(dAtA[i:], m.AccountIdentity)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.AccountIdentity)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PeerId) > 0 {
		i -= len(m.PeerId)
		copy(dAtA[i:], m.PeerId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.PeerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccountDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ToBeDeletedTimestamp != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.ToBeDeletedTimestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AccountRevertDeletionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountRevertDeletionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountRevertDeletionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *AccountRevertDeletionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountRevertDeletionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountRevertDeletionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *AclAddRecordRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclAddRecordRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclAddRecordRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AclAddRecordResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclAddRecordResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclAddRecordResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RecordId) > 0 {
		i -= len(m.RecordId)
		copy(dAtA[i:], m.RecordId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.RecordId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AclGetRecordsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclGetRecordsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclGetRecordsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AclHead) > 0 {
		i -= len(m.AclHead)
		copy(dAtA[i:], m.AclHead)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.AclHead)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AclGetRecordsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclGetRecordsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclGetRecordsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Records) > 0 {
		for iNdEx := len(m.Records) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Records[iNdEx])
			copy(dAtA[i:], m.Records[iNdEx])
			i = encodeVarintCoordinator(dAtA, i, uint64(len(m.Records[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AccountLimitsSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountLimitsSetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountLimitsSetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SharedSpacesLimit != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.SharedSpacesLimit))
		i--
		dAtA[i] = 0x30
	}
	if m.SpaceMembersWrite != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.SpaceMembersWrite))
		i--
		dAtA[i] = 0x28
	}
	if m.SpaceMembersRead != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.SpaceMembersRead))
		i--
		dAtA[i] = 0x20
	}
	if m.FileStorageLimitBytes != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.FileStorageLimitBytes))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccountLimitsSetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountLimitsSetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountLimitsSetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *AclEventLogRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclEventLogRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclEventLogRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AfterId) > 0 {
		i -= len(m.AfterId)
		copy(dAtA[i:], m.AfterId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.AfterId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccountIdentity) > 0 {
		i -= len(m.AccountIdentity)
		copy(dAtA[i:], m.AccountIdentity)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.AccountIdentity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AclEventLogResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclEventLogResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclEventLogResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HasMore {
		i--
		if m.HasMore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Records) > 0 {
		for iNdEx := len(m.Records) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Records[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCoordinator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AclEventLogRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclEventLogRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclEventLogRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AclChangeId) > 0 {
		i -= len(m.AclChangeId)
		copy(dAtA[i:], m.AclChangeId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.AclChangeId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Type != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if m.Timestamp != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x18
	}
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCoordinator(dAtA []byte, offset int, v uint64) int {
	offset -= sovCoordinator(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SpaceSignRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.Header)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.OldIdentity)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.NewIdentitySignature)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	if m.ForceRequest {
		n += 2
	}
	return n
}

func (m *SpaceLimits) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReadMembers != 0 {
		n += 1 + sovCoordinator(uint64(m.ReadMembers))
	}
	if m.WriteMembers != 0 {
		n += 1 + sovCoordinator(uint64(m.WriteMembers))
	}
	return n
}

func (m *SpaceStatusPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovCoordinator(uint64(m.Status))
	}
	if m.DeletionTimestamp != 0 {
		n += 1 + sovCoordinator(uint64(m.DeletionTimestamp))
	}
	if m.Permissions != 0 {
		n += 1 + sovCoordinator(uint64(m.Permissions))
	}
	if m.Limits != nil {
		l = m.Limits.Size()
		n += 1 + l + sovCoordinator(uint64(l))
	}
	if m.IsShared {
		n += 2
	}
	return n
}

func (m *SpaceSignResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Receipt != nil {
		l = m.Receipt.Size()
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *SpaceReceiptWithSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceReceiptPayload)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *SpaceReceipt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.PeerId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.AccountIdentity)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.NetworkId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	if m.ValidUntil != 0 {
		n += 1 + sovCoordinator(uint64(m.ValidUntil))
	}
	return n
}

func (m *SpaceStatusCheckRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *SpaceStatusCheckResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *SpaceStatusCheckManyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SpaceIds) > 0 {
		for _, s := range m.SpaceIds {
			l = len(s)
			n += 1 + l + sovCoordinator(uint64(l))
		}
	}
	return n
}

func (m *SpaceStatusCheckManyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Payloads) > 0 {
		for _, e := range m.Payloads {
			l = e.Size()
			n += 1 + l + sovCoordinator(uint64(l))
		}
	}
	if m.AccountLimits != nil {
		l = m.AccountLimits.Size()
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *AccountLimits) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SharedSpacesLimit != 0 {
		n += 1 + sovCoordinator(uint64(m.SharedSpacesLimit))
	}
	return n
}

func (m *SpaceStatusChangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.DeletionPayloadId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.DeletionPayload)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	if m.DeletionPayloadType != 0 {
		n += 1 + sovCoordinator(uint64(m.DeletionPayloadType))
	}
	return n
}

func (m *SpaceStatusChangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *SpaceMakeShareableRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *SpaceMakeShareableResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SpaceMakeUnshareableRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.AclHead)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *SpaceMakeUnshareableResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *NetworkConfigurationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CurrentId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *NetworkConfigurationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConfigurationId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.NetworkId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovCoordinator(uint64(l))
		}
	}
	if m.CreationTimeUnix != 0 {
		n += 1 + sovCoordinator(uint64(m.CreationTimeUnix))
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PeerId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	if len(m.Addresses) > 0 {
		for _, s := range m.Addresses {
			l = len(s)
			n += 1 + l + sovCoordinator(uint64(l))
		}
	}
	if len(m.Types) > 0 {
		l = 0
		for _, e := range m.Types {
			l += sovCoordinator(uint64(e))
		}
		n += 1 + sovCoordinator(uint64(l)) + l
	}
	return n
}

func (m *DeletionConfirmPayloadWithSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeletionPayload)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *DeletionConfirmPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.PeerId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.AccountIdentity)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.NetworkId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovCoordinator(uint64(m.Timestamp))
	}
	return n
}

func (m *DeletionLogRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AfterId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovCoordinator(uint64(m.Limit))
	}
	return n
}

func (m *DeletionLogResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Records) > 0 {
		for _, e := range m.Records {
			l = e.Size()
			n += 1 + l + sovCoordinator(uint64(l))
		}
	}
	if m.HasMore {
		n += 2
	}
	return n
}

func (m *DeletionLogRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovCoordinator(uint64(m.Status))
	}
	if m.Timestamp != 0 {
		n += 1 + sovCoordinator(uint64(m.Timestamp))
	}
	l = len(m.FileGroup)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *SpaceDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.DeletionPayloadId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.DeletionPayload)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	if m.DeletionDuration != 0 {
		n += 1 + sovCoordinator(uint64(m.DeletionDuration))
	}
	return n
}

func (m *SpaceDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ToBeDeletedTimestamp != 0 {
		n += 1 + sovCoordinator(uint64(m.ToBeDeletedTimestamp))
	}
	return n
}

func (m *AccountDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeletionPayloadId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.DeletionPayload)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *AccountDeletionConfirmPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PeerId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.AccountIdentity)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.NetworkId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovCoordinator(uint64(m.Timestamp))
	}
	return n
}

func (m *AccountDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ToBeDeletedTimestamp != 0 {
		n += 1 + sovCoordinator(uint64(m.ToBeDeletedTimestamp))
	}
	return n
}

func (m *AccountRevertDeletionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *AccountRevertDeletionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *AclAddRecordRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *AclAddRecordResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RecordId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *AclGetRecordsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.AclHead)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *AclGetRecordsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Records) > 0 {
		for _, b := range m.Records {
			l = len(b)
			n += 1 + l + sovCoordinator(uint64(l))
		}
	}
	return n
}

func (m *AccountLimitsSetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	if m.FileStorageLimitBytes != 0 {
		n += 1 + sovCoordinator(uint64(m.FileStorageLimitBytes))
	}
	if m.SpaceMembersRead != 0 {
		n += 1 + sovCoordinator(uint64(m.SpaceMembersRead))
	}
	if m.SpaceMembersWrite != 0 {
		n += 1 + sovCoordinator(uint64(m.SpaceMembersWrite))
	}
	if m.SharedSpacesLimit != 0 {
		n += 1 + sovCoordinator(uint64(m.SharedSpacesLimit))
	}
	return n
}

func (m *AccountLimitsSetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *AclEventLogRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountIdentity)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.AfterId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovCoordinator(uint64(m.Limit))
	}
	return n
}

func (m *AclEventLogResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Records) > 0 {
		for _, e := range m.Records {
			l = e.Size()
			n += 1 + l + sovCoordinator(uint64(l))
		}
	}
	if m.HasMore {
		n += 2
	}
	return n
}

func (m *AclEventLogRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovCoordinator(uint64(m.Timestamp))
	}
	if m.Type != 0 {
		n += 1 + sovCoordinator(uint64(m.Type))
	}
	l = len(m.AclChangeId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func sovCoordinator(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCoordinator(x uint64) (n int) {
	return sovCoordinator(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SpaceSignRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceSignRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceSignRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Header = append(m.Header[:0], dAtA[iNdEx:postIndex]...)
			if m.Header == nil {
				m.Header = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldIdentity", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldIdentity = append(m.OldIdentity[:0], dAtA[iNdEx:postIndex]...)
			if m.OldIdentity == nil {
				m.OldIdentity = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewIdentitySignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewIdentitySignature = append(m.NewIdentitySignature[:0], dAtA[iNdEx:postIndex]...)
			if m.NewIdentitySignature == nil {
				m.NewIdentitySignature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceRequest", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceRequest = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadMembers", wireType)
			}
			m.ReadMembers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadMembers |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteMembers", wireType)
			}
			m.WriteMembers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteMembers |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceStatusPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceStatusPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceStatusPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= SpaceStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionTimestamp", wireType)
			}
			m.DeletionTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeletionTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			m.Permissions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Permissions |= SpacePermissions(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limits == nil {
				m.Limits = &SpaceLimits{}
			}
			if err := m.Limits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShared", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsShared = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceSignResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceSignResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceSignResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receipt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Receipt == nil {
				m.Receipt = &SpaceReceiptWithSignature{}
			}
			if err := m.Receipt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceReceiptWithSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceReceiptWithSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceReceiptWithSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceReceiptPayload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceReceiptPayload = append(m.SpaceReceiptPayload[:0], dAtA[iNdEx:postIndex]...)
			if m.SpaceReceiptPayload == nil {
				m.SpaceReceiptPayload = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceReceipt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceReceipt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceReceipt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountIdentity", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountIdentity = append(m.AccountIdentity[:0], dAtA[iNdEx:postIndex]...)
			if m.AccountIdentity == nil {
				m.AccountIdentity = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidUntil", wireType)
			}
			m.ValidUntil = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidUntil |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceStatusCheckRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceStatusCheckRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceStatusCheckRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceStatusCheckResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceStatusCheckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceStatusCheckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &SpaceStatusPayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceStatusCheckManyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceStatusCheckManyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceStatusCheckManyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceIds = append(m.SpaceIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceStatusCheckManyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceStatusCheckManyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceStatusCheckManyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payloads", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payloads = append(m.Payloads, &SpaceStatusPayload{})
			if err := m.Payloads[len(m.Payloads)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccountLimits == nil {
				m.AccountLimits = &AccountLimits{}
			}
			if err := m.AccountLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharedSpacesLimit", wireType)
			}
			m.SharedSpacesLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SharedSpacesLimit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceStatusChangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceStatusChangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceStatusChangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionPayloadId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeletionPayloadId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionPayload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeletionPayload = append(m.DeletionPayload[:0], dAtA[iNdEx:postIndex]...)
			if m.DeletionPayload == nil {
				m.DeletionPayload = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionPayloadType", wireType)
			}
			m.DeletionPayloadType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeletionPayloadType |= DeletionPayloadType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceStatusChangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceStatusChangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceStatusChangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &SpaceStatusPayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceMakeShareableRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceMakeShareableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceMakeShareableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceMakeShareableResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceMakeShareableResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceMakeShareableResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceMakeUnshareableRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceMakeUnshareableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceMakeUnshareableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AclHead", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AclHead = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceMakeUnshareableResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceMakeUnshareableResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceMakeUnshareableResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkConfigurationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkConfigurationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkConfigurationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkConfigurationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkConfigurationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkConfigurationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigurationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigurationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimeUnix", wireType)
			}
			m.CreationTimeUnix = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreationTimeUnix |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addresses = append(m.Addresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v NodeType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCoordinator
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= NodeType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Types = append(m.Types, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCoordinator
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCoordinator
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCoordinator
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Types) == 0 {
					m.Types = make([]NodeType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v NodeType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCoordinator
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= NodeType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Types = append(m.Types, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeletionConfirmPayloadWithSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletionConfirmPayloadWithSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletionConfirmPayloadWithSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionPayload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeletionPayload = append(m.DeletionPayload[:0], dAtA[iNdEx:postIndex]...)
			if m.DeletionPayload == nil {
				m.DeletionPayload = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeletionConfirmPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletionConfirmPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletionConfirmPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountIdentity", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountIdentity = append(m.AccountIdentity[:0], dAtA[iNdEx:postIndex]...)
			if m.AccountIdentity == nil {
				m.AccountIdentity = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeletionLogRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletionLogRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletionLogRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AfterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeletionLogResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletionLogResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletionLogResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Records", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Records = append(m.Records, &DeletionLogRecord{})
			if err := m.Records[len(m.Records)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMore = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeletionLogRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletionLogRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletionLogRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= DeletionLogRecordStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionPayloadId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeletionPayloadId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionPayload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeletionPayload = append(m.DeletionPayload[:0], dAtA[iNdEx:postIndex]...)
			if m.DeletionPayload == nil {
				m.DeletionPayload = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionDuration", wireType)
			}
			m.DeletionDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeletionDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToBeDeletedTimestamp", wireType)
			}
			m.ToBeDeletedTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToBeDeletedTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionPayloadId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeletionPayloadId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionPayload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeletionPayload = append(m.DeletionPayload[:0], dAtA[iNdEx:postIndex]...)
			if m.DeletionPayload == nil {
				m.DeletionPayload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountDeletionConfirmPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountDeletionConfirmPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountDeletionConfirmPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountIdentity", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountIdentity = append(m.AccountIdentity[:0], dAtA[iNdEx:postIndex]...)
			if m.AccountIdentity == nil {
				m.AccountIdentity = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToBeDeletedTimestamp", wireType)
			}
			m.ToBeDeletedTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToBeDeletedTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountRevertDeletionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountRevertDeletionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountRevertDeletionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountRevertDeletionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountRevertDeletionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountRevertDeletionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclAddRecordRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclAddRecordRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclAddRecordRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclAddRecordResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclAddRecordResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclAddRecordResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecordId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclGetRecordsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclGetRecordsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclGetRecordsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AclHead", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AclHead = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclGetRecordsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclGetRecordsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclGetRecordsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Records", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Records = append(m.Records, make([]byte, postIndex-iNdEx))
			copy(m.Records[len(m.Records)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountLimitsSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountLimitsSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountLimitsSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileStorageLimitBytes", wireType)
			}
			m.FileStorageLimitBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileStorageLimitBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceMembersRead", wireType)
			}
			m.SpaceMembersRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpaceMembersRead |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceMembersWrite", wireType)
			}
			m.SpaceMembersWrite = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpaceMembersWrite |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharedSpacesLimit", wireType)
			}
			m.SharedSpacesLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SharedSpacesLimit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountLimitsSetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountLimitsSetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountLimitsSetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclEventLogRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclEventLogRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclEventLogRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountIdentity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountIdentity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AfterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclEventLogResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclEventLogResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclEventLogResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Records", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Records = append(m.Records, &AclEventLogRecord{})
			if err := m.Records[len(m.Records)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMore = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclEventLogRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclEventLogRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclEventLogRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= AclEventLogRecordType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AclChangeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AclChangeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCoordinator(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCoordinator
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCoordinator
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCoordinator
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCoordinator        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCoordinator          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCoordinator = fmt.Errorf("proto: unexpected end of group")
)
