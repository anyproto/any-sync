// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: coordinator/coordinatorproto/protos/coordinator.proto

package coordinatorproto

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ErrorCodes int32

const (
	ErrorCodes_Unexpected           ErrorCodes = 0
	ErrorCodes_SpaceDeleted         ErrorCodes = 1
	ErrorCodes_SpaceDeletionPending ErrorCodes = 2
	ErrorCodes_SpaceCreated         ErrorCodes = 3
	ErrorCodes_SpaceNotExists       ErrorCodes = 4
	ErrorCodes_ErrorOffset          ErrorCodes = 300
)

var ErrorCodes_name = map[int32]string{
	0:   "Unexpected",
	1:   "SpaceDeleted",
	2:   "SpaceDeletionPending",
	3:   "SpaceCreated",
	4:   "SpaceNotExists",
	300: "ErrorOffset",
}

var ErrorCodes_value = map[string]int32{
	"Unexpected":           0,
	"SpaceDeleted":         1,
	"SpaceDeletionPending": 2,
	"SpaceCreated":         3,
	"SpaceNotExists":       4,
	"ErrorOffset":          300,
}

func (x ErrorCodes) String() string {
	return proto.EnumName(ErrorCodes_name, int32(x))
}

func (ErrorCodes) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{0}
}

type SpaceStatus int32

const (
	SpaceStatus_SpaceStatusCreated         SpaceStatus = 0
	SpaceStatus_SpaceStatusPendingDeletion SpaceStatus = 1
	SpaceStatus_SpaceStatusDeletionStarted SpaceStatus = 2
	SpaceStatus_SpaceStatusDeleted         SpaceStatus = 3
)

var SpaceStatus_name = map[int32]string{
	0: "SpaceStatusCreated",
	1: "SpaceStatusPendingDeletion",
	2: "SpaceStatusDeletionStarted",
	3: "SpaceStatusDeleted",
}

var SpaceStatus_value = map[string]int32{
	"SpaceStatusCreated":         0,
	"SpaceStatusPendingDeletion": 1,
	"SpaceStatusDeletionStarted": 2,
	"SpaceStatusDeleted":         3,
}

func (x SpaceStatus) String() string {
	return proto.EnumName(SpaceStatus_name, int32(x))
}

func (SpaceStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{1}
}

type SpaceSignRequest struct {
	// SpaceId is the id of the signed space
	SpaceId string `protobuf:"bytes,1,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
	// Header is the header of the signed space
	Header []byte `protobuf:"bytes,2,opt,name=header,proto3" json:"header,omitempty"`
	// OldIdentity is the old identity of the space owner
	OldIdentity []byte `protobuf:"bytes,3,opt,name=oldIdentity,proto3" json:"oldIdentity,omitempty"`
	// NewIdentitySignature is the new identity signed by the old one
	NewIdentitySignature []byte `protobuf:"bytes,4,opt,name=newIdentitySignature,proto3" json:"newIdentitySignature,omitempty"`
}

func (m *SpaceSignRequest) Reset()         { *m = SpaceSignRequest{} }
func (m *SpaceSignRequest) String() string { return proto.CompactTextString(m) }
func (*SpaceSignRequest) ProtoMessage()    {}
func (*SpaceSignRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{0}
}
func (m *SpaceSignRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceSignRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceSignRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceSignRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceSignRequest.Merge(m, src)
}
func (m *SpaceSignRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpaceSignRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceSignRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceSignRequest proto.InternalMessageInfo

func (m *SpaceSignRequest) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

func (m *SpaceSignRequest) GetHeader() []byte {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *SpaceSignRequest) GetOldIdentity() []byte {
	if m != nil {
		return m.OldIdentity
	}
	return nil
}

func (m *SpaceSignRequest) GetNewIdentitySignature() []byte {
	if m != nil {
		return m.NewIdentitySignature
	}
	return nil
}

type SpaceStatusPayload struct {
	Status            SpaceStatus `protobuf:"varint,1,opt,name=status,proto3,enum=coordinator.SpaceStatus" json:"status,omitempty"`
	DeletionTimestamp int64       `protobuf:"varint,2,opt,name=deletionTimestamp,proto3" json:"deletionTimestamp,omitempty"`
}

func (m *SpaceStatusPayload) Reset()         { *m = SpaceStatusPayload{} }
func (m *SpaceStatusPayload) String() string { return proto.CompactTextString(m) }
func (*SpaceStatusPayload) ProtoMessage()    {}
func (*SpaceStatusPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{1}
}
func (m *SpaceStatusPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceStatusPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceStatusPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceStatusPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceStatusPayload.Merge(m, src)
}
func (m *SpaceStatusPayload) XXX_Size() int {
	return m.Size()
}
func (m *SpaceStatusPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceStatusPayload.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceStatusPayload proto.InternalMessageInfo

func (m *SpaceStatusPayload) GetStatus() SpaceStatus {
	if m != nil {
		return m.Status
	}
	return SpaceStatus_SpaceStatusCreated
}

func (m *SpaceStatusPayload) GetDeletionTimestamp() int64 {
	if m != nil {
		return m.DeletionTimestamp
	}
	return 0
}

type SpaceSignResponse struct {
	Receipt *SpaceReceiptWithSignature `protobuf:"bytes,1,opt,name=receipt,proto3" json:"receipt,omitempty"`
}

func (m *SpaceSignResponse) Reset()         { *m = SpaceSignResponse{} }
func (m *SpaceSignResponse) String() string { return proto.CompactTextString(m) }
func (*SpaceSignResponse) ProtoMessage()    {}
func (*SpaceSignResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{2}
}
func (m *SpaceSignResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceSignResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceSignResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceSignResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceSignResponse.Merge(m, src)
}
func (m *SpaceSignResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpaceSignResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceSignResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceSignResponse proto.InternalMessageInfo

func (m *SpaceSignResponse) GetReceipt() *SpaceReceiptWithSignature {
	if m != nil {
		return m.Receipt
	}
	return nil
}

// SpaceReceiptWithSignature contains protobuf encoded receipt and its signature
type SpaceReceiptWithSignature struct {
	SpaceReceiptPayload []byte `protobuf:"bytes,1,opt,name=spaceReceiptPayload,proto3" json:"spaceReceiptPayload,omitempty"`
	Signature           []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *SpaceReceiptWithSignature) Reset()         { *m = SpaceReceiptWithSignature{} }
func (m *SpaceReceiptWithSignature) String() string { return proto.CompactTextString(m) }
func (*SpaceReceiptWithSignature) ProtoMessage()    {}
func (*SpaceReceiptWithSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{3}
}
func (m *SpaceReceiptWithSignature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceReceiptWithSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceReceiptWithSignature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceReceiptWithSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceReceiptWithSignature.Merge(m, src)
}
func (m *SpaceReceiptWithSignature) XXX_Size() int {
	return m.Size()
}
func (m *SpaceReceiptWithSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceReceiptWithSignature.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceReceiptWithSignature proto.InternalMessageInfo

func (m *SpaceReceiptWithSignature) GetSpaceReceiptPayload() []byte {
	if m != nil {
		return m.SpaceReceiptPayload
	}
	return nil
}

func (m *SpaceReceiptWithSignature) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// SpaceReceipt contains permission to SpacePush operation
type SpaceReceipt struct {
	// spaceId
	SpaceId string `protobuf:"bytes,1,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
	// peerId of receipt requester
	PeerId string `protobuf:"bytes,2,opt,name=peerId,proto3" json:"peerId,omitempty"`
	// identity of space owner
	AccountIdentity []byte `protobuf:"bytes,3,opt,name=accountIdentity,proto3" json:"accountIdentity,omitempty"`
	// identity of control node
	ControlNodeIdentity []byte `protobuf:"bytes,4,opt,name=controlNodeIdentity,proto3" json:"controlNodeIdentity,omitempty"`
	// unix-timestamp with a deadline time of receipt validity
	ValidUntil uint64 `protobuf:"varint,5,opt,name=validUntil,proto3" json:"validUntil,omitempty"`
}

func (m *SpaceReceipt) Reset()         { *m = SpaceReceipt{} }
func (m *SpaceReceipt) String() string { return proto.CompactTextString(m) }
func (*SpaceReceipt) ProtoMessage()    {}
func (*SpaceReceipt) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{4}
}
func (m *SpaceReceipt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceReceipt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceReceipt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceReceipt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceReceipt.Merge(m, src)
}
func (m *SpaceReceipt) XXX_Size() int {
	return m.Size()
}
func (m *SpaceReceipt) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceReceipt.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceReceipt proto.InternalMessageInfo

func (m *SpaceReceipt) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

func (m *SpaceReceipt) GetPeerId() string {
	if m != nil {
		return m.PeerId
	}
	return ""
}

func (m *SpaceReceipt) GetAccountIdentity() []byte {
	if m != nil {
		return m.AccountIdentity
	}
	return nil
}

func (m *SpaceReceipt) GetControlNodeIdentity() []byte {
	if m != nil {
		return m.ControlNodeIdentity
	}
	return nil
}

func (m *SpaceReceipt) GetValidUntil() uint64 {
	if m != nil {
		return m.ValidUntil
	}
	return 0
}

// FileLimitCheckRequest contains an account identity and spaceId
// control node checks that identity owns a given space
type FileLimitCheckRequest struct {
	AccountIdentity []byte `protobuf:"bytes,1,opt,name=accountIdentity,proto3" json:"accountIdentity,omitempty"`
	SpaceId         string `protobuf:"bytes,2,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
}

func (m *FileLimitCheckRequest) Reset()         { *m = FileLimitCheckRequest{} }
func (m *FileLimitCheckRequest) String() string { return proto.CompactTextString(m) }
func (*FileLimitCheckRequest) ProtoMessage()    {}
func (*FileLimitCheckRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{5}
}
func (m *FileLimitCheckRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileLimitCheckRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileLimitCheckRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileLimitCheckRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileLimitCheckRequest.Merge(m, src)
}
func (m *FileLimitCheckRequest) XXX_Size() int {
	return m.Size()
}
func (m *FileLimitCheckRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FileLimitCheckRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FileLimitCheckRequest proto.InternalMessageInfo

func (m *FileLimitCheckRequest) GetAccountIdentity() []byte {
	if m != nil {
		return m.AccountIdentity
	}
	return nil
}

func (m *FileLimitCheckRequest) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

// FileLimitCheckResponse returns a current space limit in bytes
type FileLimitCheckResponse struct {
	Limit uint64 `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *FileLimitCheckResponse) Reset()         { *m = FileLimitCheckResponse{} }
func (m *FileLimitCheckResponse) String() string { return proto.CompactTextString(m) }
func (*FileLimitCheckResponse) ProtoMessage()    {}
func (*FileLimitCheckResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{6}
}
func (m *FileLimitCheckResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileLimitCheckResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileLimitCheckResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileLimitCheckResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileLimitCheckResponse.Merge(m, src)
}
func (m *FileLimitCheckResponse) XXX_Size() int {
	return m.Size()
}
func (m *FileLimitCheckResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FileLimitCheckResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FileLimitCheckResponse proto.InternalMessageInfo

func (m *FileLimitCheckResponse) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

// SpaceStatusCheckRequest contains the spaceId of requested space
type SpaceStatusCheckRequest struct {
	SpaceId string `protobuf:"bytes,1,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
}

func (m *SpaceStatusCheckRequest) Reset()         { *m = SpaceStatusCheckRequest{} }
func (m *SpaceStatusCheckRequest) String() string { return proto.CompactTextString(m) }
func (*SpaceStatusCheckRequest) ProtoMessage()    {}
func (*SpaceStatusCheckRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{7}
}
func (m *SpaceStatusCheckRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceStatusCheckRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceStatusCheckRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceStatusCheckRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceStatusCheckRequest.Merge(m, src)
}
func (m *SpaceStatusCheckRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpaceStatusCheckRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceStatusCheckRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceStatusCheckRequest proto.InternalMessageInfo

func (m *SpaceStatusCheckRequest) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

// SpaceStatusCheckResponse contains the current status of space
type SpaceStatusCheckResponse struct {
	Payload *SpaceStatusPayload `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *SpaceStatusCheckResponse) Reset()         { *m = SpaceStatusCheckResponse{} }
func (m *SpaceStatusCheckResponse) String() string { return proto.CompactTextString(m) }
func (*SpaceStatusCheckResponse) ProtoMessage()    {}
func (*SpaceStatusCheckResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{8}
}
func (m *SpaceStatusCheckResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceStatusCheckResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceStatusCheckResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceStatusCheckResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceStatusCheckResponse.Merge(m, src)
}
func (m *SpaceStatusCheckResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpaceStatusCheckResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceStatusCheckResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceStatusCheckResponse proto.InternalMessageInfo

func (m *SpaceStatusCheckResponse) GetPayload() *SpaceStatusPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

// SpaceStatusChangeRequest contains the deletionChange if we want to delete space, or it is empty otherwise
type SpaceStatusChangeRequest struct {
	SpaceId               string `protobuf:"bytes,1,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
	DeletionChangeId      string `protobuf:"bytes,2,opt,name=deletionChangeId,proto3" json:"deletionChangeId,omitempty"`
	DeletionChangePayload []byte `protobuf:"bytes,3,opt,name=deletionChangePayload,proto3" json:"deletionChangePayload,omitempty"`
}

func (m *SpaceStatusChangeRequest) Reset()         { *m = SpaceStatusChangeRequest{} }
func (m *SpaceStatusChangeRequest) String() string { return proto.CompactTextString(m) }
func (*SpaceStatusChangeRequest) ProtoMessage()    {}
func (*SpaceStatusChangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{9}
}
func (m *SpaceStatusChangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceStatusChangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceStatusChangeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceStatusChangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceStatusChangeRequest.Merge(m, src)
}
func (m *SpaceStatusChangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpaceStatusChangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceStatusChangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceStatusChangeRequest proto.InternalMessageInfo

func (m *SpaceStatusChangeRequest) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

func (m *SpaceStatusChangeRequest) GetDeletionChangeId() string {
	if m != nil {
		return m.DeletionChangeId
	}
	return ""
}

func (m *SpaceStatusChangeRequest) GetDeletionChangePayload() []byte {
	if m != nil {
		return m.DeletionChangePayload
	}
	return nil
}

// SpaceStatusChangeResponse contains changed status of space
type SpaceStatusChangeResponse struct {
	Payload *SpaceStatusPayload `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *SpaceStatusChangeResponse) Reset()         { *m = SpaceStatusChangeResponse{} }
func (m *SpaceStatusChangeResponse) String() string { return proto.CompactTextString(m) }
func (*SpaceStatusChangeResponse) ProtoMessage()    {}
func (*SpaceStatusChangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{10}
}
func (m *SpaceStatusChangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceStatusChangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceStatusChangeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceStatusChangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceStatusChangeResponse.Merge(m, src)
}
func (m *SpaceStatusChangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpaceStatusChangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceStatusChangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceStatusChangeResponse proto.InternalMessageInfo

func (m *SpaceStatusChangeResponse) GetPayload() *SpaceStatusPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func init() {
	proto.RegisterEnum("coordinator.ErrorCodes", ErrorCodes_name, ErrorCodes_value)
	proto.RegisterEnum("coordinator.SpaceStatus", SpaceStatus_name, SpaceStatus_value)
	proto.RegisterType((*SpaceSignRequest)(nil), "coordinator.SpaceSignRequest")
	proto.RegisterType((*SpaceStatusPayload)(nil), "coordinator.SpaceStatusPayload")
	proto.RegisterType((*SpaceSignResponse)(nil), "coordinator.SpaceSignResponse")
	proto.RegisterType((*SpaceReceiptWithSignature)(nil), "coordinator.SpaceReceiptWithSignature")
	proto.RegisterType((*SpaceReceipt)(nil), "coordinator.SpaceReceipt")
	proto.RegisterType((*FileLimitCheckRequest)(nil), "coordinator.FileLimitCheckRequest")
	proto.RegisterType((*FileLimitCheckResponse)(nil), "coordinator.FileLimitCheckResponse")
	proto.RegisterType((*SpaceStatusCheckRequest)(nil), "coordinator.SpaceStatusCheckRequest")
	proto.RegisterType((*SpaceStatusCheckResponse)(nil), "coordinator.SpaceStatusCheckResponse")
	proto.RegisterType((*SpaceStatusChangeRequest)(nil), "coordinator.SpaceStatusChangeRequest")
	proto.RegisterType((*SpaceStatusChangeResponse)(nil), "coordinator.SpaceStatusChangeResponse")
}

func init() {
	proto.RegisterFile("coordinator/coordinatorproto/protos/coordinator.proto", fileDescriptor_d94f6f99586adae2)
}

var fileDescriptor_d94f6f99586adae2 = []byte{
	// 728 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0xcf, 0x4e, 0x13, 0x41,
	0x18, 0xef, 0xb6, 0x05, 0xd2, 0xaf, 0xa4, 0x2e, 0x23, 0xe0, 0xda, 0xe0, 0xda, 0xac, 0x4a, 0x1a,
	0x62, 0x80, 0x14, 0x35, 0xf1, 0x66, 0xac, 0x98, 0x60, 0x0c, 0x92, 0xc5, 0x6a, 0xd4, 0x83, 0x59,
	0x76, 0x3f, 0x60, 0xc2, 0xb2, 0xb3, 0xee, 0x4c, 0x15, 0x0e, 0x26, 0x3e, 0x82, 0x27, 0x0f, 0x3e,
	0x83, 0x8f, 0xe0, 0x03, 0x78, 0xe4, 0xe8, 0xd1, 0xc0, 0x53, 0x78, 0x33, 0x9d, 0xdd, 0x6d, 0x67,
	0xdb, 0x6d, 0x39, 0x78, 0x81, 0xce, 0xef, 0xfb, 0x7d, 0x7f, 0x7f, 0xdf, 0xcc, 0xc2, 0x7d, 0x97,
	0xb1, 0xc8, 0xa3, 0x81, 0x23, 0x58, 0xb4, 0xa6, 0xfc, 0x0e, 0x23, 0x26, 0xd8, 0x9a, 0xfc, 0xcb,
	0x55, 0x7c, 0x55, 0x42, 0xa4, 0xaa, 0x40, 0xd6, 0x77, 0x0d, 0xf4, 0xdd, 0xd0, 0x71, 0x71, 0x97,
	0x1e, 0x04, 0x36, 0x7e, 0xe8, 0x22, 0x17, 0xc4, 0x80, 0x19, 0xde, 0xc3, 0xb6, 0x3c, 0x43, 0x6b,
	0x68, 0xcd, 0x8a, 0x9d, 0x1e, 0xc9, 0x22, 0x4c, 0x1f, 0xa2, 0xe3, 0x61, 0x64, 0x14, 0x1b, 0x5a,
	0x73, 0xd6, 0x4e, 0x4e, 0xa4, 0x01, 0x55, 0xe6, 0x7b, 0x5b, 0x1e, 0x06, 0x82, 0x8a, 0x53, 0xa3,
	0x24, 0x8d, 0x2a, 0x44, 0x5a, 0x30, 0x1f, 0xe0, 0xa7, 0xf4, 0xd8, 0xcb, 0xe6, 0x88, 0x6e, 0x84,
	0x46, 0x59, 0x52, 0x73, 0x6d, 0x96, 0x00, 0x12, 0xd7, 0x26, 0x1c, 0xd1, 0xe5, 0x3b, 0xce, 0xa9,
	0xcf, 0x1c, 0x8f, 0xac, 0xc3, 0x34, 0x97, 0x80, 0x2c, 0xae, 0xd6, 0x32, 0x56, 0xd5, 0x1e, 0x15,
	0x07, 0x3b, 0xe1, 0x91, 0xbb, 0x30, 0xe7, 0xa1, 0x8f, 0x82, 0xb2, 0xe0, 0x25, 0x3d, 0x46, 0x2e,
	0x9c, 0xe3, 0x50, 0x36, 0x50, 0xb2, 0x47, 0x0d, 0x56, 0x07, 0xe6, 0x94, 0x89, 0xf0, 0x90, 0x05,
	0x1c, 0xc9, 0x23, 0x98, 0x89, 0xd0, 0x45, 0x1a, 0x0a, 0x99, 0xb5, 0xda, 0x5a, 0x1e, 0xcd, 0x6a,
	0xc7, 0x84, 0xd7, 0x54, 0x1c, 0xf6, 0x7b, 0xb0, 0x53, 0x37, 0xeb, 0x08, 0xae, 0x8f, 0x65, 0x91,
	0x75, 0xb8, 0xca, 0x15, 0x63, 0xd2, 0xaa, 0x4c, 0x35, 0x6b, 0xe7, 0x99, 0xc8, 0x12, 0x54, 0x78,
	0x7f, 0x88, 0xb1, 0x18, 0x03, 0xc0, 0xfa, 0xa9, 0xc1, 0xac, 0x9a, 0x6d, 0xb2, 0xa4, 0x21, 0x62,
	0xb4, 0xe5, 0xc9, 0x28, 0x15, 0x3b, 0x39, 0x91, 0x26, 0x5c, 0x71, 0x5c, 0x97, 0x75, 0x03, 0x31,
	0x24, 0xeb, 0x30, 0xdc, 0x2b, 0xde, 0x65, 0x81, 0x88, 0x98, 0xbf, 0xcd, 0x3c, 0xec, 0xb3, 0x63,
	0x65, 0xf3, 0x4c, 0xc4, 0x04, 0xf8, 0xe8, 0xf8, 0xd4, 0xeb, 0x04, 0x82, 0xfa, 0xc6, 0x54, 0x43,
	0x6b, 0x96, 0x6d, 0x05, 0xb1, 0xde, 0xc1, 0xc2, 0x53, 0xea, 0xe3, 0x73, 0x7a, 0x4c, 0x45, 0xfb,
	0x10, 0xdd, 0xa3, 0x74, 0x33, 0x73, 0x8a, 0xd2, 0xf2, 0x8b, 0x52, 0x1a, 0x2e, 0x66, 0x1a, 0xb6,
	0x56, 0x61, 0x71, 0x38, 0x78, 0x22, 0xf2, 0x3c, 0x4c, 0xf9, 0x3d, 0x54, 0xc6, 0x2c, 0xdb, 0xf1,
	0xc1, 0xda, 0x80, 0x6b, 0xca, 0x52, 0x65, 0xca, 0x19, 0x3b, 0x55, 0xab, 0x03, 0xc6, 0xa8, 0x53,
	0x92, 0xe6, 0x21, 0xcc, 0x84, 0x8a, 0xc0, 0xd5, 0xd6, 0xcd, 0x71, 0x1b, 0x9c, 0x88, 0x6d, 0xa7,
	0x7c, 0xeb, 0x9b, 0x36, 0x14, 0xd7, 0x09, 0x0e, 0xf0, 0xf2, 0x6b, 0xbb, 0x02, 0x7a, 0xba, 0xe7,
	0xb1, 0x4b, 0x7f, 0x2a, 0x23, 0x38, 0xb9, 0x07, 0x0b, 0x59, 0x2c, 0x5d, 0xc6, 0x58, 0xfd, 0x7c,
	0xa3, 0xf5, 0x2a, 0xd9, 0xee, 0x6c, 0x5d, 0xff, 0xdd, 0xf0, 0xca, 0x17, 0x0d, 0x60, 0x33, 0x8a,
	0x58, 0xd4, 0x66, 0x1e, 0x72, 0x52, 0x03, 0xe8, 0x04, 0x78, 0x12, 0xa2, 0x2b, 0xd0, 0xd3, 0x0b,
	0x44, 0x4f, 0xd6, 0xfc, 0x49, 0xaf, 0x28, 0xf4, 0x74, 0x8d, 0x18, 0x30, 0x3f, 0x40, 0x28, 0x0b,
	0x76, 0x30, 0xf0, 0x68, 0x70, 0xa0, 0x17, 0xfb, 0xdc, 0x76, 0x84, 0x4e, 0x8f, 0x5b, 0x22, 0x04,
	0x6a, 0x12, 0xd9, 0x66, 0x62, 0xf3, 0x84, 0x72, 0xc1, 0xf5, 0x32, 0xd1, 0xa1, 0x2a, 0xf3, 0xbd,
	0xd8, 0xdf, 0xe7, 0x28, 0xf4, 0x1f, 0xc5, 0x95, 0xcf, 0x50, 0x55, 0x2a, 0x24, 0x8b, 0x99, 0x47,
	0x29, 0x0d, 0x56, 0x20, 0x26, 0xd4, 0xd5, 0x46, 0xe2, 0xb4, 0x69, 0x15, 0xba, 0x36, 0x64, 0x4f,
	0x0d, 0xbb, 0xc2, 0x89, 0x7a, 0xfe, 0xc5, 0xa1, 0xb8, 0x69, 0x43, 0xa5, 0xd6, 0xdf, 0x22, 0x54,
	0xdb, 0x83, 0x69, 0x91, 0x67, 0x50, 0xe9, 0x3f, 0x4f, 0xe4, 0x46, 0xce, 0x20, 0x07, 0x0f, 0x79,
	0xdd, 0x1c, 0x67, 0x4e, 0x84, 0x79, 0x03, 0xb5, 0xec, 0x55, 0x20, 0x56, 0xc6, 0x23, 0xf7, 0x12,
	0xd6, 0x6f, 0x4d, 0xe4, 0x24, 0xa1, 0xdf, 0xa7, 0xdf, 0x95, 0xc1, 0x05, 0x20, 0xb7, 0xc7, 0xc9,
	0x9e, 0x09, 0x7f, 0xe7, 0x12, 0x56, 0x92, 0x60, 0x2f, 0x7d, 0xa6, 0x95, 0x8d, 0x23, 0x13, 0x7c,
	0x95, 0x9b, 0x52, 0x5f, 0xbe, 0x8c, 0x16, 0xe7, 0x78, 0xfc, 0xe0, 0xd7, 0xb9, 0xa9, 0x9d, 0x9d,
	0x9b, 0xda, 0x9f, 0x73, 0x53, 0xfb, 0x7a, 0x61, 0x16, 0xce, 0x2e, 0xcc, 0xc2, 0xef, 0x0b, 0xb3,
	0xf0, 0x76, 0x69, 0xd2, 0xb7, 0x77, 0x6f, 0x5a, 0xfe, 0xdb, 0xf8, 0x17, 0x00, 0x00, 0xff, 0xff,
	0x86, 0x2f, 0x30, 0xee, 0xa2, 0x07, 0x00, 0x00,
}

func (m *SpaceSignRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceSignRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceSignRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewIdentitySignature) > 0 {
		i -= len(m.NewIdentitySignature)
		copy(dAtA[i:], m.NewIdentitySignature)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.NewIdentitySignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OldIdentity) > 0 {
		i -= len(m.OldIdentity)
		copy(dAtA[i:], m.OldIdentity)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.OldIdentity)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Header) > 0 {
		i -= len(m.Header)
		copy(dAtA[i:], m.Header)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.Header)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceStatusPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceStatusPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceStatusPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeletionTimestamp != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.DeletionTimestamp))
		i--
		dAtA[i] = 0x10
	}
	if m.Status != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpaceSignResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceSignResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceSignResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Receipt != nil {
		{
			size, err := m.Receipt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCoordinator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceReceiptWithSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceReceiptWithSignature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceReceiptWithSignature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpaceReceiptPayload) > 0 {
		i -= len(m.SpaceReceiptPayload)
		copy(dAtA[i:], m.SpaceReceiptPayload)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceReceiptPayload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceReceipt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceReceipt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceReceipt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValidUntil != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.ValidUntil))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ControlNodeIdentity) > 0 {
		i -= len(m.ControlNodeIdentity)
		copy(dAtA[i:], m.ControlNodeIdentity)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.ControlNodeIdentity)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AccountIdentity) > 0 {
		i -= len(m.AccountIdentity)
		copy(dAtA[i:], m.AccountIdentity)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.AccountIdentity)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PeerId) > 0 {
		i -= len(m.PeerId)
		copy(dAtA[i:], m.PeerId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.PeerId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileLimitCheckRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileLimitCheckRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileLimitCheckRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccountIdentity) > 0 {
		i -= len(m.AccountIdentity)
		copy(dAtA[i:], m.AccountIdentity)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.AccountIdentity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileLimitCheckResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileLimitCheckResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileLimitCheckResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpaceStatusCheckRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceStatusCheckRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceStatusCheckRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceStatusCheckResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceStatusCheckResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceStatusCheckResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCoordinator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceStatusChangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceStatusChangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceStatusChangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DeletionChangePayload) > 0 {
		i -= len(m.DeletionChangePayload)
		copy(dAtA[i:], m.DeletionChangePayload)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.DeletionChangePayload)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DeletionChangeId) > 0 {
		i -= len(m.DeletionChangeId)
		copy(dAtA[i:], m.DeletionChangeId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.DeletionChangeId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceStatusChangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceStatusChangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceStatusChangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCoordinator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCoordinator(dAtA []byte, offset int, v uint64) int {
	offset -= sovCoordinator(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SpaceSignRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.Header)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.OldIdentity)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.NewIdentitySignature)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *SpaceStatusPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovCoordinator(uint64(m.Status))
	}
	if m.DeletionTimestamp != 0 {
		n += 1 + sovCoordinator(uint64(m.DeletionTimestamp))
	}
	return n
}

func (m *SpaceSignResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Receipt != nil {
		l = m.Receipt.Size()
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *SpaceReceiptWithSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceReceiptPayload)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *SpaceReceipt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.PeerId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.AccountIdentity)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.ControlNodeIdentity)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	if m.ValidUntil != 0 {
		n += 1 + sovCoordinator(uint64(m.ValidUntil))
	}
	return n
}

func (m *FileLimitCheckRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountIdentity)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *FileLimitCheckResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Limit != 0 {
		n += 1 + sovCoordinator(uint64(m.Limit))
	}
	return n
}

func (m *SpaceStatusCheckRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *SpaceStatusCheckResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *SpaceStatusChangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.DeletionChangeId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.DeletionChangePayload)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *SpaceStatusChangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func sovCoordinator(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCoordinator(x uint64) (n int) {
	return sovCoordinator(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SpaceSignRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceSignRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceSignRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Header = append(m.Header[:0], dAtA[iNdEx:postIndex]...)
			if m.Header == nil {
				m.Header = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldIdentity", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldIdentity = append(m.OldIdentity[:0], dAtA[iNdEx:postIndex]...)
			if m.OldIdentity == nil {
				m.OldIdentity = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewIdentitySignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewIdentitySignature = append(m.NewIdentitySignature[:0], dAtA[iNdEx:postIndex]...)
			if m.NewIdentitySignature == nil {
				m.NewIdentitySignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceStatusPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceStatusPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceStatusPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= SpaceStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionTimestamp", wireType)
			}
			m.DeletionTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeletionTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceSignResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceSignResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceSignResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receipt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Receipt == nil {
				m.Receipt = &SpaceReceiptWithSignature{}
			}
			if err := m.Receipt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceReceiptWithSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceReceiptWithSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceReceiptWithSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceReceiptPayload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceReceiptPayload = append(m.SpaceReceiptPayload[:0], dAtA[iNdEx:postIndex]...)
			if m.SpaceReceiptPayload == nil {
				m.SpaceReceiptPayload = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceReceipt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceReceipt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceReceipt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountIdentity", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountIdentity = append(m.AccountIdentity[:0], dAtA[iNdEx:postIndex]...)
			if m.AccountIdentity == nil {
				m.AccountIdentity = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlNodeIdentity", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ControlNodeIdentity = append(m.ControlNodeIdentity[:0], dAtA[iNdEx:postIndex]...)
			if m.ControlNodeIdentity == nil {
				m.ControlNodeIdentity = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidUntil", wireType)
			}
			m.ValidUntil = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidUntil |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileLimitCheckRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileLimitCheckRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileLimitCheckRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountIdentity", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountIdentity = append(m.AccountIdentity[:0], dAtA[iNdEx:postIndex]...)
			if m.AccountIdentity == nil {
				m.AccountIdentity = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileLimitCheckResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileLimitCheckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileLimitCheckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceStatusCheckRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceStatusCheckRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceStatusCheckRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceStatusCheckResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceStatusCheckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceStatusCheckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &SpaceStatusPayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceStatusChangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceStatusChangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceStatusChangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionChangeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeletionChangeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionChangePayload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeletionChangePayload = append(m.DeletionChangePayload[:0], dAtA[iNdEx:postIndex]...)
			if m.DeletionChangePayload == nil {
				m.DeletionChangePayload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceStatusChangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceStatusChangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceStatusChangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &SpaceStatusPayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCoordinator(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCoordinator
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCoordinator
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCoordinator
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCoordinator        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCoordinator          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCoordinator = fmt.Errorf("proto: unexpected end of group")
)
