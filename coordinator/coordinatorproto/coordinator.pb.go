// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: coordinator/coordinatorproto/protos/coordinator.proto

package coordinatorproto

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ErrorCodes int32

const (
	ErrorCodes_Unexpected           ErrorCodes = 0
	ErrorCodes_SpaceDeleted         ErrorCodes = 1
	ErrorCodes_SpaceDeletionPending ErrorCodes = 2
	ErrorCodes_SpaceCreated         ErrorCodes = 3
	ErrorCodes_SpaceNotExists       ErrorCodes = 4
	ErrorCodes_ErrorOffset          ErrorCodes = 300
)

var ErrorCodes_name = map[int32]string{
	0:   "Unexpected",
	1:   "SpaceDeleted",
	2:   "SpaceDeletionPending",
	3:   "SpaceCreated",
	4:   "SpaceNotExists",
	300: "ErrorOffset",
}

var ErrorCodes_value = map[string]int32{
	"Unexpected":           0,
	"SpaceDeleted":         1,
	"SpaceDeletionPending": 2,
	"SpaceCreated":         3,
	"SpaceNotExists":       4,
	"ErrorOffset":          300,
}

func (x ErrorCodes) String() string {
	return proto.EnumName(ErrorCodes_name, int32(x))
}

func (ErrorCodes) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{0}
}

type SpaceStatus int32

const (
	SpaceStatus_SpaceStatusCreated         SpaceStatus = 0
	SpaceStatus_SpaceStatusPendingDeletion SpaceStatus = 1
	SpaceStatus_SpaceStatusDeletionStarted SpaceStatus = 2
	SpaceStatus_SpaceStatusDeleted         SpaceStatus = 3
)

var SpaceStatus_name = map[int32]string{
	0: "SpaceStatusCreated",
	1: "SpaceStatusPendingDeletion",
	2: "SpaceStatusDeletionStarted",
	3: "SpaceStatusDeleted",
}

var SpaceStatus_value = map[string]int32{
	"SpaceStatusCreated":         0,
	"SpaceStatusPendingDeletion": 1,
	"SpaceStatusDeletionStarted": 2,
	"SpaceStatusDeleted":         3,
}

func (x SpaceStatus) String() string {
	return proto.EnumName(SpaceStatus_name, int32(x))
}

func (SpaceStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{1}
}

// NodeType determines the type of API that a node supports
type NodeType int32

const (
	// TreeAPI supports space/tree sync api
	NodeType_TreeAPI NodeType = 0
	// FileAPI support file api
	NodeType_FileAPI NodeType = 1
	// CoordinatorAPI supports coordinator api
	NodeType_CoordinatorAPI NodeType = 2
)

var NodeType_name = map[int32]string{
	0: "TreeAPI",
	1: "FileAPI",
	2: "CoordinatorAPI",
}

var NodeType_value = map[string]int32{
	"TreeAPI":        0,
	"FileAPI":        1,
	"CoordinatorAPI": 2,
}

func (x NodeType) String() string {
	return proto.EnumName(NodeType_name, int32(x))
}

func (NodeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{2}
}

type SpaceSignRequest struct {
	SpaceId string `protobuf:"bytes,1,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
	Header  []byte `protobuf:"bytes,2,opt,name=header,proto3" json:"header,omitempty"`
}

func (m *SpaceSignRequest) Reset()         { *m = SpaceSignRequest{} }
func (m *SpaceSignRequest) String() string { return proto.CompactTextString(m) }
func (*SpaceSignRequest) ProtoMessage()    {}
func (*SpaceSignRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{0}
}
func (m *SpaceSignRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceSignRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceSignRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceSignRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceSignRequest.Merge(m, src)
}
func (m *SpaceSignRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpaceSignRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceSignRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceSignRequest proto.InternalMessageInfo

func (m *SpaceSignRequest) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

func (m *SpaceSignRequest) GetHeader() []byte {
	if m != nil {
		return m.Header
	}
	return nil
}

type SpaceStatusPayload struct {
	Status            SpaceStatus `protobuf:"varint,1,opt,name=status,proto3,enum=coordinator.SpaceStatus" json:"status,omitempty"`
	DeletionTimestamp int64       `protobuf:"varint,2,opt,name=deletionTimestamp,proto3" json:"deletionTimestamp,omitempty"`
}

func (m *SpaceStatusPayload) Reset()         { *m = SpaceStatusPayload{} }
func (m *SpaceStatusPayload) String() string { return proto.CompactTextString(m) }
func (*SpaceStatusPayload) ProtoMessage()    {}
func (*SpaceStatusPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{1}
}
func (m *SpaceStatusPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceStatusPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceStatusPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceStatusPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceStatusPayload.Merge(m, src)
}
func (m *SpaceStatusPayload) XXX_Size() int {
	return m.Size()
}
func (m *SpaceStatusPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceStatusPayload.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceStatusPayload proto.InternalMessageInfo

func (m *SpaceStatusPayload) GetStatus() SpaceStatus {
	if m != nil {
		return m.Status
	}
	return SpaceStatus_SpaceStatusCreated
}

func (m *SpaceStatusPayload) GetDeletionTimestamp() int64 {
	if m != nil {
		return m.DeletionTimestamp
	}
	return 0
}

type SpaceSignResponse struct {
	Receipt *SpaceReceiptWithSignature `protobuf:"bytes,1,opt,name=receipt,proto3" json:"receipt,omitempty"`
}

func (m *SpaceSignResponse) Reset()         { *m = SpaceSignResponse{} }
func (m *SpaceSignResponse) String() string { return proto.CompactTextString(m) }
func (*SpaceSignResponse) ProtoMessage()    {}
func (*SpaceSignResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{2}
}
func (m *SpaceSignResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceSignResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceSignResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceSignResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceSignResponse.Merge(m, src)
}
func (m *SpaceSignResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpaceSignResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceSignResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceSignResponse proto.InternalMessageInfo

func (m *SpaceSignResponse) GetReceipt() *SpaceReceiptWithSignature {
	if m != nil {
		return m.Receipt
	}
	return nil
}

// SpaceReceiptWithSignature contains protobuf encoded receipt and its signature
type SpaceReceiptWithSignature struct {
	SpaceReceiptPayload []byte `protobuf:"bytes,1,opt,name=spaceReceiptPayload,proto3" json:"spaceReceiptPayload,omitempty"`
	Signature           []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *SpaceReceiptWithSignature) Reset()         { *m = SpaceReceiptWithSignature{} }
func (m *SpaceReceiptWithSignature) String() string { return proto.CompactTextString(m) }
func (*SpaceReceiptWithSignature) ProtoMessage()    {}
func (*SpaceReceiptWithSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{3}
}
func (m *SpaceReceiptWithSignature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceReceiptWithSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceReceiptWithSignature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceReceiptWithSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceReceiptWithSignature.Merge(m, src)
}
func (m *SpaceReceiptWithSignature) XXX_Size() int {
	return m.Size()
}
func (m *SpaceReceiptWithSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceReceiptWithSignature.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceReceiptWithSignature proto.InternalMessageInfo

func (m *SpaceReceiptWithSignature) GetSpaceReceiptPayload() []byte {
	if m != nil {
		return m.SpaceReceiptPayload
	}
	return nil
}

func (m *SpaceReceiptWithSignature) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// SpaceReceipt contains permission to SpacePush operation
type SpaceReceipt struct {
	// spaceId
	SpaceId string `protobuf:"bytes,1,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
	// peerId of receipt requester
	PeerId string `protobuf:"bytes,2,opt,name=peerId,proto3" json:"peerId,omitempty"`
	// identity of space owner
	AccountIdentity []byte `protobuf:"bytes,3,opt,name=accountIdentity,proto3" json:"accountIdentity,omitempty"`
	// identity of control node
	ControlNodeIdentity []byte `protobuf:"bytes,4,opt,name=controlNodeIdentity,proto3" json:"controlNodeIdentity,omitempty"`
	// unix-timestamp with a deadline time of receipt validity
	ValidUntil uint64 `protobuf:"varint,5,opt,name=validUntil,proto3" json:"validUntil,omitempty"`
}

func (m *SpaceReceipt) Reset()         { *m = SpaceReceipt{} }
func (m *SpaceReceipt) String() string { return proto.CompactTextString(m) }
func (*SpaceReceipt) ProtoMessage()    {}
func (*SpaceReceipt) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{4}
}
func (m *SpaceReceipt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceReceipt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceReceipt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceReceipt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceReceipt.Merge(m, src)
}
func (m *SpaceReceipt) XXX_Size() int {
	return m.Size()
}
func (m *SpaceReceipt) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceReceipt.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceReceipt proto.InternalMessageInfo

func (m *SpaceReceipt) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

func (m *SpaceReceipt) GetPeerId() string {
	if m != nil {
		return m.PeerId
	}
	return ""
}

func (m *SpaceReceipt) GetAccountIdentity() []byte {
	if m != nil {
		return m.AccountIdentity
	}
	return nil
}

func (m *SpaceReceipt) GetControlNodeIdentity() []byte {
	if m != nil {
		return m.ControlNodeIdentity
	}
	return nil
}

func (m *SpaceReceipt) GetValidUntil() uint64 {
	if m != nil {
		return m.ValidUntil
	}
	return 0
}

// FileLimitCheckRequest contains an account identity and spaceId
// control node checks that identity owns a given space
type FileLimitCheckRequest struct {
	AccountIdentity []byte `protobuf:"bytes,1,opt,name=accountIdentity,proto3" json:"accountIdentity,omitempty"`
	SpaceId         string `protobuf:"bytes,2,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
}

func (m *FileLimitCheckRequest) Reset()         { *m = FileLimitCheckRequest{} }
func (m *FileLimitCheckRequest) String() string { return proto.CompactTextString(m) }
func (*FileLimitCheckRequest) ProtoMessage()    {}
func (*FileLimitCheckRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{5}
}
func (m *FileLimitCheckRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileLimitCheckRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileLimitCheckRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileLimitCheckRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileLimitCheckRequest.Merge(m, src)
}
func (m *FileLimitCheckRequest) XXX_Size() int {
	return m.Size()
}
func (m *FileLimitCheckRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FileLimitCheckRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FileLimitCheckRequest proto.InternalMessageInfo

func (m *FileLimitCheckRequest) GetAccountIdentity() []byte {
	if m != nil {
		return m.AccountIdentity
	}
	return nil
}

func (m *FileLimitCheckRequest) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

// FileLimitCheckResponse returns a current space limit in bytes
type FileLimitCheckResponse struct {
	Limit uint64 `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *FileLimitCheckResponse) Reset()         { *m = FileLimitCheckResponse{} }
func (m *FileLimitCheckResponse) String() string { return proto.CompactTextString(m) }
func (*FileLimitCheckResponse) ProtoMessage()    {}
func (*FileLimitCheckResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{6}
}
func (m *FileLimitCheckResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileLimitCheckResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileLimitCheckResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileLimitCheckResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileLimitCheckResponse.Merge(m, src)
}
func (m *FileLimitCheckResponse) XXX_Size() int {
	return m.Size()
}
func (m *FileLimitCheckResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FileLimitCheckResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FileLimitCheckResponse proto.InternalMessageInfo

func (m *FileLimitCheckResponse) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

// SpaceStatusCheckRequest contains the spaceId of requested space
type SpaceStatusCheckRequest struct {
	SpaceId string `protobuf:"bytes,1,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
}

func (m *SpaceStatusCheckRequest) Reset()         { *m = SpaceStatusCheckRequest{} }
func (m *SpaceStatusCheckRequest) String() string { return proto.CompactTextString(m) }
func (*SpaceStatusCheckRequest) ProtoMessage()    {}
func (*SpaceStatusCheckRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{7}
}
func (m *SpaceStatusCheckRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceStatusCheckRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceStatusCheckRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceStatusCheckRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceStatusCheckRequest.Merge(m, src)
}
func (m *SpaceStatusCheckRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpaceStatusCheckRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceStatusCheckRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceStatusCheckRequest proto.InternalMessageInfo

func (m *SpaceStatusCheckRequest) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

// SpaceStatusCheckResponse contains the current status of space
type SpaceStatusCheckResponse struct {
	Payload *SpaceStatusPayload `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *SpaceStatusCheckResponse) Reset()         { *m = SpaceStatusCheckResponse{} }
func (m *SpaceStatusCheckResponse) String() string { return proto.CompactTextString(m) }
func (*SpaceStatusCheckResponse) ProtoMessage()    {}
func (*SpaceStatusCheckResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{8}
}
func (m *SpaceStatusCheckResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceStatusCheckResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceStatusCheckResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceStatusCheckResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceStatusCheckResponse.Merge(m, src)
}
func (m *SpaceStatusCheckResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpaceStatusCheckResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceStatusCheckResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceStatusCheckResponse proto.InternalMessageInfo

func (m *SpaceStatusCheckResponse) GetPayload() *SpaceStatusPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

// SpaceStatusChangeRequest contains the deletionChange if we want to delete space, or it is empty otherwise
type SpaceStatusChangeRequest struct {
	SpaceId               string `protobuf:"bytes,1,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
	DeletionChangeId      string `protobuf:"bytes,2,opt,name=deletionChangeId,proto3" json:"deletionChangeId,omitempty"`
	DeletionChangePayload []byte `protobuf:"bytes,3,opt,name=deletionChangePayload,proto3" json:"deletionChangePayload,omitempty"`
}

func (m *SpaceStatusChangeRequest) Reset()         { *m = SpaceStatusChangeRequest{} }
func (m *SpaceStatusChangeRequest) String() string { return proto.CompactTextString(m) }
func (*SpaceStatusChangeRequest) ProtoMessage()    {}
func (*SpaceStatusChangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{9}
}
func (m *SpaceStatusChangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceStatusChangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceStatusChangeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceStatusChangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceStatusChangeRequest.Merge(m, src)
}
func (m *SpaceStatusChangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpaceStatusChangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceStatusChangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceStatusChangeRequest proto.InternalMessageInfo

func (m *SpaceStatusChangeRequest) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

func (m *SpaceStatusChangeRequest) GetDeletionChangeId() string {
	if m != nil {
		return m.DeletionChangeId
	}
	return ""
}

func (m *SpaceStatusChangeRequest) GetDeletionChangePayload() []byte {
	if m != nil {
		return m.DeletionChangePayload
	}
	return nil
}

// SpaceStatusChangeResponse contains changed status of space
type SpaceStatusChangeResponse struct {
	Payload *SpaceStatusPayload `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *SpaceStatusChangeResponse) Reset()         { *m = SpaceStatusChangeResponse{} }
func (m *SpaceStatusChangeResponse) String() string { return proto.CompactTextString(m) }
func (*SpaceStatusChangeResponse) ProtoMessage()    {}
func (*SpaceStatusChangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{10}
}
func (m *SpaceStatusChangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceStatusChangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceStatusChangeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceStatusChangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceStatusChangeResponse.Merge(m, src)
}
func (m *SpaceStatusChangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpaceStatusChangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceStatusChangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceStatusChangeResponse proto.InternalMessageInfo

func (m *SpaceStatusChangeResponse) GetPayload() *SpaceStatusPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

// NetworkConfigurationRequest contains the requested configurationId, it can be empty to request the latest version
type NetworkConfigurationRequest struct {
	ConfigurationId string `protobuf:"bytes,1,opt,name=configurationId,proto3" json:"configurationId,omitempty"`
}

func (m *NetworkConfigurationRequest) Reset()         { *m = NetworkConfigurationRequest{} }
func (m *NetworkConfigurationRequest) String() string { return proto.CompactTextString(m) }
func (*NetworkConfigurationRequest) ProtoMessage()    {}
func (*NetworkConfigurationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{11}
}
func (m *NetworkConfigurationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkConfigurationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkConfigurationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkConfigurationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkConfigurationRequest.Merge(m, src)
}
func (m *NetworkConfigurationRequest) XXX_Size() int {
	return m.Size()
}
func (m *NetworkConfigurationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkConfigurationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkConfigurationRequest proto.InternalMessageInfo

func (m *NetworkConfigurationRequest) GetConfigurationId() string {
	if m != nil {
		return m.ConfigurationId
	}
	return ""
}

// NetworkConfigurationResponse contains list of nodes
type NetworkConfigurationResponse struct {
	ConfigurationId string  `protobuf:"bytes,1,opt,name=configurationId,proto3" json:"configurationId,omitempty"`
	Nodes           []*Node `protobuf:"bytes,2,rep,name=nodes,proto3" json:"nodes,omitempty"`
}

func (m *NetworkConfigurationResponse) Reset()         { *m = NetworkConfigurationResponse{} }
func (m *NetworkConfigurationResponse) String() string { return proto.CompactTextString(m) }
func (*NetworkConfigurationResponse) ProtoMessage()    {}
func (*NetworkConfigurationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{12}
}
func (m *NetworkConfigurationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkConfigurationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkConfigurationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkConfigurationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkConfigurationResponse.Merge(m, src)
}
func (m *NetworkConfigurationResponse) XXX_Size() int {
	return m.Size()
}
func (m *NetworkConfigurationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkConfigurationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkConfigurationResponse proto.InternalMessageInfo

func (m *NetworkConfigurationResponse) GetConfigurationId() string {
	if m != nil {
		return m.ConfigurationId
	}
	return ""
}

func (m *NetworkConfigurationResponse) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

// Node describes one node in the network
type Node struct {
	// peerId - it's a peer identifier (libp2p format string) so it's an encoded publicKey
	PeerId string `protobuf:"bytes,1,opt,name=peerId,proto3" json:"peerId,omitempty"`
	// list of node addresses
	Addresses []string `protobuf:"bytes,2,rep,name=addresses,proto3" json:"addresses,omitempty"`
	// list of supported APIs
	Types []NodeType `protobuf:"varint,3,rep,packed,name=types,proto3,enum=coordinator.NodeType" json:"types,omitempty"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{13}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetPeerId() string {
	if m != nil {
		return m.PeerId
	}
	return ""
}

func (m *Node) GetAddresses() []string {
	if m != nil {
		return m.Addresses
	}
	return nil
}

func (m *Node) GetTypes() []NodeType {
	if m != nil {
		return m.Types
	}
	return nil
}

func init() {
	proto.RegisterEnum("coordinator.ErrorCodes", ErrorCodes_name, ErrorCodes_value)
	proto.RegisterEnum("coordinator.SpaceStatus", SpaceStatus_name, SpaceStatus_value)
	proto.RegisterEnum("coordinator.NodeType", NodeType_name, NodeType_value)
	proto.RegisterType((*SpaceSignRequest)(nil), "coordinator.SpaceSignRequest")
	proto.RegisterType((*SpaceStatusPayload)(nil), "coordinator.SpaceStatusPayload")
	proto.RegisterType((*SpaceSignResponse)(nil), "coordinator.SpaceSignResponse")
	proto.RegisterType((*SpaceReceiptWithSignature)(nil), "coordinator.SpaceReceiptWithSignature")
	proto.RegisterType((*SpaceReceipt)(nil), "coordinator.SpaceReceipt")
	proto.RegisterType((*FileLimitCheckRequest)(nil), "coordinator.FileLimitCheckRequest")
	proto.RegisterType((*FileLimitCheckResponse)(nil), "coordinator.FileLimitCheckResponse")
	proto.RegisterType((*SpaceStatusCheckRequest)(nil), "coordinator.SpaceStatusCheckRequest")
	proto.RegisterType((*SpaceStatusCheckResponse)(nil), "coordinator.SpaceStatusCheckResponse")
	proto.RegisterType((*SpaceStatusChangeRequest)(nil), "coordinator.SpaceStatusChangeRequest")
	proto.RegisterType((*SpaceStatusChangeResponse)(nil), "coordinator.SpaceStatusChangeResponse")
	proto.RegisterType((*NetworkConfigurationRequest)(nil), "coordinator.NetworkConfigurationRequest")
	proto.RegisterType((*NetworkConfigurationResponse)(nil), "coordinator.NetworkConfigurationResponse")
	proto.RegisterType((*Node)(nil), "coordinator.Node")
}

func init() {
	proto.RegisterFile("coordinator/coordinatorproto/protos/coordinator.proto", fileDescriptor_d94f6f99586adae2)
}

var fileDescriptor_d94f6f99586adae2 = []byte{
	// 856 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0x8e, 0xe3, 0xb4, 0x25, 0xc7, 0x55, 0x70, 0x87, 0xb6, 0x98, 0x50, 0x4c, 0x64, 0x60, 0x09,
	0x05, 0x75, 0x57, 0x59, 0x40, 0x70, 0x07, 0x64, 0x17, 0x54, 0x84, 0x4a, 0xe5, 0xb6, 0x20, 0xe0,
	0x02, 0x79, 0xed, 0xd3, 0x76, 0xd4, 0xd4, 0xe3, 0x9d, 0x99, 0xc0, 0xf6, 0x02, 0x89, 0x47, 0xe0,
	0x8a, 0xa7, 0xe0, 0x11, 0x78, 0x00, 0x2e, 0xf7, 0x92, 0x4b, 0xd4, 0x4a, 0x3c, 0x07, 0x1a, 0x7b,
	0x9c, 0x8c, 0x13, 0x27, 0xad, 0xc4, 0x4d, 0xdb, 0xf3, 0x9d, 0x9f, 0xef, 0x9c, 0x39, 0x3f, 0x2e,
	0x7c, 0x10, 0x33, 0xc6, 0x13, 0x9a, 0x46, 0x92, 0xf1, 0xfb, 0xc6, 0xdf, 0x19, 0x67, 0x92, 0xdd,
	0xcf, 0x7f, 0x0a, 0x13, 0xdf, 0xcb, 0x21, 0xe2, 0x18, 0x50, 0xf0, 0x08, 0xdc, 0xa3, 0x2c, 0x8a,
	0xf1, 0x88, 0x9e, 0xa5, 0x21, 0x3e, 0x1d, 0xa3, 0x90, 0xc4, 0x83, 0x35, 0xa1, 0xb0, 0xfd, 0xc4,
	0xb3, 0x7a, 0x56, 0xbf, 0x1d, 0x96, 0x22, 0xd9, 0x86, 0xd5, 0x73, 0x8c, 0x12, 0xe4, 0x5e, 0xb3,
	0x67, 0xf5, 0xd7, 0x43, 0x2d, 0x05, 0x12, 0x48, 0x11, 0x45, 0x46, 0x72, 0x2c, 0x0e, 0xa3, 0xab,
	0x11, 0x8b, 0x12, 0xf2, 0x00, 0x56, 0x45, 0x0e, 0xe4, 0x61, 0x3a, 0x03, 0x6f, 0xcf, 0x4c, 0xc6,
	0x70, 0x08, 0xb5, 0x1d, 0x79, 0x0f, 0x36, 0x12, 0x1c, 0xa1, 0xa4, 0x2c, 0x3d, 0xa6, 0x97, 0x28,
	0x64, 0x74, 0x99, 0xe5, 0x54, 0x76, 0x38, 0xaf, 0x08, 0x4e, 0x60, 0xc3, 0xc8, 0x5d, 0x64, 0x2c,
	0x15, 0x48, 0x3e, 0x81, 0x35, 0x8e, 0x31, 0xd2, 0x4c, 0xe6, 0xac, 0xce, 0xe0, 0xde, 0x3c, 0x6b,
	0x58, 0x18, 0x7c, 0x4b, 0xe5, 0xb9, 0xf2, 0x8d, 0xe4, 0x98, 0x63, 0x58, 0xba, 0x05, 0x17, 0xf0,
	0xca, 0x42, 0x2b, 0xf2, 0x00, 0x5e, 0x12, 0x86, 0x52, 0x97, 0x9a, 0x53, 0xad, 0x87, 0x75, 0x2a,
	0xb2, 0x03, 0x6d, 0x51, 0xba, 0xeb, 0x67, 0x9b, 0x02, 0xc1, 0x9f, 0x16, 0xac, 0x9b, 0x6c, 0xcb,
	0x1f, 0x3f, 0x43, 0xe4, 0xfb, 0x49, 0x1e, 0xa5, 0x1d, 0x6a, 0x89, 0xf4, 0xe1, 0xc5, 0x28, 0x8e,
	0xd9, 0x38, 0x95, 0xfb, 0x09, 0xa6, 0x92, 0xca, 0x2b, 0xcf, 0xce, 0x69, 0x66, 0x61, 0x95, 0x7c,
	0xcc, 0x52, 0xc9, 0xd9, 0xe8, 0x80, 0x25, 0x38, 0xb1, 0x6e, 0x15, 0xc9, 0xd7, 0xa8, 0x88, 0x0f,
	0xf0, 0x53, 0x34, 0xa2, 0xc9, 0x49, 0x2a, 0xe9, 0xc8, 0x5b, 0xe9, 0x59, 0xfd, 0x56, 0x68, 0x20,
	0xc1, 0x0f, 0xb0, 0xf5, 0x39, 0x1d, 0xe1, 0x57, 0xf4, 0x92, 0xca, 0xe1, 0x39, 0xc6, 0x17, 0xe5,
	0x0c, 0xd5, 0x24, 0x65, 0xd5, 0x27, 0x65, 0x14, 0xdc, 0xac, 0x14, 0x1c, 0xec, 0xc1, 0xf6, 0x6c,
	0x70, 0xdd, 0xe4, 0x4d, 0x58, 0x19, 0x29, 0x34, 0x8f, 0xd9, 0x0a, 0x0b, 0x21, 0x78, 0x08, 0x2f,
	0x1b, 0x43, 0x55, 0x49, 0x67, 0xe1, 0xab, 0x06, 0x27, 0xe0, 0xcd, 0x3b, 0x69, 0x9a, 0x8f, 0x61,
	0x2d, 0x33, 0x1a, 0xec, 0x0c, 0x5e, 0x5f, 0x34, 0xc1, 0xba, 0xd9, 0x61, 0x69, 0x1f, 0xfc, 0x6e,
	0xcd, 0xc4, 0x8d, 0xd2, 0x33, 0xbc, 0x7d, 0xc1, 0x76, 0xc1, 0x2d, 0xe7, 0xbc, 0x70, 0x99, 0xbc,
	0xca, 0x1c, 0x4e, 0xde, 0x87, 0xad, 0x2a, 0x56, 0x0e, 0x63, 0xd1, 0xfd, 0x7a, 0x65, 0xf0, 0x8d,
	0x9e, 0xee, 0x6a, 0x5e, 0xff, 0xbf, 0xe0, 0x2f, 0xe0, 0xd5, 0x03, 0x94, 0x3f, 0x33, 0x7e, 0x31,
	0x64, 0xe9, 0x29, 0x3d, 0x1b, 0xf3, 0x48, 0x91, 0x1b, 0xf3, 0x10, 0x9b, 0xf8, 0xa4, 0xf4, 0x59,
	0x38, 0x78, 0x0a, 0x3b, 0xf5, 0x81, 0x74, 0x8e, 0x77, 0x8e, 0x44, 0xde, 0x86, 0x95, 0x94, 0x25,
	0x28, 0xbc, 0x66, 0xcf, 0xee, 0x3b, 0x83, 0x8d, 0x4a, 0x2d, 0x6a, 0xcc, 0xc3, 0x42, 0x1f, 0x50,
	0x68, 0x29, 0xd1, 0xd8, 0x30, 0xab, 0xb2, 0x61, 0x3b, 0xd0, 0x8e, 0x92, 0x84, 0xa3, 0x10, 0x3a,
	0x58, 0x3b, 0x9c, 0x02, 0xe4, 0x5d, 0x58, 0x91, 0x57, 0x19, 0x0a, 0xcf, 0xee, 0xd9, 0xfd, 0xce,
	0x60, 0x6b, 0x8e, 0xe6, 0xf8, 0x2a, 0xc3, 0xb0, 0xb0, 0xd9, 0xfd, 0xd5, 0x02, 0x78, 0xcc, 0x39,
	0xe3, 0x43, 0xc5, 0x4c, 0x3a, 0x00, 0x27, 0x29, 0x3e, 0xcb, 0x30, 0x96, 0x98, 0xb8, 0x0d, 0xe2,
	0xea, 0x6b, 0xf0, 0x48, 0xf5, 0x0e, 0x13, 0xd7, 0x22, 0x1e, 0x6c, 0x4e, 0x11, 0xca, 0xd2, 0x43,
	0x4c, 0x13, 0x9a, 0x9e, 0xb9, 0xcd, 0x89, 0xed, 0x90, 0x63, 0xa4, 0x6c, 0x6d, 0x42, 0xa0, 0x93,
	0x23, 0x07, 0x4c, 0x3e, 0x7e, 0x46, 0x85, 0x14, 0x6e, 0x8b, 0xb8, 0xe0, 0xe4, 0x7c, 0x5f, 0x9f,
	0x9e, 0x0a, 0x94, 0xee, 0x1f, 0xcd, 0xdd, 0x5f, 0xc0, 0x31, 0x1a, 0x49, 0xb6, 0x2b, 0xb7, 0xbb,
	0x0c, 0xd6, 0x20, 0x3e, 0x74, 0xcd, 0x7e, 0x17, 0xb4, 0x65, 0x16, 0xae, 0x35, 0xa3, 0x2f, 0x15,
	0x47, 0x32, 0xe2, 0xca, 0xbf, 0x39, 0x13, 0xb7, 0x2c, 0xc8, 0xde, 0xfd, 0x08, 0x5e, 0x28, 0x1f,
	0x85, 0x38, 0xb0, 0x76, 0xcc, 0x11, 0x3f, 0x3d, 0xdc, 0x77, 0x1b, 0x4a, 0x50, 0xeb, 0xae, 0x04,
	0x4b, 0x95, 0x32, 0x9c, 0x3e, 0xa3, 0xc2, 0x9a, 0x83, 0x7f, 0x6d, 0x70, 0x0c, 0x90, 0x7c, 0x09,
	0xed, 0xc9, 0xfd, 0x27, 0xaf, 0xd5, 0x4c, 0xea, 0xf4, 0x9b, 0xd6, 0xf5, 0x17, 0xa9, 0xf5, 0x54,
	0x7d, 0x07, 0x9d, 0xea, 0xad, 0x21, 0x41, 0xc5, 0xa3, 0xf6, 0xca, 0x75, 0xdf, 0x58, 0x6a, 0xa3,
	0x43, 0xff, 0x58, 0x7e, 0x62, 0xa7, 0x17, 0x86, 0xbc, 0xb9, 0x68, 0xaf, 0x2a, 0xe1, 0xdf, 0xba,
	0xc5, 0x4a, 0x13, 0x3c, 0x29, 0xbf, 0x83, 0xc6, 0x4a, 0x93, 0x25, 0xbe, 0xc6, 0x29, 0xea, 0xde,
	0xbb, 0xcd, 0x4c, 0x73, 0x5c, 0xc0, 0x66, 0xdd, 0x56, 0x92, 0x7e, 0x75, 0xda, 0x17, 0x5f, 0x80,
	0xee, 0x3b, 0x77, 0xb0, 0x2c, 0xc8, 0x3e, 0xfb, 0xf0, 0xaf, 0x6b, 0xdf, 0x7a, 0x7e, 0xed, 0x5b,
	0xff, 0x5c, 0xfb, 0xd6, 0x6f, 0x37, 0x7e, 0xe3, 0xf9, 0x8d, 0xdf, 0xf8, 0xfb, 0xc6, 0x6f, 0x7c,
	0xbf, 0xb3, 0xec, 0x5f, 0x9e, 0x27, 0xab, 0xf9, 0xaf, 0x87, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff,
	0x69, 0x34, 0x32, 0xd9, 0x19, 0x09, 0x00, 0x00,
}

func (m *SpaceSignRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceSignRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceSignRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Header) > 0 {
		i -= len(m.Header)
		copy(dAtA[i:], m.Header)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.Header)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceStatusPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceStatusPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceStatusPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeletionTimestamp != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.DeletionTimestamp))
		i--
		dAtA[i] = 0x10
	}
	if m.Status != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpaceSignResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceSignResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceSignResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Receipt != nil {
		{
			size, err := m.Receipt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCoordinator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceReceiptWithSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceReceiptWithSignature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceReceiptWithSignature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpaceReceiptPayload) > 0 {
		i -= len(m.SpaceReceiptPayload)
		copy(dAtA[i:], m.SpaceReceiptPayload)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceReceiptPayload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceReceipt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceReceipt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceReceipt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValidUntil != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.ValidUntil))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ControlNodeIdentity) > 0 {
		i -= len(m.ControlNodeIdentity)
		copy(dAtA[i:], m.ControlNodeIdentity)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.ControlNodeIdentity)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AccountIdentity) > 0 {
		i -= len(m.AccountIdentity)
		copy(dAtA[i:], m.AccountIdentity)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.AccountIdentity)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PeerId) > 0 {
		i -= len(m.PeerId)
		copy(dAtA[i:], m.PeerId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.PeerId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileLimitCheckRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileLimitCheckRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileLimitCheckRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccountIdentity) > 0 {
		i -= len(m.AccountIdentity)
		copy(dAtA[i:], m.AccountIdentity)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.AccountIdentity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileLimitCheckResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileLimitCheckResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileLimitCheckResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpaceStatusCheckRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceStatusCheckRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceStatusCheckRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceStatusCheckResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceStatusCheckResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceStatusCheckResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCoordinator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceStatusChangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceStatusChangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceStatusChangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DeletionChangePayload) > 0 {
		i -= len(m.DeletionChangePayload)
		copy(dAtA[i:], m.DeletionChangePayload)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.DeletionChangePayload)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DeletionChangeId) > 0 {
		i -= len(m.DeletionChangeId)
		copy(dAtA[i:], m.DeletionChangeId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.DeletionChangeId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceStatusChangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceStatusChangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceStatusChangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCoordinator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkConfigurationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkConfigurationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkConfigurationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ConfigurationId) > 0 {
		i -= len(m.ConfigurationId)
		copy(dAtA[i:], m.ConfigurationId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.ConfigurationId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkConfigurationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkConfigurationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkConfigurationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCoordinator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ConfigurationId) > 0 {
		i -= len(m.ConfigurationId)
		copy(dAtA[i:], m.ConfigurationId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.ConfigurationId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Types) > 0 {
		dAtA5 := make([]byte, len(m.Types)*10)
		var j4 int
		for _, num := range m.Types {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintCoordinator(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Addresses) > 0 {
		for iNdEx := len(m.Addresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Addresses[iNdEx])
			copy(dAtA[i:], m.Addresses[iNdEx])
			i = encodeVarintCoordinator(dAtA, i, uint64(len(m.Addresses[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PeerId) > 0 {
		i -= len(m.PeerId)
		copy(dAtA[i:], m.PeerId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.PeerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCoordinator(dAtA []byte, offset int, v uint64) int {
	offset -= sovCoordinator(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SpaceSignRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.Header)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *SpaceStatusPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovCoordinator(uint64(m.Status))
	}
	if m.DeletionTimestamp != 0 {
		n += 1 + sovCoordinator(uint64(m.DeletionTimestamp))
	}
	return n
}

func (m *SpaceSignResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Receipt != nil {
		l = m.Receipt.Size()
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *SpaceReceiptWithSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceReceiptPayload)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *SpaceReceipt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.PeerId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.AccountIdentity)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.ControlNodeIdentity)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	if m.ValidUntil != 0 {
		n += 1 + sovCoordinator(uint64(m.ValidUntil))
	}
	return n
}

func (m *FileLimitCheckRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountIdentity)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *FileLimitCheckResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Limit != 0 {
		n += 1 + sovCoordinator(uint64(m.Limit))
	}
	return n
}

func (m *SpaceStatusCheckRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *SpaceStatusCheckResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *SpaceStatusChangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.DeletionChangeId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.DeletionChangePayload)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *SpaceStatusChangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *NetworkConfigurationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConfigurationId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *NetworkConfigurationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConfigurationId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovCoordinator(uint64(l))
		}
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PeerId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	if len(m.Addresses) > 0 {
		for _, s := range m.Addresses {
			l = len(s)
			n += 1 + l + sovCoordinator(uint64(l))
		}
	}
	if len(m.Types) > 0 {
		l = 0
		for _, e := range m.Types {
			l += sovCoordinator(uint64(e))
		}
		n += 1 + sovCoordinator(uint64(l)) + l
	}
	return n
}

func sovCoordinator(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCoordinator(x uint64) (n int) {
	return sovCoordinator(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SpaceSignRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceSignRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceSignRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Header = append(m.Header[:0], dAtA[iNdEx:postIndex]...)
			if m.Header == nil {
				m.Header = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceStatusPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceStatusPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceStatusPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= SpaceStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionTimestamp", wireType)
			}
			m.DeletionTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeletionTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceSignResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceSignResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceSignResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receipt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Receipt == nil {
				m.Receipt = &SpaceReceiptWithSignature{}
			}
			if err := m.Receipt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceReceiptWithSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceReceiptWithSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceReceiptWithSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceReceiptPayload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceReceiptPayload = append(m.SpaceReceiptPayload[:0], dAtA[iNdEx:postIndex]...)
			if m.SpaceReceiptPayload == nil {
				m.SpaceReceiptPayload = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceReceipt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceReceipt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceReceipt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountIdentity", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountIdentity = append(m.AccountIdentity[:0], dAtA[iNdEx:postIndex]...)
			if m.AccountIdentity == nil {
				m.AccountIdentity = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlNodeIdentity", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ControlNodeIdentity = append(m.ControlNodeIdentity[:0], dAtA[iNdEx:postIndex]...)
			if m.ControlNodeIdentity == nil {
				m.ControlNodeIdentity = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidUntil", wireType)
			}
			m.ValidUntil = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidUntil |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileLimitCheckRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileLimitCheckRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileLimitCheckRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountIdentity", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountIdentity = append(m.AccountIdentity[:0], dAtA[iNdEx:postIndex]...)
			if m.AccountIdentity == nil {
				m.AccountIdentity = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileLimitCheckResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileLimitCheckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileLimitCheckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceStatusCheckRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceStatusCheckRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceStatusCheckRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceStatusCheckResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceStatusCheckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceStatusCheckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &SpaceStatusPayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceStatusChangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceStatusChangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceStatusChangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionChangeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeletionChangeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionChangePayload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeletionChangePayload = append(m.DeletionChangePayload[:0], dAtA[iNdEx:postIndex]...)
			if m.DeletionChangePayload == nil {
				m.DeletionChangePayload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceStatusChangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceStatusChangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceStatusChangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &SpaceStatusPayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkConfigurationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkConfigurationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkConfigurationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigurationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigurationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkConfigurationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkConfigurationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkConfigurationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigurationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigurationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addresses = append(m.Addresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v NodeType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCoordinator
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= NodeType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Types = append(m.Types, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCoordinator
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCoordinator
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCoordinator
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Types) == 0 {
					m.Types = make([]NodeType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v NodeType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCoordinator
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= NodeType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Types = append(m.Types, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCoordinator(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCoordinator
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCoordinator
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCoordinator
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCoordinator        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCoordinator          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCoordinator = fmt.Errorf("proto: unexpected end of group")
)
