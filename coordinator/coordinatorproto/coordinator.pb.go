// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: coordinator/coordinatorproto/protos/coordinator.proto

package coordinatorproto

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ErrorCodes int32

const (
	ErrorCodes_Unexpected           ErrorCodes = 0
	ErrorCodes_SpaceDeleted         ErrorCodes = 1
	ErrorCodes_SpaceDeletionPending ErrorCodes = 2
	ErrorCodes_SpaceCreated         ErrorCodes = 3
	ErrorCodes_SpaceNotExists       ErrorCodes = 4
	ErrorCodes_ErrorOffset          ErrorCodes = 300
)

var ErrorCodes_name = map[int32]string{
	0:   "Unexpected",
	1:   "SpaceDeleted",
	2:   "SpaceDeletionPending",
	3:   "SpaceCreated",
	4:   "SpaceNotExists",
	300: "ErrorOffset",
}

var ErrorCodes_value = map[string]int32{
	"Unexpected":           0,
	"SpaceDeleted":         1,
	"SpaceDeletionPending": 2,
	"SpaceCreated":         3,
	"SpaceNotExists":       4,
	"ErrorOffset":          300,
}

func (x ErrorCodes) String() string {
	return proto.EnumName(ErrorCodes_name, int32(x))
}

func (ErrorCodes) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{0}
}

type SpaceStatus int32

const (
	SpaceStatus_SpaceStatusCreated         SpaceStatus = 0
	SpaceStatus_SpaceStatusPendingDeletion SpaceStatus = 1
	SpaceStatus_SpaceStatusDeletionStarted SpaceStatus = 2
	SpaceStatus_SpaceStatusDeleted         SpaceStatus = 3
)

var SpaceStatus_name = map[int32]string{
	0: "SpaceStatusCreated",
	1: "SpaceStatusPendingDeletion",
	2: "SpaceStatusDeletionStarted",
	3: "SpaceStatusDeleted",
}

var SpaceStatus_value = map[string]int32{
	"SpaceStatusCreated":         0,
	"SpaceStatusPendingDeletion": 1,
	"SpaceStatusDeletionStarted": 2,
	"SpaceStatusDeleted":         3,
}

func (x SpaceStatus) String() string {
	return proto.EnumName(SpaceStatus_name, int32(x))
}

func (SpaceStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{1}
}

// NodeType determines the type of API that a node supports
type NodeType int32

const (
	// TreeAPI supports space/tree sync api
	NodeType_TreeAPI NodeType = 0
	// FileAPI support file api
	NodeType_FileAPI NodeType = 1
	// CoordinatorAPI supports coordinator api
	NodeType_CoordinatorAPI NodeType = 2
)

var NodeType_name = map[int32]string{
	0: "TreeAPI",
	1: "FileAPI",
	2: "CoordinatorAPI",
}

var NodeType_value = map[string]int32{
	"TreeAPI":        0,
	"FileAPI":        1,
	"CoordinatorAPI": 2,
}

func (x NodeType) String() string {
	return proto.EnumName(NodeType_name, int32(x))
}

func (NodeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{2}
}

type SpaceSignRequest struct {
	// SpaceId is the id of the signed space
	SpaceId string `protobuf:"bytes,1,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
	// Header is the header of the signed space
	Header []byte `protobuf:"bytes,2,opt,name=header,proto3" json:"header,omitempty"`
	// OldIdentity is the old identity of the space owner
	OldIdentity []byte `protobuf:"bytes,3,opt,name=oldIdentity,proto3" json:"oldIdentity,omitempty"`
	// NewIdentitySignature is the new identity signed by the old one
	NewIdentitySignature []byte `protobuf:"bytes,4,opt,name=newIdentitySignature,proto3" json:"newIdentitySignature,omitempty"`
}

func (m *SpaceSignRequest) Reset()         { *m = SpaceSignRequest{} }
func (m *SpaceSignRequest) String() string { return proto.CompactTextString(m) }
func (*SpaceSignRequest) ProtoMessage()    {}
func (*SpaceSignRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{0}
}
func (m *SpaceSignRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceSignRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceSignRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceSignRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceSignRequest.Merge(m, src)
}
func (m *SpaceSignRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpaceSignRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceSignRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceSignRequest proto.InternalMessageInfo

func (m *SpaceSignRequest) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

func (m *SpaceSignRequest) GetHeader() []byte {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *SpaceSignRequest) GetOldIdentity() []byte {
	if m != nil {
		return m.OldIdentity
	}
	return nil
}

func (m *SpaceSignRequest) GetNewIdentitySignature() []byte {
	if m != nil {
		return m.NewIdentitySignature
	}
	return nil
}

type SpaceStatusPayload struct {
	Status            SpaceStatus `protobuf:"varint,1,opt,name=status,proto3,enum=coordinator.SpaceStatus" json:"status,omitempty"`
	DeletionTimestamp int64       `protobuf:"varint,2,opt,name=deletionTimestamp,proto3" json:"deletionTimestamp,omitempty"`
}

func (m *SpaceStatusPayload) Reset()         { *m = SpaceStatusPayload{} }
func (m *SpaceStatusPayload) String() string { return proto.CompactTextString(m) }
func (*SpaceStatusPayload) ProtoMessage()    {}
func (*SpaceStatusPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{1}
}
func (m *SpaceStatusPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceStatusPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceStatusPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceStatusPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceStatusPayload.Merge(m, src)
}
func (m *SpaceStatusPayload) XXX_Size() int {
	return m.Size()
}
func (m *SpaceStatusPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceStatusPayload.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceStatusPayload proto.InternalMessageInfo

func (m *SpaceStatusPayload) GetStatus() SpaceStatus {
	if m != nil {
		return m.Status
	}
	return SpaceStatus_SpaceStatusCreated
}

func (m *SpaceStatusPayload) GetDeletionTimestamp() int64 {
	if m != nil {
		return m.DeletionTimestamp
	}
	return 0
}

type SpaceSignResponse struct {
	Receipt *SpaceReceiptWithSignature `protobuf:"bytes,1,opt,name=receipt,proto3" json:"receipt,omitempty"`
}

func (m *SpaceSignResponse) Reset()         { *m = SpaceSignResponse{} }
func (m *SpaceSignResponse) String() string { return proto.CompactTextString(m) }
func (*SpaceSignResponse) ProtoMessage()    {}
func (*SpaceSignResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{2}
}
func (m *SpaceSignResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceSignResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceSignResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceSignResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceSignResponse.Merge(m, src)
}
func (m *SpaceSignResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpaceSignResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceSignResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceSignResponse proto.InternalMessageInfo

func (m *SpaceSignResponse) GetReceipt() *SpaceReceiptWithSignature {
	if m != nil {
		return m.Receipt
	}
	return nil
}

// SpaceReceiptWithSignature contains protobuf encoded receipt and its signature
type SpaceReceiptWithSignature struct {
	SpaceReceiptPayload []byte `protobuf:"bytes,1,opt,name=spaceReceiptPayload,proto3" json:"spaceReceiptPayload,omitempty"`
	Signature           []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *SpaceReceiptWithSignature) Reset()         { *m = SpaceReceiptWithSignature{} }
func (m *SpaceReceiptWithSignature) String() string { return proto.CompactTextString(m) }
func (*SpaceReceiptWithSignature) ProtoMessage()    {}
func (*SpaceReceiptWithSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{3}
}
func (m *SpaceReceiptWithSignature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceReceiptWithSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceReceiptWithSignature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceReceiptWithSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceReceiptWithSignature.Merge(m, src)
}
func (m *SpaceReceiptWithSignature) XXX_Size() int {
	return m.Size()
}
func (m *SpaceReceiptWithSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceReceiptWithSignature.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceReceiptWithSignature proto.InternalMessageInfo

func (m *SpaceReceiptWithSignature) GetSpaceReceiptPayload() []byte {
	if m != nil {
		return m.SpaceReceiptPayload
	}
	return nil
}

func (m *SpaceReceiptWithSignature) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// SpaceReceipt contains permission to SpacePush operation
type SpaceReceipt struct {
	// SpaceId is the identifier of space
	SpaceId string `protobuf:"bytes,1,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
	// PeerId of receipt requester
	PeerId string `protobuf:"bytes,2,opt,name=peerId,proto3" json:"peerId,omitempty"`
	// AccountIdentity is an identity of a space owner
	AccountIdentity []byte `protobuf:"bytes,3,opt,name=accountIdentity,proto3" json:"accountIdentity,omitempty"`
	// NetworkId is the id of a network where the receipt is issued
	NetworkId string `protobuf:"bytes,4,opt,name=networkId,proto3" json:"networkId,omitempty"`
	// ValidUntil is a unix-timestamp with a deadline time of receipt validity
	ValidUntil uint64 `protobuf:"varint,5,opt,name=validUntil,proto3" json:"validUntil,omitempty"`
}

func (m *SpaceReceipt) Reset()         { *m = SpaceReceipt{} }
func (m *SpaceReceipt) String() string { return proto.CompactTextString(m) }
func (*SpaceReceipt) ProtoMessage()    {}
func (*SpaceReceipt) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{4}
}
func (m *SpaceReceipt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceReceipt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceReceipt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceReceipt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceReceipt.Merge(m, src)
}
func (m *SpaceReceipt) XXX_Size() int {
	return m.Size()
}
func (m *SpaceReceipt) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceReceipt.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceReceipt proto.InternalMessageInfo

func (m *SpaceReceipt) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

func (m *SpaceReceipt) GetPeerId() string {
	if m != nil {
		return m.PeerId
	}
	return ""
}

func (m *SpaceReceipt) GetAccountIdentity() []byte {
	if m != nil {
		return m.AccountIdentity
	}
	return nil
}

func (m *SpaceReceipt) GetNetworkId() string {
	if m != nil {
		return m.NetworkId
	}
	return ""
}

func (m *SpaceReceipt) GetValidUntil() uint64 {
	if m != nil {
		return m.ValidUntil
	}
	return 0
}

// FileLimitCheckRequest contains an account identity and spaceId
// control node checks that identity owns a given space
type FileLimitCheckRequest struct {
	AccountIdentity []byte `protobuf:"bytes,1,opt,name=accountIdentity,proto3" json:"accountIdentity,omitempty"`
	SpaceId         string `protobuf:"bytes,2,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
}

func (m *FileLimitCheckRequest) Reset()         { *m = FileLimitCheckRequest{} }
func (m *FileLimitCheckRequest) String() string { return proto.CompactTextString(m) }
func (*FileLimitCheckRequest) ProtoMessage()    {}
func (*FileLimitCheckRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{5}
}
func (m *FileLimitCheckRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileLimitCheckRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileLimitCheckRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileLimitCheckRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileLimitCheckRequest.Merge(m, src)
}
func (m *FileLimitCheckRequest) XXX_Size() int {
	return m.Size()
}
func (m *FileLimitCheckRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FileLimitCheckRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FileLimitCheckRequest proto.InternalMessageInfo

func (m *FileLimitCheckRequest) GetAccountIdentity() []byte {
	if m != nil {
		return m.AccountIdentity
	}
	return nil
}

func (m *FileLimitCheckRequest) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

// FileLimitCheckResponse returns a current space limit in bytes
type FileLimitCheckResponse struct {
	Limit uint64 `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *FileLimitCheckResponse) Reset()         { *m = FileLimitCheckResponse{} }
func (m *FileLimitCheckResponse) String() string { return proto.CompactTextString(m) }
func (*FileLimitCheckResponse) ProtoMessage()    {}
func (*FileLimitCheckResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{6}
}
func (m *FileLimitCheckResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileLimitCheckResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileLimitCheckResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileLimitCheckResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileLimitCheckResponse.Merge(m, src)
}
func (m *FileLimitCheckResponse) XXX_Size() int {
	return m.Size()
}
func (m *FileLimitCheckResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FileLimitCheckResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FileLimitCheckResponse proto.InternalMessageInfo

func (m *FileLimitCheckResponse) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

// SpaceStatusCheckRequest contains the spaceId of requested space
type SpaceStatusCheckRequest struct {
	SpaceId string `protobuf:"bytes,1,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
}

func (m *SpaceStatusCheckRequest) Reset()         { *m = SpaceStatusCheckRequest{} }
func (m *SpaceStatusCheckRequest) String() string { return proto.CompactTextString(m) }
func (*SpaceStatusCheckRequest) ProtoMessage()    {}
func (*SpaceStatusCheckRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{7}
}
func (m *SpaceStatusCheckRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceStatusCheckRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceStatusCheckRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceStatusCheckRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceStatusCheckRequest.Merge(m, src)
}
func (m *SpaceStatusCheckRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpaceStatusCheckRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceStatusCheckRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceStatusCheckRequest proto.InternalMessageInfo

func (m *SpaceStatusCheckRequest) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

// SpaceStatusCheckResponse contains the current status of space
type SpaceStatusCheckResponse struct {
	Payload *SpaceStatusPayload `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *SpaceStatusCheckResponse) Reset()         { *m = SpaceStatusCheckResponse{} }
func (m *SpaceStatusCheckResponse) String() string { return proto.CompactTextString(m) }
func (*SpaceStatusCheckResponse) ProtoMessage()    {}
func (*SpaceStatusCheckResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{8}
}
func (m *SpaceStatusCheckResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceStatusCheckResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceStatusCheckResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceStatusCheckResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceStatusCheckResponse.Merge(m, src)
}
func (m *SpaceStatusCheckResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpaceStatusCheckResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceStatusCheckResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceStatusCheckResponse proto.InternalMessageInfo

func (m *SpaceStatusCheckResponse) GetPayload() *SpaceStatusPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

// SpaceStatusChangeRequest contains the deletionChange if we want to delete space, or it is empty otherwise
type SpaceStatusChangeRequest struct {
	SpaceId               string `protobuf:"bytes,1,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
	DeletionChangeId      string `protobuf:"bytes,2,opt,name=deletionChangeId,proto3" json:"deletionChangeId,omitempty"`
	DeletionChangePayload []byte `protobuf:"bytes,3,opt,name=deletionChangePayload,proto3" json:"deletionChangePayload,omitempty"`
}

func (m *SpaceStatusChangeRequest) Reset()         { *m = SpaceStatusChangeRequest{} }
func (m *SpaceStatusChangeRequest) String() string { return proto.CompactTextString(m) }
func (*SpaceStatusChangeRequest) ProtoMessage()    {}
func (*SpaceStatusChangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{9}
}
func (m *SpaceStatusChangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceStatusChangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceStatusChangeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceStatusChangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceStatusChangeRequest.Merge(m, src)
}
func (m *SpaceStatusChangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpaceStatusChangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceStatusChangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceStatusChangeRequest proto.InternalMessageInfo

func (m *SpaceStatusChangeRequest) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

func (m *SpaceStatusChangeRequest) GetDeletionChangeId() string {
	if m != nil {
		return m.DeletionChangeId
	}
	return ""
}

func (m *SpaceStatusChangeRequest) GetDeletionChangePayload() []byte {
	if m != nil {
		return m.DeletionChangePayload
	}
	return nil
}

// SpaceStatusChangeResponse contains changed status of space
type SpaceStatusChangeResponse struct {
	Payload *SpaceStatusPayload `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *SpaceStatusChangeResponse) Reset()         { *m = SpaceStatusChangeResponse{} }
func (m *SpaceStatusChangeResponse) String() string { return proto.CompactTextString(m) }
func (*SpaceStatusChangeResponse) ProtoMessage()    {}
func (*SpaceStatusChangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{10}
}
func (m *SpaceStatusChangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceStatusChangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceStatusChangeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceStatusChangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceStatusChangeResponse.Merge(m, src)
}
func (m *SpaceStatusChangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpaceStatusChangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceStatusChangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceStatusChangeResponse proto.InternalMessageInfo

func (m *SpaceStatusChangeResponse) GetPayload() *SpaceStatusPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

// NetworkConfigurationRequest contains currenId of the client configuration, it can be empty
type NetworkConfigurationRequest struct {
	// currenId of the client configuration
	// if the currentId is equal to the latest configuration id then the response will not contain a nodes list
	CurrentId string `protobuf:"bytes,1,opt,name=currentId,proto3" json:"currentId,omitempty"`
}

func (m *NetworkConfigurationRequest) Reset()         { *m = NetworkConfigurationRequest{} }
func (m *NetworkConfigurationRequest) String() string { return proto.CompactTextString(m) }
func (*NetworkConfigurationRequest) ProtoMessage()    {}
func (*NetworkConfigurationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{11}
}
func (m *NetworkConfigurationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkConfigurationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkConfigurationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkConfigurationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkConfigurationRequest.Merge(m, src)
}
func (m *NetworkConfigurationRequest) XXX_Size() int {
	return m.Size()
}
func (m *NetworkConfigurationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkConfigurationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkConfigurationRequest proto.InternalMessageInfo

func (m *NetworkConfigurationRequest) GetCurrentId() string {
	if m != nil {
		return m.CurrentId
	}
	return ""
}

// NetworkConfigurationResponse contains list of nodes
type NetworkConfigurationResponse struct {
	// id of current configuration
	ConfigurationId string `protobuf:"bytes,1,opt,name=configurationId,proto3" json:"configurationId,omitempty"`
	// network id
	NetworkId string `protobuf:"bytes,2,opt,name=networkId,proto3" json:"networkId,omitempty"`
	// nodes list - it will be empty if the client's currentId is equal configurationId
	Nodes []*Node `protobuf:"bytes,3,rep,name=nodes,proto3" json:"nodes,omitempty"`
	// unix timestamp of the creation time of configuration
	CreationTimeUnix uint64 `protobuf:"varint,4,opt,name=creationTimeUnix,proto3" json:"creationTimeUnix,omitempty"`
}

func (m *NetworkConfigurationResponse) Reset()         { *m = NetworkConfigurationResponse{} }
func (m *NetworkConfigurationResponse) String() string { return proto.CompactTextString(m) }
func (*NetworkConfigurationResponse) ProtoMessage()    {}
func (*NetworkConfigurationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{12}
}
func (m *NetworkConfigurationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkConfigurationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkConfigurationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkConfigurationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkConfigurationResponse.Merge(m, src)
}
func (m *NetworkConfigurationResponse) XXX_Size() int {
	return m.Size()
}
func (m *NetworkConfigurationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkConfigurationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkConfigurationResponse proto.InternalMessageInfo

func (m *NetworkConfigurationResponse) GetConfigurationId() string {
	if m != nil {
		return m.ConfigurationId
	}
	return ""
}

func (m *NetworkConfigurationResponse) GetNetworkId() string {
	if m != nil {
		return m.NetworkId
	}
	return ""
}

func (m *NetworkConfigurationResponse) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *NetworkConfigurationResponse) GetCreationTimeUnix() uint64 {
	if m != nil {
		return m.CreationTimeUnix
	}
	return 0
}

// Node describes one node in the network
type Node struct {
	// peerId - it's a peer identifier (libp2p format string) so it's an encoded publicKey
	PeerId string `protobuf:"bytes,1,opt,name=peerId,proto3" json:"peerId,omitempty"`
	// list of node addresses
	Addresses []string `protobuf:"bytes,2,rep,name=addresses,proto3" json:"addresses,omitempty"`
	// list of supported APIs
	Types []NodeType `protobuf:"varint,3,rep,packed,name=types,proto3,enum=coordinator.NodeType" json:"types,omitempty"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_d94f6f99586adae2, []int{13}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetPeerId() string {
	if m != nil {
		return m.PeerId
	}
	return ""
}

func (m *Node) GetAddresses() []string {
	if m != nil {
		return m.Addresses
	}
	return nil
}

func (m *Node) GetTypes() []NodeType {
	if m != nil {
		return m.Types
	}
	return nil
}

func init() {
	proto.RegisterEnum("coordinator.ErrorCodes", ErrorCodes_name, ErrorCodes_value)
	proto.RegisterEnum("coordinator.SpaceStatus", SpaceStatus_name, SpaceStatus_value)
	proto.RegisterEnum("coordinator.NodeType", NodeType_name, NodeType_value)
	proto.RegisterType((*SpaceSignRequest)(nil), "coordinator.SpaceSignRequest")
	proto.RegisterType((*SpaceStatusPayload)(nil), "coordinator.SpaceStatusPayload")
	proto.RegisterType((*SpaceSignResponse)(nil), "coordinator.SpaceSignResponse")
	proto.RegisterType((*SpaceReceiptWithSignature)(nil), "coordinator.SpaceReceiptWithSignature")
	proto.RegisterType((*SpaceReceipt)(nil), "coordinator.SpaceReceipt")
	proto.RegisterType((*FileLimitCheckRequest)(nil), "coordinator.FileLimitCheckRequest")
	proto.RegisterType((*FileLimitCheckResponse)(nil), "coordinator.FileLimitCheckResponse")
	proto.RegisterType((*SpaceStatusCheckRequest)(nil), "coordinator.SpaceStatusCheckRequest")
	proto.RegisterType((*SpaceStatusCheckResponse)(nil), "coordinator.SpaceStatusCheckResponse")
	proto.RegisterType((*SpaceStatusChangeRequest)(nil), "coordinator.SpaceStatusChangeRequest")
	proto.RegisterType((*SpaceStatusChangeResponse)(nil), "coordinator.SpaceStatusChangeResponse")
	proto.RegisterType((*NetworkConfigurationRequest)(nil), "coordinator.NetworkConfigurationRequest")
	proto.RegisterType((*NetworkConfigurationResponse)(nil), "coordinator.NetworkConfigurationResponse")
	proto.RegisterType((*Node)(nil), "coordinator.Node")
}

func init() {
	proto.RegisterFile("coordinator/coordinatorproto/protos/coordinator.proto", fileDescriptor_d94f6f99586adae2)
}

var fileDescriptor_d94f6f99586adae2 = []byte{
	// 914 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xcf, 0x6e, 0xeb, 0x44,
	0x17, 0x8f, 0x93, 0xb4, 0xfd, 0x72, 0x5c, 0xe5, 0xba, 0xf3, 0xb5, 0xc5, 0x84, 0x60, 0x22, 0x03,
	0x97, 0x50, 0x50, 0xef, 0x55, 0x2e, 0x20, 0x10, 0x1b, 0x20, 0x5c, 0xa4, 0x20, 0x54, 0x2a, 0xb7,
	0x01, 0x01, 0x0b, 0xe4, 0xeb, 0x39, 0x6d, 0x47, 0x4d, 0x6d, 0x33, 0x33, 0xe1, 0xb6, 0x0b, 0x24,
	0x1e, 0x81, 0x15, 0x0b, 0x9e, 0x80, 0x05, 0x6f, 0xc0, 0x0b, 0xb0, 0xbc, 0x4b, 0x96, 0xa8, 0x95,
	0x78, 0x0e, 0x34, 0x63, 0x3b, 0x19, 0x27, 0x4e, 0x8b, 0xc4, 0x26, 0xc9, 0xf9, 0x9d, 0xff, 0x73,
	0x7e, 0x73, 0x26, 0xf0, 0x76, 0x94, 0x24, 0x9c, 0xb2, 0x38, 0x94, 0x09, 0x7f, 0x60, 0xfc, 0x4e,
	0x79, 0x22, 0x93, 0x07, 0xfa, 0x53, 0x98, 0xf8, 0xbe, 0x86, 0x88, 0x6d, 0x40, 0xfe, 0x2f, 0x16,
	0x38, 0x47, 0x69, 0x18, 0xe1, 0x11, 0x3b, 0x8d, 0x03, 0xfc, 0x6e, 0x8a, 0x42, 0x12, 0x17, 0x36,
	0x84, 0xc2, 0x46, 0xd4, 0xb5, 0x7a, 0x56, 0xbf, 0x15, 0x14, 0x22, 0xd9, 0x85, 0xf5, 0x33, 0x0c,
	0x29, 0x72, 0xb7, 0xde, 0xb3, 0xfa, 0x9b, 0x41, 0x2e, 0x91, 0x1e, 0xd8, 0xc9, 0x84, 0x8e, 0x28,
	0xc6, 0x92, 0xc9, 0x2b, 0xb7, 0xa1, 0x95, 0x26, 0x44, 0x06, 0xb0, 0x1d, 0xe3, 0xd3, 0x42, 0x54,
	0xd9, 0x42, 0x39, 0xe5, 0xe8, 0x36, 0xb5, 0x69, 0xa5, 0xce, 0x97, 0x40, 0xb2, 0xda, 0x64, 0x28,
	0xa7, 0xe2, 0x30, 0xbc, 0x9a, 0x24, 0x21, 0x25, 0x0f, 0x61, 0x5d, 0x68, 0x40, 0x17, 0xd7, 0x1e,
	0xb8, 0xfb, 0x66, 0x8f, 0x86, 0x43, 0x90, 0xdb, 0x91, 0x37, 0x61, 0x8b, 0xe2, 0x04, 0x25, 0x4b,
	0xe2, 0x63, 0x76, 0x81, 0x42, 0x86, 0x17, 0xa9, 0x6e, 0xa0, 0x11, 0x2c, 0x2b, 0xfc, 0x31, 0x6c,
	0x19, 0x27, 0x22, 0xd2, 0x24, 0x16, 0x48, 0x3e, 0x80, 0x0d, 0x8e, 0x11, 0xb2, 0x54, 0xea, 0xac,
	0xf6, 0xe0, 0xfe, 0x72, 0xd6, 0x20, 0x33, 0xf8, 0x92, 0xc9, 0xb3, 0x59, 0x0f, 0x41, 0xe1, 0xe6,
	0x9f, 0xc3, 0xf3, 0x2b, 0xad, 0xc8, 0x43, 0xf8, 0xbf, 0x30, 0x94, 0x79, 0xab, 0x3a, 0xd5, 0x66,
	0x50, 0xa5, 0x22, 0x5d, 0x68, 0x89, 0xd9, 0x21, 0x66, 0xc3, 0x98, 0x03, 0xfe, 0xaf, 0x16, 0x6c,
	0x9a, 0xd9, 0x6e, 0x1f, 0x69, 0x8a, 0xc8, 0x47, 0x54, 0x47, 0x69, 0x05, 0xb9, 0x44, 0xfa, 0x70,
	0x2f, 0x8c, 0xa2, 0x64, 0x1a, 0xcb, 0x85, 0xb1, 0x2e, 0xc2, 0xaa, 0x94, 0x18, 0xe5, 0xd3, 0x84,
	0x9f, 0x8f, 0xa8, 0x9e, 0x67, 0x2b, 0x98, 0x03, 0xc4, 0x03, 0xf8, 0x3e, 0x9c, 0x30, 0x3a, 0x8e,
	0x25, 0x9b, 0xb8, 0x6b, 0x3d, 0xab, 0xdf, 0x0c, 0x0c, 0xc4, 0xff, 0x06, 0x76, 0x3e, 0x61, 0x13,
	0xfc, 0x8c, 0x5d, 0x30, 0x39, 0x3c, 0xc3, 0xe8, 0xbc, 0x60, 0x61, 0x45, 0x01, 0x56, 0x75, 0x01,
	0x46, 0x73, 0xf5, 0x52, 0x73, 0xfe, 0x3e, 0xec, 0x2e, 0x06, 0xcf, 0x07, 0xba, 0x0d, 0x6b, 0x13,
	0x85, 0xea, 0x98, 0xcd, 0x20, 0x13, 0xfc, 0x47, 0xf0, 0x9c, 0x41, 0xa0, 0x52, 0x39, 0x2b, 0x4f,
	0xd0, 0x1f, 0x83, 0xbb, 0xec, 0x94, 0xa7, 0x79, 0x0f, 0x36, 0x52, 0x63, 0x98, 0xf6, 0xe0, 0xa5,
	0x55, 0x6c, 0xcd, 0x07, 0x1b, 0x14, 0xf6, 0xfe, 0xcf, 0xd6, 0x42, 0xdc, 0x30, 0x3e, 0xc5, 0xbb,
	0xaf, 0xe8, 0x1e, 0x38, 0x05, 0xa7, 0x33, 0x97, 0xd9, 0xa9, 0x2c, 0xe1, 0xe4, 0x2d, 0xd8, 0x29,
	0x63, 0x05, 0xf1, 0xb2, 0x49, 0x57, 0x2b, 0xfd, 0x2f, 0x72, 0x26, 0x97, 0xeb, 0xfa, 0xef, 0x0d,
	0xbf, 0x0f, 0x2f, 0x1c, 0x64, 0xb4, 0x19, 0x26, 0xf1, 0x09, 0x3b, 0x9d, 0xf2, 0x50, 0x25, 0x2f,
	0x5a, 0xee, 0x42, 0x2b, 0x9a, 0x72, 0x8e, 0x6a, 0xf0, 0x79, 0xd3, 0x73, 0xc0, 0xff, 0xdd, 0x82,
	0x6e, 0xb5, 0x77, 0x5e, 0x58, 0x1f, 0xee, 0x45, 0xa6, 0x62, 0x16, 0x64, 0x11, 0x2e, 0xf3, 0xb9,
	0xbe, 0xc8, 0xe7, 0xd7, 0x60, 0x2d, 0x4e, 0x28, 0x0a, 0xb7, 0xd1, 0x6b, 0xf4, 0xed, 0xc1, 0x56,
	0xa9, 0xbd, 0x83, 0x84, 0x62, 0x90, 0xe9, 0xd5, 0x20, 0x22, 0x8e, 0x61, 0xb1, 0x5c, 0xc6, 0x31,
	0xbb, 0xd4, 0xb7, 0xa3, 0x19, 0x2c, 0xe1, 0x3e, 0x83, 0xa6, 0x72, 0x35, 0x2e, 0xa3, 0x55, 0xba,
	0x8c, 0x5d, 0x68, 0x85, 0x94, 0x72, 0x14, 0x02, 0x85, 0x5b, 0xef, 0x35, 0x54, 0x49, 0x33, 0x80,
	0xbc, 0x01, 0x6b, 0xf2, 0x2a, 0xcd, 0x4b, 0x6a, 0x0f, 0x76, 0x96, 0x4a, 0x3a, 0xbe, 0x4a, 0x31,
	0xc8, 0x6c, 0xf6, 0x7e, 0xb4, 0x00, 0x1e, 0x73, 0x9e, 0xf0, 0xa1, 0xae, 0xb2, 0x0d, 0x30, 0x8e,
	0xf1, 0x32, 0xc5, 0x48, 0x22, 0x75, 0x6a, 0xc4, 0xc9, 0x17, 0xc7, 0xc7, 0x6a, 0xf4, 0x48, 0x1d,
	0x8b, 0xb8, 0xb0, 0x3d, 0x47, 0x58, 0x12, 0x1f, 0x62, 0x4c, 0x59, 0x7c, 0xea, 0xd4, 0x67, 0xb6,
	0x43, 0xd5, 0x0e, 0x52, 0xa7, 0x41, 0x08, 0xb4, 0x35, 0x72, 0x90, 0xc8, 0xc7, 0x97, 0x4c, 0x48,
	0xe1, 0x34, 0x89, 0x03, 0xb6, 0xce, 0xf7, 0xf9, 0xc9, 0x89, 0x40, 0xe9, 0xfc, 0x56, 0xdf, 0xfb,
	0x01, 0x6c, 0x83, 0x07, 0x64, 0xb7, 0xb4, 0xe6, 0x8b, 0x60, 0x35, 0xe2, 0x41, 0xc7, 0xa4, 0x4b,
	0x96, 0xb6, 0xa8, 0xc2, 0xb1, 0x16, 0xf4, 0x85, 0xe2, 0x48, 0x86, 0x5c, 0xf9, 0xd7, 0x17, 0xe2,
	0x16, 0x0d, 0x35, 0xf6, 0xde, 0x85, 0xff, 0x15, 0x87, 0x42, 0x6c, 0xd8, 0x38, 0xe6, 0x88, 0x1f,
	0x1e, 0x8e, 0x9c, 0x9a, 0x12, 0xd4, 0xb6, 0x50, 0x82, 0xa5, 0x5a, 0x19, 0xce, 0x8f, 0x51, 0x61,
	0xf5, 0xc1, 0xdf, 0x0d, 0xb0, 0x0d, 0x90, 0x7c, 0x0a, 0xad, 0xd9, 0x53, 0x41, 0x5e, 0xac, 0x20,
	0xfa, 0xfc, 0x51, 0xed, 0x78, 0xab, 0xd4, 0x39, 0x3f, 0xbf, 0x82, 0x76, 0x79, 0x55, 0x11, 0xbf,
	0xe4, 0x51, 0xb9, 0x24, 0x3b, 0x2f, 0xdf, 0x6a, 0x93, 0x87, 0xfe, 0xb6, 0x78, 0xe3, 0xe7, 0x0b,
	0x8a, 0xbc, 0xb2, 0xea, 0x5a, 0x96, 0xc2, 0xbf, 0x7a, 0x87, 0x55, 0x9e, 0xe0, 0x49, 0xf1, 0x64,
	0x1a, 0x1b, 0x81, 0xdc, 0xe2, 0x6b, 0x6c, 0xb2, 0xce, 0xfd, 0xbb, 0xcc, 0xf2, 0x1c, 0xe7, 0xb0,
	0x5d, 0x75, 0xbf, 0x49, 0xbf, 0xcc, 0xf6, 0xd5, 0x0b, 0xa4, 0xf3, 0xfa, 0xbf, 0xb0, 0xcc, 0x92,
	0x7d, 0xf4, 0xce, 0x1f, 0xd7, 0x9e, 0xf5, 0xec, 0xda, 0xb3, 0xfe, 0xba, 0xf6, 0xac, 0x9f, 0x6e,
	0xbc, 0xda, 0xb3, 0x1b, 0xaf, 0xf6, 0xe7, 0x8d, 0x57, 0xfb, 0xba, 0x7b, 0xdb, 0x9f, 0xae, 0x27,
	0xeb, 0xfa, 0xeb, 0xd1, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x0f, 0xcc, 0xe8, 0x2d, 0x9b, 0x09,
	0x00, 0x00,
}

func (m *SpaceSignRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceSignRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceSignRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewIdentitySignature) > 0 {
		i -= len(m.NewIdentitySignature)
		copy(dAtA[i:], m.NewIdentitySignature)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.NewIdentitySignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OldIdentity) > 0 {
		i -= len(m.OldIdentity)
		copy(dAtA[i:], m.OldIdentity)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.OldIdentity)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Header) > 0 {
		i -= len(m.Header)
		copy(dAtA[i:], m.Header)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.Header)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceStatusPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceStatusPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceStatusPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeletionTimestamp != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.DeletionTimestamp))
		i--
		dAtA[i] = 0x10
	}
	if m.Status != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpaceSignResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceSignResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceSignResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Receipt != nil {
		{
			size, err := m.Receipt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCoordinator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceReceiptWithSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceReceiptWithSignature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceReceiptWithSignature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpaceReceiptPayload) > 0 {
		i -= len(m.SpaceReceiptPayload)
		copy(dAtA[i:], m.SpaceReceiptPayload)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceReceiptPayload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceReceipt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceReceipt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceReceipt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValidUntil != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.ValidUntil))
		i--
		dAtA[i] = 0x28
	}
	if len(m.NetworkId) > 0 {
		i -= len(m.NetworkId)
		copy(dAtA[i:], m.NetworkId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.NetworkId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AccountIdentity) > 0 {
		i -= len(m.AccountIdentity)
		copy(dAtA[i:], m.AccountIdentity)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.AccountIdentity)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PeerId) > 0 {
		i -= len(m.PeerId)
		copy(dAtA[i:], m.PeerId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.PeerId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileLimitCheckRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileLimitCheckRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileLimitCheckRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccountIdentity) > 0 {
		i -= len(m.AccountIdentity)
		copy(dAtA[i:], m.AccountIdentity)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.AccountIdentity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileLimitCheckResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileLimitCheckResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileLimitCheckResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpaceStatusCheckRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceStatusCheckRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceStatusCheckRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceStatusCheckResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceStatusCheckResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceStatusCheckResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCoordinator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceStatusChangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceStatusChangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceStatusChangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DeletionChangePayload) > 0 {
		i -= len(m.DeletionChangePayload)
		copy(dAtA[i:], m.DeletionChangePayload)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.DeletionChangePayload)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DeletionChangeId) > 0 {
		i -= len(m.DeletionChangeId)
		copy(dAtA[i:], m.DeletionChangeId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.DeletionChangeId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceStatusChangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceStatusChangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceStatusChangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCoordinator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkConfigurationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkConfigurationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkConfigurationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CurrentId) > 0 {
		i -= len(m.CurrentId)
		copy(dAtA[i:], m.CurrentId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.CurrentId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkConfigurationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkConfigurationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkConfigurationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreationTimeUnix != 0 {
		i = encodeVarintCoordinator(dAtA, i, uint64(m.CreationTimeUnix))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCoordinator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.NetworkId) > 0 {
		i -= len(m.NetworkId)
		copy(dAtA[i:], m.NetworkId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.NetworkId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ConfigurationId) > 0 {
		i -= len(m.ConfigurationId)
		copy(dAtA[i:], m.ConfigurationId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.ConfigurationId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Types) > 0 {
		dAtA5 := make([]byte, len(m.Types)*10)
		var j4 int
		for _, num := range m.Types {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintCoordinator(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Addresses) > 0 {
		for iNdEx := len(m.Addresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Addresses[iNdEx])
			copy(dAtA[i:], m.Addresses[iNdEx])
			i = encodeVarintCoordinator(dAtA, i, uint64(len(m.Addresses[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PeerId) > 0 {
		i -= len(m.PeerId)
		copy(dAtA[i:], m.PeerId)
		i = encodeVarintCoordinator(dAtA, i, uint64(len(m.PeerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCoordinator(dAtA []byte, offset int, v uint64) int {
	offset -= sovCoordinator(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SpaceSignRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.Header)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.OldIdentity)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.NewIdentitySignature)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *SpaceStatusPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovCoordinator(uint64(m.Status))
	}
	if m.DeletionTimestamp != 0 {
		n += 1 + sovCoordinator(uint64(m.DeletionTimestamp))
	}
	return n
}

func (m *SpaceSignResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Receipt != nil {
		l = m.Receipt.Size()
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *SpaceReceiptWithSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceReceiptPayload)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *SpaceReceipt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.PeerId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.AccountIdentity)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.NetworkId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	if m.ValidUntil != 0 {
		n += 1 + sovCoordinator(uint64(m.ValidUntil))
	}
	return n
}

func (m *FileLimitCheckRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountIdentity)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *FileLimitCheckResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Limit != 0 {
		n += 1 + sovCoordinator(uint64(m.Limit))
	}
	return n
}

func (m *SpaceStatusCheckRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *SpaceStatusCheckResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *SpaceStatusChangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.DeletionChangeId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.DeletionChangePayload)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *SpaceStatusChangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *NetworkConfigurationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CurrentId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	return n
}

func (m *NetworkConfigurationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConfigurationId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	l = len(m.NetworkId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovCoordinator(uint64(l))
		}
	}
	if m.CreationTimeUnix != 0 {
		n += 1 + sovCoordinator(uint64(m.CreationTimeUnix))
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PeerId)
	if l > 0 {
		n += 1 + l + sovCoordinator(uint64(l))
	}
	if len(m.Addresses) > 0 {
		for _, s := range m.Addresses {
			l = len(s)
			n += 1 + l + sovCoordinator(uint64(l))
		}
	}
	if len(m.Types) > 0 {
		l = 0
		for _, e := range m.Types {
			l += sovCoordinator(uint64(e))
		}
		n += 1 + sovCoordinator(uint64(l)) + l
	}
	return n
}

func sovCoordinator(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCoordinator(x uint64) (n int) {
	return sovCoordinator(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SpaceSignRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceSignRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceSignRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Header = append(m.Header[:0], dAtA[iNdEx:postIndex]...)
			if m.Header == nil {
				m.Header = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldIdentity", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldIdentity = append(m.OldIdentity[:0], dAtA[iNdEx:postIndex]...)
			if m.OldIdentity == nil {
				m.OldIdentity = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewIdentitySignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewIdentitySignature = append(m.NewIdentitySignature[:0], dAtA[iNdEx:postIndex]...)
			if m.NewIdentitySignature == nil {
				m.NewIdentitySignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceStatusPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceStatusPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceStatusPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= SpaceStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionTimestamp", wireType)
			}
			m.DeletionTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeletionTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceSignResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceSignResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceSignResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receipt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Receipt == nil {
				m.Receipt = &SpaceReceiptWithSignature{}
			}
			if err := m.Receipt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceReceiptWithSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceReceiptWithSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceReceiptWithSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceReceiptPayload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceReceiptPayload = append(m.SpaceReceiptPayload[:0], dAtA[iNdEx:postIndex]...)
			if m.SpaceReceiptPayload == nil {
				m.SpaceReceiptPayload = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceReceipt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceReceipt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceReceipt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountIdentity", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountIdentity = append(m.AccountIdentity[:0], dAtA[iNdEx:postIndex]...)
			if m.AccountIdentity == nil {
				m.AccountIdentity = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidUntil", wireType)
			}
			m.ValidUntil = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidUntil |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileLimitCheckRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileLimitCheckRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileLimitCheckRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountIdentity", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountIdentity = append(m.AccountIdentity[:0], dAtA[iNdEx:postIndex]...)
			if m.AccountIdentity == nil {
				m.AccountIdentity = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileLimitCheckResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileLimitCheckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileLimitCheckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceStatusCheckRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceStatusCheckRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceStatusCheckRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceStatusCheckResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceStatusCheckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceStatusCheckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &SpaceStatusPayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceStatusChangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceStatusChangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceStatusChangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionChangeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeletionChangeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionChangePayload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeletionChangePayload = append(m.DeletionChangePayload[:0], dAtA[iNdEx:postIndex]...)
			if m.DeletionChangePayload == nil {
				m.DeletionChangePayload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceStatusChangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceStatusChangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceStatusChangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &SpaceStatusPayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkConfigurationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkConfigurationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkConfigurationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkConfigurationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkConfigurationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkConfigurationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigurationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigurationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimeUnix", wireType)
			}
			m.CreationTimeUnix = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreationTimeUnix |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCoordinator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addresses = append(m.Addresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v NodeType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCoordinator
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= NodeType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Types = append(m.Types, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCoordinator
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCoordinator
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCoordinator
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Types) == 0 {
					m.Types = make([]NodeType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v NodeType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCoordinator
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= NodeType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Types = append(m.Types, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCoordinator(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCoordinator
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCoordinator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCoordinator
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCoordinator
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCoordinator
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCoordinator        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCoordinator          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCoordinator = fmt.Errorf("proto: unexpected end of group")
)
