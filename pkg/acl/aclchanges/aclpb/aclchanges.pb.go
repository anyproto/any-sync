// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pkg/acl/aclchanges/aclpb/protos/aclchanges.proto

package aclpb

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ACLChangeUserPermissions int32

const (
	ACLChange_Admin   ACLChangeUserPermissions = 0
	ACLChange_Writer  ACLChangeUserPermissions = 1
	ACLChange_Reader  ACLChangeUserPermissions = 2
	ACLChange_Removed ACLChangeUserPermissions = 3
)

var ACLChangeUserPermissions_name = map[int32]string{
	0: "Admin",
	1: "Writer",
	2: "Reader",
	3: "Removed",
}

var ACLChangeUserPermissions_value = map[string]int32{
	"Admin":   0,
	"Writer":  1,
	"Reader":  2,
	"Removed": 3,
}

func (x ACLChangeUserPermissions) String() string {
	return proto.EnumName(ACLChangeUserPermissions_name, int32(x))
}

func (ACLChangeUserPermissions) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_37a022c841a51877, []int{1, 0}
}

type RawChange struct {
	Payload   []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	Signature []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	Id        string `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *RawChange) Reset()         { *m = RawChange{} }
func (m *RawChange) String() string { return proto.CompactTextString(m) }
func (*RawChange) ProtoMessage()    {}
func (*RawChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_37a022c841a51877, []int{0}
}
func (m *RawChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawChange.Merge(m, src)
}
func (m *RawChange) XXX_Size() int {
	return m.Size()
}
func (m *RawChange) XXX_DiscardUnknown() {
	xxx_messageInfo_RawChange.DiscardUnknown(m)
}

var xxx_messageInfo_RawChange proto.InternalMessageInfo

func (m *RawChange) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *RawChange) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *RawChange) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// the element of change tree used to store and internal apply smartBlock history
type ACLChange struct {
	TreeHeadIds    []string          `protobuf:"bytes,1,rep,name=treeHeadIds,proto3" json:"treeHeadIds,omitempty"`
	AclHeadIds     []string          `protobuf:"bytes,2,rep,name=aclHeadIds,proto3" json:"aclHeadIds,omitempty"`
	SnapshotBaseId string            `protobuf:"bytes,3,opt,name=snapshotBaseId,proto3" json:"snapshotBaseId,omitempty"`
	AclData        *ACLChangeACLData `protobuf:"bytes,4,opt,name=aclData,proto3" json:"aclData,omitempty"`
	// the data is encoded with read key and should be read in ChangesData format
	ChangesData        []byte `protobuf:"bytes,5,opt,name=changesData,proto3" json:"changesData,omitempty"`
	CurrentReadKeyHash uint64 `protobuf:"varint,6,opt,name=currentReadKeyHash,proto3" json:"currentReadKeyHash,omitempty"`
	Timestamp          int64  `protobuf:"varint,7,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Identity           string `protobuf:"bytes,8,opt,name=identity,proto3" json:"identity,omitempty"`
}

func (m *ACLChange) Reset()         { *m = ACLChange{} }
func (m *ACLChange) String() string { return proto.CompactTextString(m) }
func (*ACLChange) ProtoMessage()    {}
func (*ACLChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_37a022c841a51877, []int{1}
}
func (m *ACLChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ACLChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ACLChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ACLChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ACLChange.Merge(m, src)
}
func (m *ACLChange) XXX_Size() int {
	return m.Size()
}
func (m *ACLChange) XXX_DiscardUnknown() {
	xxx_messageInfo_ACLChange.DiscardUnknown(m)
}

var xxx_messageInfo_ACLChange proto.InternalMessageInfo

func (m *ACLChange) GetTreeHeadIds() []string {
	if m != nil {
		return m.TreeHeadIds
	}
	return nil
}

func (m *ACLChange) GetAclHeadIds() []string {
	if m != nil {
		return m.AclHeadIds
	}
	return nil
}

func (m *ACLChange) GetSnapshotBaseId() string {
	if m != nil {
		return m.SnapshotBaseId
	}
	return ""
}

func (m *ACLChange) GetAclData() *ACLChangeACLData {
	if m != nil {
		return m.AclData
	}
	return nil
}

func (m *ACLChange) GetChangesData() []byte {
	if m != nil {
		return m.ChangesData
	}
	return nil
}

func (m *ACLChange) GetCurrentReadKeyHash() uint64 {
	if m != nil {
		return m.CurrentReadKeyHash
	}
	return 0
}

func (m *ACLChange) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ACLChange) GetIdentity() string {
	if m != nil {
		return m.Identity
	}
	return ""
}

type ACLChangeACLContentValue struct {
	// Types that are valid to be assigned to Value:
	//	*ACLChangeACLContentValueValueOfUserAdd
	//	*ACLChangeACLContentValueValueOfUserRemove
	//	*ACLChangeACLContentValueValueOfUserPermissionChange
	//	*ACLChangeACLContentValueValueOfUserInvite
	//	*ACLChangeACLContentValueValueOfUserJoin
	//	*ACLChangeACLContentValueValueOfUserConfirm
	Value IsACLChangeACLContentValueValue `protobuf_oneof:"value"`
}

func (m *ACLChangeACLContentValue) Reset()         { *m = ACLChangeACLContentValue{} }
func (m *ACLChangeACLContentValue) String() string { return proto.CompactTextString(m) }
func (*ACLChangeACLContentValue) ProtoMessage()    {}
func (*ACLChangeACLContentValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_37a022c841a51877, []int{1, 0}
}
func (m *ACLChangeACLContentValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ACLChangeACLContentValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ACLChangeACLContentValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ACLChangeACLContentValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ACLChangeACLContentValue.Merge(m, src)
}
func (m *ACLChangeACLContentValue) XXX_Size() int {
	return m.Size()
}
func (m *ACLChangeACLContentValue) XXX_DiscardUnknown() {
	xxx_messageInfo_ACLChangeACLContentValue.DiscardUnknown(m)
}

var xxx_messageInfo_ACLChangeACLContentValue proto.InternalMessageInfo

type IsACLChangeACLContentValueValue interface {
	IsACLChangeACLContentValueValue()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ACLChangeACLContentValueValueOfUserAdd struct {
	UserAdd *ACLChangeUserAdd `protobuf:"bytes,1,opt,name=userAdd,proto3,oneof" json:"userAdd,omitempty"`
}
type ACLChangeACLContentValueValueOfUserRemove struct {
	UserRemove *ACLChangeUserRemove `protobuf:"bytes,2,opt,name=userRemove,proto3,oneof" json:"userRemove,omitempty"`
}
type ACLChangeACLContentValueValueOfUserPermissionChange struct {
	UserPermissionChange *ACLChangeUserPermissionChange `protobuf:"bytes,3,opt,name=userPermissionChange,proto3,oneof" json:"userPermissionChange,omitempty"`
}
type ACLChangeACLContentValueValueOfUserInvite struct {
	UserInvite *ACLChangeUserInvite `protobuf:"bytes,4,opt,name=userInvite,proto3,oneof" json:"userInvite,omitempty"`
}
type ACLChangeACLContentValueValueOfUserJoin struct {
	UserJoin *ACLChangeUserJoin `protobuf:"bytes,5,opt,name=userJoin,proto3,oneof" json:"userJoin,omitempty"`
}
type ACLChangeACLContentValueValueOfUserConfirm struct {
	UserConfirm *ACLChangeUserConfirm `protobuf:"bytes,6,opt,name=userConfirm,proto3,oneof" json:"userConfirm,omitempty"`
}

func (*ACLChangeACLContentValueValueOfUserAdd) IsACLChangeACLContentValueValue()              {}
func (*ACLChangeACLContentValueValueOfUserRemove) IsACLChangeACLContentValueValue()           {}
func (*ACLChangeACLContentValueValueOfUserPermissionChange) IsACLChangeACLContentValueValue() {}
func (*ACLChangeACLContentValueValueOfUserInvite) IsACLChangeACLContentValueValue()           {}
func (*ACLChangeACLContentValueValueOfUserJoin) IsACLChangeACLContentValueValue()             {}
func (*ACLChangeACLContentValueValueOfUserConfirm) IsACLChangeACLContentValueValue()          {}

func (m *ACLChangeACLContentValue) GetValue() IsACLChangeACLContentValueValue {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *ACLChangeACLContentValue) GetUserAdd() *ACLChangeUserAdd {
	if x, ok := m.GetValue().(*ACLChangeACLContentValueValueOfUserAdd); ok {
		return x.UserAdd
	}
	return nil
}

func (m *ACLChangeACLContentValue) GetUserRemove() *ACLChangeUserRemove {
	if x, ok := m.GetValue().(*ACLChangeACLContentValueValueOfUserRemove); ok {
		return x.UserRemove
	}
	return nil
}

func (m *ACLChangeACLContentValue) GetUserPermissionChange() *ACLChangeUserPermissionChange {
	if x, ok := m.GetValue().(*ACLChangeACLContentValueValueOfUserPermissionChange); ok {
		return x.UserPermissionChange
	}
	return nil
}

func (m *ACLChangeACLContentValue) GetUserInvite() *ACLChangeUserInvite {
	if x, ok := m.GetValue().(*ACLChangeACLContentValueValueOfUserInvite); ok {
		return x.UserInvite
	}
	return nil
}

func (m *ACLChangeACLContentValue) GetUserJoin() *ACLChangeUserJoin {
	if x, ok := m.GetValue().(*ACLChangeACLContentValueValueOfUserJoin); ok {
		return x.UserJoin
	}
	return nil
}

func (m *ACLChangeACLContentValue) GetUserConfirm() *ACLChangeUserConfirm {
	if x, ok := m.GetValue().(*ACLChangeACLContentValueValueOfUserConfirm); ok {
		return x.UserConfirm
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ACLChangeACLContentValue) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ACLChangeACLContentValueValueOfUserAdd)(nil),
		(*ACLChangeACLContentValueValueOfUserRemove)(nil),
		(*ACLChangeACLContentValueValueOfUserPermissionChange)(nil),
		(*ACLChangeACLContentValueValueOfUserInvite)(nil),
		(*ACLChangeACLContentValueValueOfUserJoin)(nil),
		(*ACLChangeACLContentValueValueOfUserConfirm)(nil),
	}
}

type ACLChangeACLData struct {
	AclSnapshot *ACLChangeACLSnapshot       `protobuf:"bytes,1,opt,name=aclSnapshot,proto3" json:"aclSnapshot,omitempty"`
	AclContent  []*ACLChangeACLContentValue `protobuf:"bytes,2,rep,name=aclContent,proto3" json:"aclContent,omitempty"`
}

func (m *ACLChangeACLData) Reset()         { *m = ACLChangeACLData{} }
func (m *ACLChangeACLData) String() string { return proto.CompactTextString(m) }
func (*ACLChangeACLData) ProtoMessage()    {}
func (*ACLChangeACLData) Descriptor() ([]byte, []int) {
	return fileDescriptor_37a022c841a51877, []int{1, 1}
}
func (m *ACLChangeACLData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ACLChangeACLData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ACLChangeACLData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ACLChangeACLData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ACLChangeACLData.Merge(m, src)
}
func (m *ACLChangeACLData) XXX_Size() int {
	return m.Size()
}
func (m *ACLChangeACLData) XXX_DiscardUnknown() {
	xxx_messageInfo_ACLChangeACLData.DiscardUnknown(m)
}

var xxx_messageInfo_ACLChangeACLData proto.InternalMessageInfo

func (m *ACLChangeACLData) GetAclSnapshot() *ACLChangeACLSnapshot {
	if m != nil {
		return m.AclSnapshot
	}
	return nil
}

func (m *ACLChangeACLData) GetAclContent() []*ACLChangeACLContentValue {
	if m != nil {
		return m.AclContent
	}
	return nil
}

type ACLChangeACLSnapshot struct {
	// We don't need ACLState as a separate message now, because we simplified the snapshot model
	AclState *ACLChangeACLState `protobuf:"bytes,1,opt,name=aclState,proto3" json:"aclState,omitempty"`
}

func (m *ACLChangeACLSnapshot) Reset()         { *m = ACLChangeACLSnapshot{} }
func (m *ACLChangeACLSnapshot) String() string { return proto.CompactTextString(m) }
func (*ACLChangeACLSnapshot) ProtoMessage()    {}
func (*ACLChangeACLSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_37a022c841a51877, []int{1, 2}
}
func (m *ACLChangeACLSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ACLChangeACLSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ACLChangeACLSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ACLChangeACLSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ACLChangeACLSnapshot.Merge(m, src)
}
func (m *ACLChangeACLSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *ACLChangeACLSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_ACLChangeACLSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_ACLChangeACLSnapshot proto.InternalMessageInfo

func (m *ACLChangeACLSnapshot) GetAclState() *ACLChangeACLState {
	if m != nil {
		return m.AclState
	}
	return nil
}

type ACLChangeACLState struct {
	ReadKeyHashes []uint64                        `protobuf:"varint,1,rep,packed,name=readKeyHashes,proto3" json:"readKeyHashes,omitempty"`
	UserStates    []*ACLChangeUserState           `protobuf:"bytes,2,rep,name=userStates,proto3" json:"userStates,omitempty"`
	Invites       map[string]*ACLChangeUserInvite `protobuf:"bytes,3,rep,name=invites,proto3" json:"invites,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ACLChangeACLState) Reset()         { *m = ACLChangeACLState{} }
func (m *ACLChangeACLState) String() string { return proto.CompactTextString(m) }
func (*ACLChangeACLState) ProtoMessage()    {}
func (*ACLChangeACLState) Descriptor() ([]byte, []int) {
	return fileDescriptor_37a022c841a51877, []int{1, 3}
}
func (m *ACLChangeACLState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ACLChangeACLState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ACLChangeACLState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ACLChangeACLState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ACLChangeACLState.Merge(m, src)
}
func (m *ACLChangeACLState) XXX_Size() int {
	return m.Size()
}
func (m *ACLChangeACLState) XXX_DiscardUnknown() {
	xxx_messageInfo_ACLChangeACLState.DiscardUnknown(m)
}

var xxx_messageInfo_ACLChangeACLState proto.InternalMessageInfo

func (m *ACLChangeACLState) GetReadKeyHashes() []uint64 {
	if m != nil {
		return m.ReadKeyHashes
	}
	return nil
}

func (m *ACLChangeACLState) GetUserStates() []*ACLChangeUserState {
	if m != nil {
		return m.UserStates
	}
	return nil
}

func (m *ACLChangeACLState) GetInvites() map[string]*ACLChangeUserInvite {
	if m != nil {
		return m.Invites
	}
	return nil
}

type ACLChangeUserState struct {
	Identity          string                   `protobuf:"bytes,1,opt,name=identity,proto3" json:"identity,omitempty"`
	EncryptionKey     []byte                   `protobuf:"bytes,2,opt,name=encryptionKey,proto3" json:"encryptionKey,omitempty"`
	EncryptedReadKeys [][]byte                 `protobuf:"bytes,3,rep,name=encryptedReadKeys,proto3" json:"encryptedReadKeys,omitempty"`
	Permissions       ACLChangeUserPermissions `protobuf:"varint,4,opt,name=permissions,proto3,enum=acl.ACLChangeUserPermissions" json:"permissions,omitempty"`
	IsConfirmed       bool                     `protobuf:"varint,5,opt,name=IsConfirmed,proto3" json:"IsConfirmed,omitempty"`
}

func (m *ACLChangeUserState) Reset()         { *m = ACLChangeUserState{} }
func (m *ACLChangeUserState) String() string { return proto.CompactTextString(m) }
func (*ACLChangeUserState) ProtoMessage()    {}
func (*ACLChangeUserState) Descriptor() ([]byte, []int) {
	return fileDescriptor_37a022c841a51877, []int{1, 4}
}
func (m *ACLChangeUserState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ACLChangeUserState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ACLChangeUserState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ACLChangeUserState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ACLChangeUserState.Merge(m, src)
}
func (m *ACLChangeUserState) XXX_Size() int {
	return m.Size()
}
func (m *ACLChangeUserState) XXX_DiscardUnknown() {
	xxx_messageInfo_ACLChangeUserState.DiscardUnknown(m)
}

var xxx_messageInfo_ACLChangeUserState proto.InternalMessageInfo

func (m *ACLChangeUserState) GetIdentity() string {
	if m != nil {
		return m.Identity
	}
	return ""
}

func (m *ACLChangeUserState) GetEncryptionKey() []byte {
	if m != nil {
		return m.EncryptionKey
	}
	return nil
}

func (m *ACLChangeUserState) GetEncryptedReadKeys() [][]byte {
	if m != nil {
		return m.EncryptedReadKeys
	}
	return nil
}

func (m *ACLChangeUserState) GetPermissions() ACLChangeUserPermissions {
	if m != nil {
		return m.Permissions
	}
	return ACLChange_Admin
}

func (m *ACLChangeUserState) GetIsConfirmed() bool {
	if m != nil {
		return m.IsConfirmed
	}
	return false
}

// we already know identity and encryptionKey
type ACLChangeUserAdd struct {
	Identity          string                   `protobuf:"bytes,1,opt,name=identity,proto3" json:"identity,omitempty"`
	EncryptionKey     []byte                   `protobuf:"bytes,2,opt,name=encryptionKey,proto3" json:"encryptionKey,omitempty"`
	EncryptedReadKeys [][]byte                 `protobuf:"bytes,3,rep,name=encryptedReadKeys,proto3" json:"encryptedReadKeys,omitempty"`
	Permissions       ACLChangeUserPermissions `protobuf:"varint,4,opt,name=permissions,proto3,enum=acl.ACLChangeUserPermissions" json:"permissions,omitempty"`
}

func (m *ACLChangeUserAdd) Reset()         { *m = ACLChangeUserAdd{} }
func (m *ACLChangeUserAdd) String() string { return proto.CompactTextString(m) }
func (*ACLChangeUserAdd) ProtoMessage()    {}
func (*ACLChangeUserAdd) Descriptor() ([]byte, []int) {
	return fileDescriptor_37a022c841a51877, []int{1, 5}
}
func (m *ACLChangeUserAdd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ACLChangeUserAdd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ACLChangeUserAdd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ACLChangeUserAdd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ACLChangeUserAdd.Merge(m, src)
}
func (m *ACLChangeUserAdd) XXX_Size() int {
	return m.Size()
}
func (m *ACLChangeUserAdd) XXX_DiscardUnknown() {
	xxx_messageInfo_ACLChangeUserAdd.DiscardUnknown(m)
}

var xxx_messageInfo_ACLChangeUserAdd proto.InternalMessageInfo

func (m *ACLChangeUserAdd) GetIdentity() string {
	if m != nil {
		return m.Identity
	}
	return ""
}

func (m *ACLChangeUserAdd) GetEncryptionKey() []byte {
	if m != nil {
		return m.EncryptionKey
	}
	return nil
}

func (m *ACLChangeUserAdd) GetEncryptedReadKeys() [][]byte {
	if m != nil {
		return m.EncryptedReadKeys
	}
	return nil
}

func (m *ACLChangeUserAdd) GetPermissions() ACLChangeUserPermissions {
	if m != nil {
		return m.Permissions
	}
	return ACLChange_Admin
}

// TODO: this is not used as of now
type ACLChangeUserConfirm struct {
	Identity  string `protobuf:"bytes,1,opt,name=identity,proto3" json:"identity,omitempty"`
	UserAddId string `protobuf:"bytes,2,opt,name=userAddId,proto3" json:"userAddId,omitempty"`
}

func (m *ACLChangeUserConfirm) Reset()         { *m = ACLChangeUserConfirm{} }
func (m *ACLChangeUserConfirm) String() string { return proto.CompactTextString(m) }
func (*ACLChangeUserConfirm) ProtoMessage()    {}
func (*ACLChangeUserConfirm) Descriptor() ([]byte, []int) {
	return fileDescriptor_37a022c841a51877, []int{1, 6}
}
func (m *ACLChangeUserConfirm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ACLChangeUserConfirm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ACLChangeUserConfirm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ACLChangeUserConfirm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ACLChangeUserConfirm.Merge(m, src)
}
func (m *ACLChangeUserConfirm) XXX_Size() int {
	return m.Size()
}
func (m *ACLChangeUserConfirm) XXX_DiscardUnknown() {
	xxx_messageInfo_ACLChangeUserConfirm.DiscardUnknown(m)
}

var xxx_messageInfo_ACLChangeUserConfirm proto.InternalMessageInfo

func (m *ACLChangeUserConfirm) GetIdentity() string {
	if m != nil {
		return m.Identity
	}
	return ""
}

func (m *ACLChangeUserConfirm) GetUserAddId() string {
	if m != nil {
		return m.UserAddId
	}
	return ""
}

type ACLChangeUserInvite struct {
	AcceptPublicKey   []byte                   `protobuf:"bytes,1,opt,name=acceptPublicKey,proto3" json:"acceptPublicKey,omitempty"`
	EncryptPublicKey  []byte                   `protobuf:"bytes,2,opt,name=encryptPublicKey,proto3" json:"encryptPublicKey,omitempty"`
	EncryptedReadKeys [][]byte                 `protobuf:"bytes,3,rep,name=encryptedReadKeys,proto3" json:"encryptedReadKeys,omitempty"`
	Permissions       ACLChangeUserPermissions `protobuf:"varint,4,opt,name=permissions,proto3,enum=acl.ACLChangeUserPermissions" json:"permissions,omitempty"`
	InviteId          string                   `protobuf:"bytes,5,opt,name=InviteId,proto3" json:"InviteId,omitempty"`
}

func (m *ACLChangeUserInvite) Reset()         { *m = ACLChangeUserInvite{} }
func (m *ACLChangeUserInvite) String() string { return proto.CompactTextString(m) }
func (*ACLChangeUserInvite) ProtoMessage()    {}
func (*ACLChangeUserInvite) Descriptor() ([]byte, []int) {
	return fileDescriptor_37a022c841a51877, []int{1, 7}
}
func (m *ACLChangeUserInvite) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ACLChangeUserInvite) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ACLChangeUserInvite.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ACLChangeUserInvite) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ACLChangeUserInvite.Merge(m, src)
}
func (m *ACLChangeUserInvite) XXX_Size() int {
	return m.Size()
}
func (m *ACLChangeUserInvite) XXX_DiscardUnknown() {
	xxx_messageInfo_ACLChangeUserInvite.DiscardUnknown(m)
}

var xxx_messageInfo_ACLChangeUserInvite proto.InternalMessageInfo

func (m *ACLChangeUserInvite) GetAcceptPublicKey() []byte {
	if m != nil {
		return m.AcceptPublicKey
	}
	return nil
}

func (m *ACLChangeUserInvite) GetEncryptPublicKey() []byte {
	if m != nil {
		return m.EncryptPublicKey
	}
	return nil
}

func (m *ACLChangeUserInvite) GetEncryptedReadKeys() [][]byte {
	if m != nil {
		return m.EncryptedReadKeys
	}
	return nil
}

func (m *ACLChangeUserInvite) GetPermissions() ACLChangeUserPermissions {
	if m != nil {
		return m.Permissions
	}
	return ACLChange_Admin
}

func (m *ACLChangeUserInvite) GetInviteId() string {
	if m != nil {
		return m.InviteId
	}
	return ""
}

type ACLChangeUserJoin struct {
	Identity          string   `protobuf:"bytes,1,opt,name=identity,proto3" json:"identity,omitempty"`
	EncryptionKey     []byte   `protobuf:"bytes,2,opt,name=encryptionKey,proto3" json:"encryptionKey,omitempty"`
	AcceptSignature   []byte   `protobuf:"bytes,3,opt,name=acceptSignature,proto3" json:"acceptSignature,omitempty"`
	UserInviteId      string   `protobuf:"bytes,4,opt,name=userInviteId,proto3" json:"userInviteId,omitempty"`
	EncryptedReadKeys [][]byte `protobuf:"bytes,5,rep,name=encryptedReadKeys,proto3" json:"encryptedReadKeys,omitempty"`
}

func (m *ACLChangeUserJoin) Reset()         { *m = ACLChangeUserJoin{} }
func (m *ACLChangeUserJoin) String() string { return proto.CompactTextString(m) }
func (*ACLChangeUserJoin) ProtoMessage()    {}
func (*ACLChangeUserJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_37a022c841a51877, []int{1, 8}
}
func (m *ACLChangeUserJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ACLChangeUserJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ACLChangeUserJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ACLChangeUserJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ACLChangeUserJoin.Merge(m, src)
}
func (m *ACLChangeUserJoin) XXX_Size() int {
	return m.Size()
}
func (m *ACLChangeUserJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_ACLChangeUserJoin.DiscardUnknown(m)
}

var xxx_messageInfo_ACLChangeUserJoin proto.InternalMessageInfo

func (m *ACLChangeUserJoin) GetIdentity() string {
	if m != nil {
		return m.Identity
	}
	return ""
}

func (m *ACLChangeUserJoin) GetEncryptionKey() []byte {
	if m != nil {
		return m.EncryptionKey
	}
	return nil
}

func (m *ACLChangeUserJoin) GetAcceptSignature() []byte {
	if m != nil {
		return m.AcceptSignature
	}
	return nil
}

func (m *ACLChangeUserJoin) GetUserInviteId() string {
	if m != nil {
		return m.UserInviteId
	}
	return ""
}

func (m *ACLChangeUserJoin) GetEncryptedReadKeys() [][]byte {
	if m != nil {
		return m.EncryptedReadKeys
	}
	return nil
}

type ACLChangeUserRemove struct {
	Identity        string                     `protobuf:"bytes,1,opt,name=identity,proto3" json:"identity,omitempty"`
	ReadKeyReplaces []*ACLChangeReadKeyReplace `protobuf:"bytes,3,rep,name=readKeyReplaces,proto3" json:"readKeyReplaces,omitempty"`
}

func (m *ACLChangeUserRemove) Reset()         { *m = ACLChangeUserRemove{} }
func (m *ACLChangeUserRemove) String() string { return proto.CompactTextString(m) }
func (*ACLChangeUserRemove) ProtoMessage()    {}
func (*ACLChangeUserRemove) Descriptor() ([]byte, []int) {
	return fileDescriptor_37a022c841a51877, []int{1, 9}
}
func (m *ACLChangeUserRemove) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ACLChangeUserRemove) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ACLChangeUserRemove.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ACLChangeUserRemove) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ACLChangeUserRemove.Merge(m, src)
}
func (m *ACLChangeUserRemove) XXX_Size() int {
	return m.Size()
}
func (m *ACLChangeUserRemove) XXX_DiscardUnknown() {
	xxx_messageInfo_ACLChangeUserRemove.DiscardUnknown(m)
}

var xxx_messageInfo_ACLChangeUserRemove proto.InternalMessageInfo

func (m *ACLChangeUserRemove) GetIdentity() string {
	if m != nil {
		return m.Identity
	}
	return ""
}

func (m *ACLChangeUserRemove) GetReadKeyReplaces() []*ACLChangeReadKeyReplace {
	if m != nil {
		return m.ReadKeyReplaces
	}
	return nil
}

type ACLChangeReadKeyReplace struct {
	Identity         string `protobuf:"bytes,1,opt,name=identity,proto3" json:"identity,omitempty"`
	EncryptionKey    []byte `protobuf:"bytes,2,opt,name=encryptionKey,proto3" json:"encryptionKey,omitempty"`
	EncryptedReadKey []byte `protobuf:"bytes,3,opt,name=encryptedReadKey,proto3" json:"encryptedReadKey,omitempty"`
}

func (m *ACLChangeReadKeyReplace) Reset()         { *m = ACLChangeReadKeyReplace{} }
func (m *ACLChangeReadKeyReplace) String() string { return proto.CompactTextString(m) }
func (*ACLChangeReadKeyReplace) ProtoMessage()    {}
func (*ACLChangeReadKeyReplace) Descriptor() ([]byte, []int) {
	return fileDescriptor_37a022c841a51877, []int{1, 10}
}
func (m *ACLChangeReadKeyReplace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ACLChangeReadKeyReplace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ACLChangeReadKeyReplace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ACLChangeReadKeyReplace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ACLChangeReadKeyReplace.Merge(m, src)
}
func (m *ACLChangeReadKeyReplace) XXX_Size() int {
	return m.Size()
}
func (m *ACLChangeReadKeyReplace) XXX_DiscardUnknown() {
	xxx_messageInfo_ACLChangeReadKeyReplace.DiscardUnknown(m)
}

var xxx_messageInfo_ACLChangeReadKeyReplace proto.InternalMessageInfo

func (m *ACLChangeReadKeyReplace) GetIdentity() string {
	if m != nil {
		return m.Identity
	}
	return ""
}

func (m *ACLChangeReadKeyReplace) GetEncryptionKey() []byte {
	if m != nil {
		return m.EncryptionKey
	}
	return nil
}

func (m *ACLChangeReadKeyReplace) GetEncryptedReadKey() []byte {
	if m != nil {
		return m.EncryptedReadKey
	}
	return nil
}

type ACLChangeUserPermissionChange struct {
	Identity    string                   `protobuf:"bytes,1,opt,name=identity,proto3" json:"identity,omitempty"`
	Permissions ACLChangeUserPermissions `protobuf:"varint,2,opt,name=permissions,proto3,enum=acl.ACLChangeUserPermissions" json:"permissions,omitempty"`
}

func (m *ACLChangeUserPermissionChange) Reset()         { *m = ACLChangeUserPermissionChange{} }
func (m *ACLChangeUserPermissionChange) String() string { return proto.CompactTextString(m) }
func (*ACLChangeUserPermissionChange) ProtoMessage()    {}
func (*ACLChangeUserPermissionChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_37a022c841a51877, []int{1, 11}
}
func (m *ACLChangeUserPermissionChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ACLChangeUserPermissionChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ACLChangeUserPermissionChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ACLChangeUserPermissionChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ACLChangeUserPermissionChange.Merge(m, src)
}
func (m *ACLChangeUserPermissionChange) XXX_Size() int {
	return m.Size()
}
func (m *ACLChangeUserPermissionChange) XXX_DiscardUnknown() {
	xxx_messageInfo_ACLChangeUserPermissionChange.DiscardUnknown(m)
}

var xxx_messageInfo_ACLChangeUserPermissionChange proto.InternalMessageInfo

func (m *ACLChangeUserPermissionChange) GetIdentity() string {
	if m != nil {
		return m.Identity
	}
	return ""
}

func (m *ACLChangeUserPermissionChange) GetPermissions() ACLChangeUserPermissions {
	if m != nil {
		return m.Permissions
	}
	return ACLChange_Admin
}

type Change struct {
	TreeHeadIds        []string `protobuf:"bytes,1,rep,name=treeHeadIds,proto3" json:"treeHeadIds,omitempty"`
	AclHeadIds         []string `protobuf:"bytes,2,rep,name=aclHeadIds,proto3" json:"aclHeadIds,omitempty"`
	SnapshotBaseId     string   `protobuf:"bytes,3,opt,name=snapshotBaseId,proto3" json:"snapshotBaseId,omitempty"`
	ChangesData        []byte   `protobuf:"bytes,4,opt,name=changesData,proto3" json:"changesData,omitempty"`
	CurrentReadKeyHash uint64   `protobuf:"varint,5,opt,name=currentReadKeyHash,proto3" json:"currentReadKeyHash,omitempty"`
	Timestamp          int64    `protobuf:"varint,6,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Identity           string   `protobuf:"bytes,7,opt,name=identity,proto3" json:"identity,omitempty"`
	IsSnapshot         bool     `protobuf:"varint,8,opt,name=isSnapshot,proto3" json:"isSnapshot,omitempty"`
}

func (m *Change) Reset()         { *m = Change{} }
func (m *Change) String() string { return proto.CompactTextString(m) }
func (*Change) ProtoMessage()    {}
func (*Change) Descriptor() ([]byte, []int) {
	return fileDescriptor_37a022c841a51877, []int{2}
}
func (m *Change) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Change) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Change.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Change) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Change.Merge(m, src)
}
func (m *Change) XXX_Size() int {
	return m.Size()
}
func (m *Change) XXX_DiscardUnknown() {
	xxx_messageInfo_Change.DiscardUnknown(m)
}

var xxx_messageInfo_Change proto.InternalMessageInfo

func (m *Change) GetTreeHeadIds() []string {
	if m != nil {
		return m.TreeHeadIds
	}
	return nil
}

func (m *Change) GetAclHeadIds() []string {
	if m != nil {
		return m.AclHeadIds
	}
	return nil
}

func (m *Change) GetSnapshotBaseId() string {
	if m != nil {
		return m.SnapshotBaseId
	}
	return ""
}

func (m *Change) GetChangesData() []byte {
	if m != nil {
		return m.ChangesData
	}
	return nil
}

func (m *Change) GetCurrentReadKeyHash() uint64 {
	if m != nil {
		return m.CurrentReadKeyHash
	}
	return 0
}

func (m *Change) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Change) GetIdentity() string {
	if m != nil {
		return m.Identity
	}
	return ""
}

func (m *Change) GetIsSnapshot() bool {
	if m != nil {
		return m.IsSnapshot
	}
	return false
}

func init() {
	proto.RegisterEnum("acl.ACLChangeUserPermissions", ACLChangeUserPermissions_name, ACLChangeUserPermissions_value)
	proto.RegisterType((*RawChange)(nil), "acl.RawChange")
	proto.RegisterType((*ACLChange)(nil), "acl.ACLChange")
	proto.RegisterType((*ACLChangeACLContentValue)(nil), "acl.ACLChange.ACLContentValue")
	proto.RegisterType((*ACLChangeACLData)(nil), "acl.ACLChange.ACLData")
	proto.RegisterType((*ACLChangeACLSnapshot)(nil), "acl.ACLChange.ACLSnapshot")
	proto.RegisterType((*ACLChangeACLState)(nil), "acl.ACLChange.ACLState")
	proto.RegisterMapType((map[string]*ACLChangeUserInvite)(nil), "acl.ACLChange.ACLState.InvitesEntry")
	proto.RegisterType((*ACLChangeUserState)(nil), "acl.ACLChange.UserState")
	proto.RegisterType((*ACLChangeUserAdd)(nil), "acl.ACLChange.UserAdd")
	proto.RegisterType((*ACLChangeUserConfirm)(nil), "acl.ACLChange.UserConfirm")
	proto.RegisterType((*ACLChangeUserInvite)(nil), "acl.ACLChange.UserInvite")
	proto.RegisterType((*ACLChangeUserJoin)(nil), "acl.ACLChange.UserJoin")
	proto.RegisterType((*ACLChangeUserRemove)(nil), "acl.ACLChange.UserRemove")
	proto.RegisterType((*ACLChangeReadKeyReplace)(nil), "acl.ACLChange.ReadKeyReplace")
	proto.RegisterType((*ACLChangeUserPermissionChange)(nil), "acl.ACLChange.UserPermissionChange")
	proto.RegisterType((*Change)(nil), "acl.Change")
}

func init() {
	proto.RegisterFile("pkg/acl/aclchanges/aclpb/protos/aclchanges.proto", fileDescriptor_37a022c841a51877)
}

var fileDescriptor_37a022c841a51877 = []byte{
	// 987 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x56, 0x4f, 0x8f, 0xdb, 0x44,
	0x14, 0xcf, 0x24, 0x9b, 0x75, 0xfc, 0x1c, 0x76, 0xc3, 0x50, 0x51, 0x63, 0x95, 0x10, 0x85, 0x0a,
	0x45, 0x08, 0x65, 0xab, 0x54, 0x48, 0x15, 0xa0, 0x15, 0xbb, 0x0b, 0x6a, 0xc2, 0x72, 0xa8, 0x66,
	0x55, 0x10, 0xdc, 0x66, 0xed, 0x61, 0xd7, 0xaa, 0x63, 0x1b, 0xcf, 0x64, 0x51, 0x2e, 0x48, 0x9c,
	0xb8, 0x72, 0xe6, 0xc0, 0x17, 0xe1, 0x0b, 0xf4, 0xd8, 0x23, 0x37, 0xd0, 0xee, 0x9d, 0x0b, 0x5f,
	0x00, 0xcd, 0x1f, 0x3b, 0x8e, 0xe3, 0x46, 0x45, 0xaa, 0x2a, 0x71, 0x88, 0x34, 0xf3, 0x7b, 0xbf,
	0x37, 0x79, 0xef, 0xfd, 0xde, 0x3c, 0x0f, 0xdc, 0x4b, 0x9f, 0x5c, 0x1c, 0x50, 0x3f, 0x92, 0x3f,
	0xff, 0x92, 0xc6, 0x17, 0x8c, 0xcb, 0x65, 0x7a, 0x7e, 0x90, 0x66, 0x89, 0x48, 0x78, 0x09, 0x1f,
	0x2b, 0x04, 0xb7, 0xa8, 0x1f, 0x0d, 0xcf, 0xc0, 0x26, 0xf4, 0x87, 0x13, 0x65, 0xc0, 0x2e, 0x58,
	0x29, 0x5d, 0x46, 0x09, 0x0d, 0x5c, 0x34, 0x40, 0xa3, 0x2e, 0xc9, 0xb7, 0xf8, 0x0e, 0xd8, 0x3c,
	0xbc, 0x88, 0xa9, 0x58, 0x64, 0xcc, 0x6d, 0x2a, 0xdb, 0x0a, 0xc0, 0x7b, 0xd0, 0x0c, 0x03, 0xb7,
	0x35, 0x40, 0x23, 0x9b, 0x34, 0xc3, 0x60, 0xf8, 0xcf, 0x1b, 0x60, 0x1f, 0x9d, 0x7c, 0x69, 0x4e,
	0x1d, 0x80, 0x23, 0x32, 0xc6, 0xa6, 0x8c, 0x06, 0xb3, 0x80, 0xbb, 0x68, 0xd0, 0x1a, 0xd9, 0xa4,
	0x0c, 0xe1, 0x3e, 0x00, 0xf5, 0xa3, 0x9c, 0xd0, 0x54, 0x84, 0x12, 0x82, 0xdf, 0x83, 0x3d, 0x1e,
	0xd3, 0x94, 0x5f, 0x26, 0xe2, 0x98, 0x72, 0x36, 0xcb, 0xff, 0xab, 0x82, 0xe2, 0x7b, 0x60, 0x51,
	0x3f, 0xfa, 0x8c, 0x0a, 0xea, 0xee, 0x0c, 0xd0, 0xc8, 0x99, 0xbc, 0x39, 0xa6, 0x7e, 0x34, 0x2e,
	0x42, 0x91, 0x2b, 0x69, 0x25, 0x39, 0x4d, 0xc6, 0x66, 0x8a, 0xa2, 0xbc, 0xda, 0x2a, 0xb3, 0x32,
	0x84, 0xc7, 0x80, 0xfd, 0x45, 0x96, 0xb1, 0x58, 0x10, 0x46, 0x83, 0x53, 0xb6, 0x9c, 0x52, 0x7e,
	0xe9, 0xee, 0x0e, 0xd0, 0x68, 0x87, 0xd4, 0x58, 0x64, 0xa5, 0x44, 0x38, 0x67, 0x5c, 0xd0, 0x79,
	0xea, 0x5a, 0x03, 0x34, 0x6a, 0x91, 0x15, 0x80, 0x3d, 0xe8, 0x84, 0x01, 0x8b, 0x45, 0x28, 0x96,
	0x6e, 0x47, 0xe5, 0x50, 0xec, 0xbd, 0x5f, 0x5b, 0xb0, 0x2f, 0x43, 0x4d, 0x62, 0xc1, 0x62, 0xf1,
	0x15, 0x8d, 0x16, 0x0c, 0x4f, 0xc0, 0x5a, 0x70, 0x96, 0x1d, 0x05, 0x5a, 0x91, 0xcd, 0x8c, 0x1e,
	0x6b, 0xeb, 0xb4, 0x41, 0x72, 0x22, 0xfe, 0x18, 0x40, 0x2e, 0x09, 0x9b, 0x27, 0x57, 0x5a, 0x2c,
	0x67, 0xf2, 0x56, 0x8d, 0x9b, 0x26, 0x4c, 0x1b, 0xa4, 0x44, 0xc7, 0xdf, 0xc0, 0x2d, 0xb9, 0x7b,
	0xc4, 0xb2, 0x79, 0xc8, 0x79, 0x98, 0xc4, 0xda, 0x41, 0x15, 0xdc, 0x99, 0xbc, 0x5b, 0x73, 0x4c,
	0x95, 0x3a, 0x6d, 0x90, 0xda, 0x23, 0xf2, 0xb8, 0x66, 0xf1, 0x55, 0x28, 0x98, 0x11, 0xa8, 0x2e,
	0x2e, 0x4d, 0xc8, 0xe3, 0xd2, 0x3b, 0xfc, 0x21, 0x74, 0xe4, 0xee, 0x8b, 0x24, 0x8c, 0x95, 0x4a,
	0xce, 0xe4, 0x76, 0x8d, 0xab, 0x34, 0x4f, 0x1b, 0xa4, 0xa0, 0xe2, 0x43, 0x70, 0xe4, 0xfa, 0x24,
	0x89, 0xbf, 0x0b, 0xb3, 0xb9, 0x92, 0xcd, 0x99, 0x78, 0x35, 0x9e, 0x86, 0x31, 0x6d, 0x90, 0xb2,
	0xc3, 0xb1, 0x05, 0xed, 0x2b, 0x29, 0x84, 0xf7, 0x33, 0x02, 0xcb, 0x74, 0x0f, 0xfe, 0x04, 0x1c,
	0xea, 0x47, 0x67, 0xa6, 0xf7, 0x8c, 0x30, 0xde, 0x66, 0xab, 0xe5, 0x0c, 0x52, 0xa6, 0xe3, 0x43,
	0xd5, 0xec, 0x46, 0x65, 0xd5, 0xec, 0xce, 0xa4, 0xbf, 0xe9, 0x5c, 0x6e, 0x03, 0x52, 0xf2, 0xf0,
	0x8e, 0xc1, 0x29, 0x9d, 0x8d, 0xef, 0x43, 0x47, 0x9e, 0x2e, 0xa8, 0x60, 0x26, 0x92, 0xdb, 0x35,
	0x91, 0x48, 0x33, 0x29, 0x88, 0xde, 0x4f, 0x4d, 0xe8, 0xe4, 0x30, 0xbe, 0x0b, 0xaf, 0x65, 0xab,
	0x06, 0x66, 0xfa, 0x86, 0xee, 0x90, 0x75, 0x10, 0x3f, 0xd0, 0xea, 0x29, 0x17, 0x6e, 0xc2, 0x76,
	0x6b, 0x0a, 0xa9, 0xff, 0xaa, 0xc4, 0xc5, 0x87, 0x60, 0x85, 0x4a, 0x44, 0xee, 0xb6, 0x94, 0xdb,
	0xdd, 0xe7, 0x04, 0x38, 0xd6, 0x5a, 0xf3, 0xcf, 0x63, 0x91, 0x2d, 0x49, 0xee, 0xe4, 0x3d, 0x86,
	0x6e, 0xd9, 0x80, 0x7b, 0xd0, 0x7a, 0xc2, 0x96, 0x2a, 0x59, 0x9b, 0xc8, 0x25, 0x3e, 0x30, 0x2a,
	0x6d, 0x69, 0x76, 0x7d, 0x02, 0xd1, 0xbc, 0x8f, 0x9a, 0x0f, 0x90, 0xf7, 0x27, 0x02, 0xbb, 0x08,
	0x78, 0xed, 0x62, 0xa2, 0xf5, 0x8b, 0x29, 0x0b, 0xc4, 0x62, 0x3f, 0x5b, 0xa6, 0x22, 0x4c, 0xe2,
	0x53, 0xb6, 0x34, 0x03, 0x70, 0x1d, 0xc4, 0x1f, 0xc0, 0xeb, 0x06, 0x60, 0x81, 0x19, 0x08, 0x3a,
	0xe1, 0x2e, 0xd9, 0x34, 0xe0, 0x4f, 0xc1, 0x49, 0x8b, 0x0b, 0xc2, 0xd5, 0x6d, 0xd8, 0xdb, 0x68,
	0x83, 0xf5, 0xeb, 0xc5, 0x49, 0xd9, 0x45, 0x8e, 0xae, 0x19, 0x37, 0x7d, 0xca, 0x02, 0x75, 0x29,
	0x3a, 0xa4, 0x0c, 0x79, 0xbf, 0x23, 0xb0, 0xcc, 0x7c, 0xf8, 0xff, 0xe5, 0xe7, 0x3d, 0x04, 0xa7,
	0x74, 0x31, 0xb7, 0x26, 0x70, 0x07, 0x6c, 0x33, 0xfc, 0x66, 0x81, 0x0a, 0xde, 0x26, 0x2b, 0xc0,
	0xfb, 0x1b, 0x01, 0xac, 0x5a, 0x00, 0x8f, 0x60, 0x9f, 0xfa, 0x3e, 0x4b, 0xc5, 0xa3, 0xc5, 0x79,
	0x14, 0xfa, 0xa7, 0xa6, 0x95, 0xba, 0xa4, 0x0a, 0xe3, 0xf7, 0xa1, 0x67, 0x12, 0x5b, 0x51, 0x75,
	0x69, 0x36, 0xf0, 0x57, 0xae, 0xbe, 0x07, 0x1d, 0x9d, 0xcf, 0x4c, 0x4b, 0x6f, 0x93, 0x62, 0xef,
	0x3d, 0x45, 0xd0, 0xc9, 0xa7, 0xe1, 0x4b, 0x10, 0xbe, 0x28, 0xd8, 0x59, 0xf1, 0x02, 0x68, 0x95,
	0x0b, 0x56, 0xc0, 0x78, 0x08, 0xdd, 0xd5, 0xc8, 0x9e, 0x05, 0x2a, 0x2f, 0x9b, 0xac, 0x61, 0xf5,
	0x85, 0x6a, 0x3f, 0xa7, 0x50, 0xde, 0xf7, 0x5a, 0x3a, 0xf3, 0x71, 0xda, 0x96, 0xcb, 0x43, 0xd8,
	0x37, 0x03, 0x8b, 0xb0, 0x34, 0xa2, 0x7e, 0x31, 0x6d, 0xde, 0xae, 0x94, 0x95, 0xac, 0xb1, 0x48,
	0xd5, 0xcb, 0xfb, 0x11, 0xf6, 0xd6, 0x29, 0x2f, 0xa1, 0x84, 0xab, 0x4e, 0x2a, 0x72, 0x33, 0x35,
	0xdc, 0xc0, 0x3d, 0x01, 0xb7, 0xea, 0x3e, 0xab, 0x5b, 0xa3, 0xa8, 0xf4, 0x53, 0xf3, 0x3f, 0xf7,
	0xd3, 0xf0, 0x08, 0xf6, 0x2b, 0x76, 0x6c, 0x43, 0xfb, 0x28, 0x98, 0x87, 0x71, 0xaf, 0x81, 0x01,
	0x76, 0xbf, 0xce, 0x42, 0xc1, 0xb2, 0x1e, 0x92, 0x6b, 0x19, 0x2a, 0xcb, 0x7a, 0x4d, 0xec, 0x80,
	0xa5, 0xa5, 0x09, 0x7a, 0xad, 0xe1, 0x6f, 0x4d, 0xd8, 0x7d, 0xe5, 0x4f, 0xbe, 0xca, 0x03, 0x6e,
	0xe7, 0x45, 0x1f, 0x70, 0xed, 0x17, 0x7b, 0xc0, 0xed, 0x6e, 0x7b, 0xc0, 0x59, 0x15, 0x15, 0xfa,
	0x00, 0x21, 0x2f, 0x9e, 0x05, 0x1d, 0x35, 0x90, 0x4b, 0xc8, 0xf1, 0x3b, 0x4f, 0xaf, 0xfb, 0xe8,
	0xd9, 0x75, 0x1f, 0xfd, 0x75, 0xdd, 0x47, 0xbf, 0xdc, 0xf4, 0x1b, 0xcf, 0x6e, 0xfa, 0x8d, 0x3f,
	0x6e, 0xfa, 0x8d, 0x6f, 0xdb, 0xea, 0xa5, 0x7e, 0xbe, 0xab, 0x1e, 0xe6, 0xf7, 0xff, 0x0d, 0x00,
	0x00, 0xff, 0xff, 0xf9, 0xfe, 0x4f, 0x12, 0xcc, 0x0b, 0x00, 0x00,
}

func (m *RawChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintAclchanges(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintAclchanges(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintAclchanges(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ACLChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ACLChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ACLChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintAclchanges(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0x42
	}
	if m.Timestamp != 0 {
		i = encodeVarintAclchanges(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x38
	}
	if m.CurrentReadKeyHash != 0 {
		i = encodeVarintAclchanges(dAtA, i, uint64(m.CurrentReadKeyHash))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ChangesData) > 0 {
		i -= len(m.ChangesData)
		copy(dAtA[i:], m.ChangesData)
		i = encodeVarintAclchanges(dAtA, i, uint64(len(m.ChangesData)))
		i--
		dAtA[i] = 0x2a
	}
	if m.AclData != nil {
		{
			size, err := m.AclData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAclchanges(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.SnapshotBaseId) > 0 {
		i -= len(m.SnapshotBaseId)
		copy(dAtA[i:], m.SnapshotBaseId)
		i = encodeVarintAclchanges(dAtA, i, uint64(len(m.SnapshotBaseId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AclHeadIds) > 0 {
		for iNdEx := len(m.AclHeadIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AclHeadIds[iNdEx])
			copy(dAtA[i:], m.AclHeadIds[iNdEx])
			i = encodeVarintAclchanges(dAtA, i, uint64(len(m.AclHeadIds[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.TreeHeadIds) > 0 {
		for iNdEx := len(m.TreeHeadIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TreeHeadIds[iNdEx])
			copy(dAtA[i:], m.TreeHeadIds[iNdEx])
			i = encodeVarintAclchanges(dAtA, i, uint64(len(m.TreeHeadIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ACLChangeACLContentValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ACLChangeACLContentValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ACLChangeACLContentValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ACLChangeACLContentValueValueOfUserAdd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ACLChangeACLContentValueValueOfUserAdd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UserAdd != nil {
		{
			size, err := m.UserAdd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAclchanges(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ACLChangeACLContentValueValueOfUserRemove) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ACLChangeACLContentValueValueOfUserRemove) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UserRemove != nil {
		{
			size, err := m.UserRemove.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAclchanges(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ACLChangeACLContentValueValueOfUserPermissionChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ACLChangeACLContentValueValueOfUserPermissionChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UserPermissionChange != nil {
		{
			size, err := m.UserPermissionChange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAclchanges(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ACLChangeACLContentValueValueOfUserInvite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ACLChangeACLContentValueValueOfUserInvite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UserInvite != nil {
		{
			size, err := m.UserInvite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAclchanges(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ACLChangeACLContentValueValueOfUserJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ACLChangeACLContentValueValueOfUserJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UserJoin != nil {
		{
			size, err := m.UserJoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAclchanges(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ACLChangeACLContentValueValueOfUserConfirm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ACLChangeACLContentValueValueOfUserConfirm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UserConfirm != nil {
		{
			size, err := m.UserConfirm.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAclchanges(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *ACLChangeACLData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ACLChangeACLData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ACLChangeACLData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AclContent) > 0 {
		for iNdEx := len(m.AclContent) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AclContent[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAclchanges(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.AclSnapshot != nil {
		{
			size, err := m.AclSnapshot.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAclchanges(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ACLChangeACLSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ACLChangeACLSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ACLChangeACLSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AclState != nil {
		{
			size, err := m.AclState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAclchanges(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ACLChangeACLState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ACLChangeACLState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ACLChangeACLState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Invites) > 0 {
		for k := range m.Invites {
			v := m.Invites[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintAclchanges(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAclchanges(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAclchanges(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.UserStates) > 0 {
		for iNdEx := len(m.UserStates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserStates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAclchanges(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ReadKeyHashes) > 0 {
		dAtA12 := make([]byte, len(m.ReadKeyHashes)*10)
		var j11 int
		for _, num := range m.ReadKeyHashes {
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintAclchanges(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ACLChangeUserState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ACLChangeUserState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ACLChangeUserState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsConfirmed {
		i--
		if m.IsConfirmed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Permissions != 0 {
		i = encodeVarintAclchanges(dAtA, i, uint64(m.Permissions))
		i--
		dAtA[i] = 0x20
	}
	if len(m.EncryptedReadKeys) > 0 {
		for iNdEx := len(m.EncryptedReadKeys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EncryptedReadKeys[iNdEx])
			copy(dAtA[i:], m.EncryptedReadKeys[iNdEx])
			i = encodeVarintAclchanges(dAtA, i, uint64(len(m.EncryptedReadKeys[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.EncryptionKey) > 0 {
		i -= len(m.EncryptionKey)
		copy(dAtA[i:], m.EncryptionKey)
		i = encodeVarintAclchanges(dAtA, i, uint64(len(m.EncryptionKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintAclchanges(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ACLChangeUserAdd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ACLChangeUserAdd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ACLChangeUserAdd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Permissions != 0 {
		i = encodeVarintAclchanges(dAtA, i, uint64(m.Permissions))
		i--
		dAtA[i] = 0x20
	}
	if len(m.EncryptedReadKeys) > 0 {
		for iNdEx := len(m.EncryptedReadKeys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EncryptedReadKeys[iNdEx])
			copy(dAtA[i:], m.EncryptedReadKeys[iNdEx])
			i = encodeVarintAclchanges(dAtA, i, uint64(len(m.EncryptedReadKeys[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.EncryptionKey) > 0 {
		i -= len(m.EncryptionKey)
		copy(dAtA[i:], m.EncryptionKey)
		i = encodeVarintAclchanges(dAtA, i, uint64(len(m.EncryptionKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintAclchanges(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ACLChangeUserConfirm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ACLChangeUserConfirm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ACLChangeUserConfirm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UserAddId) > 0 {
		i -= len(m.UserAddId)
		copy(dAtA[i:], m.UserAddId)
		i = encodeVarintAclchanges(dAtA, i, uint64(len(m.UserAddId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintAclchanges(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ACLChangeUserInvite) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ACLChangeUserInvite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ACLChangeUserInvite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InviteId) > 0 {
		i -= len(m.InviteId)
		copy(dAtA[i:], m.InviteId)
		i = encodeVarintAclchanges(dAtA, i, uint64(len(m.InviteId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Permissions != 0 {
		i = encodeVarintAclchanges(dAtA, i, uint64(m.Permissions))
		i--
		dAtA[i] = 0x20
	}
	if len(m.EncryptedReadKeys) > 0 {
		for iNdEx := len(m.EncryptedReadKeys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EncryptedReadKeys[iNdEx])
			copy(dAtA[i:], m.EncryptedReadKeys[iNdEx])
			i = encodeVarintAclchanges(dAtA, i, uint64(len(m.EncryptedReadKeys[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.EncryptPublicKey) > 0 {
		i -= len(m.EncryptPublicKey)
		copy(dAtA[i:], m.EncryptPublicKey)
		i = encodeVarintAclchanges(dAtA, i, uint64(len(m.EncryptPublicKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AcceptPublicKey) > 0 {
		i -= len(m.AcceptPublicKey)
		copy(dAtA[i:], m.AcceptPublicKey)
		i = encodeVarintAclchanges(dAtA, i, uint64(len(m.AcceptPublicKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ACLChangeUserJoin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ACLChangeUserJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ACLChangeUserJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EncryptedReadKeys) > 0 {
		for iNdEx := len(m.EncryptedReadKeys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EncryptedReadKeys[iNdEx])
			copy(dAtA[i:], m.EncryptedReadKeys[iNdEx])
			i = encodeVarintAclchanges(dAtA, i, uint64(len(m.EncryptedReadKeys[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.UserInviteId) > 0 {
		i -= len(m.UserInviteId)
		copy(dAtA[i:], m.UserInviteId)
		i = encodeVarintAclchanges(dAtA, i, uint64(len(m.UserInviteId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AcceptSignature) > 0 {
		i -= len(m.AcceptSignature)
		copy(dAtA[i:], m.AcceptSignature)
		i = encodeVarintAclchanges(dAtA, i, uint64(len(m.AcceptSignature)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EncryptionKey) > 0 {
		i -= len(m.EncryptionKey)
		copy(dAtA[i:], m.EncryptionKey)
		i = encodeVarintAclchanges(dAtA, i, uint64(len(m.EncryptionKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintAclchanges(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ACLChangeUserRemove) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ACLChangeUserRemove) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ACLChangeUserRemove) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ReadKeyReplaces) > 0 {
		for iNdEx := len(m.ReadKeyReplaces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ReadKeyReplaces[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAclchanges(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintAclchanges(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ACLChangeReadKeyReplace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ACLChangeReadKeyReplace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ACLChangeReadKeyReplace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EncryptedReadKey) > 0 {
		i -= len(m.EncryptedReadKey)
		copy(dAtA[i:], m.EncryptedReadKey)
		i = encodeVarintAclchanges(dAtA, i, uint64(len(m.EncryptedReadKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EncryptionKey) > 0 {
		i -= len(m.EncryptionKey)
		copy(dAtA[i:], m.EncryptionKey)
		i = encodeVarintAclchanges(dAtA, i, uint64(len(m.EncryptionKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintAclchanges(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ACLChangeUserPermissionChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ACLChangeUserPermissionChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ACLChangeUserPermissionChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Permissions != 0 {
		i = encodeVarintAclchanges(dAtA, i, uint64(m.Permissions))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintAclchanges(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Change) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Change) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Change) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsSnapshot {
		i--
		if m.IsSnapshot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintAclchanges(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Timestamp != 0 {
		i = encodeVarintAclchanges(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x30
	}
	if m.CurrentReadKeyHash != 0 {
		i = encodeVarintAclchanges(dAtA, i, uint64(m.CurrentReadKeyHash))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ChangesData) > 0 {
		i -= len(m.ChangesData)
		copy(dAtA[i:], m.ChangesData)
		i = encodeVarintAclchanges(dAtA, i, uint64(len(m.ChangesData)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SnapshotBaseId) > 0 {
		i -= len(m.SnapshotBaseId)
		copy(dAtA[i:], m.SnapshotBaseId)
		i = encodeVarintAclchanges(dAtA, i, uint64(len(m.SnapshotBaseId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AclHeadIds) > 0 {
		for iNdEx := len(m.AclHeadIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AclHeadIds[iNdEx])
			copy(dAtA[i:], m.AclHeadIds[iNdEx])
			i = encodeVarintAclchanges(dAtA, i, uint64(len(m.AclHeadIds[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.TreeHeadIds) > 0 {
		for iNdEx := len(m.TreeHeadIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TreeHeadIds[iNdEx])
			copy(dAtA[i:], m.TreeHeadIds[iNdEx])
			i = encodeVarintAclchanges(dAtA, i, uint64(len(m.TreeHeadIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintAclchanges(dAtA []byte, offset int, v uint64) int {
	offset -= sovAclchanges(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RawChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovAclchanges(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovAclchanges(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAclchanges(uint64(l))
	}
	return n
}

func (m *ACLChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TreeHeadIds) > 0 {
		for _, s := range m.TreeHeadIds {
			l = len(s)
			n += 1 + l + sovAclchanges(uint64(l))
		}
	}
	if len(m.AclHeadIds) > 0 {
		for _, s := range m.AclHeadIds {
			l = len(s)
			n += 1 + l + sovAclchanges(uint64(l))
		}
	}
	l = len(m.SnapshotBaseId)
	if l > 0 {
		n += 1 + l + sovAclchanges(uint64(l))
	}
	if m.AclData != nil {
		l = m.AclData.Size()
		n += 1 + l + sovAclchanges(uint64(l))
	}
	l = len(m.ChangesData)
	if l > 0 {
		n += 1 + l + sovAclchanges(uint64(l))
	}
	if m.CurrentReadKeyHash != 0 {
		n += 1 + sovAclchanges(uint64(m.CurrentReadKeyHash))
	}
	if m.Timestamp != 0 {
		n += 1 + sovAclchanges(uint64(m.Timestamp))
	}
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovAclchanges(uint64(l))
	}
	return n
}

func (m *ACLChangeACLContentValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *ACLChangeACLContentValueValueOfUserAdd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserAdd != nil {
		l = m.UserAdd.Size()
		n += 1 + l + sovAclchanges(uint64(l))
	}
	return n
}
func (m *ACLChangeACLContentValueValueOfUserRemove) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserRemove != nil {
		l = m.UserRemove.Size()
		n += 1 + l + sovAclchanges(uint64(l))
	}
	return n
}
func (m *ACLChangeACLContentValueValueOfUserPermissionChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserPermissionChange != nil {
		l = m.UserPermissionChange.Size()
		n += 1 + l + sovAclchanges(uint64(l))
	}
	return n
}
func (m *ACLChangeACLContentValueValueOfUserInvite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserInvite != nil {
		l = m.UserInvite.Size()
		n += 1 + l + sovAclchanges(uint64(l))
	}
	return n
}
func (m *ACLChangeACLContentValueValueOfUserJoin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserJoin != nil {
		l = m.UserJoin.Size()
		n += 1 + l + sovAclchanges(uint64(l))
	}
	return n
}
func (m *ACLChangeACLContentValueValueOfUserConfirm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserConfirm != nil {
		l = m.UserConfirm.Size()
		n += 1 + l + sovAclchanges(uint64(l))
	}
	return n
}
func (m *ACLChangeACLData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AclSnapshot != nil {
		l = m.AclSnapshot.Size()
		n += 1 + l + sovAclchanges(uint64(l))
	}
	if len(m.AclContent) > 0 {
		for _, e := range m.AclContent {
			l = e.Size()
			n += 1 + l + sovAclchanges(uint64(l))
		}
	}
	return n
}

func (m *ACLChangeACLSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AclState != nil {
		l = m.AclState.Size()
		n += 1 + l + sovAclchanges(uint64(l))
	}
	return n
}

func (m *ACLChangeACLState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ReadKeyHashes) > 0 {
		l = 0
		for _, e := range m.ReadKeyHashes {
			l += sovAclchanges(uint64(e))
		}
		n += 1 + sovAclchanges(uint64(l)) + l
	}
	if len(m.UserStates) > 0 {
		for _, e := range m.UserStates {
			l = e.Size()
			n += 1 + l + sovAclchanges(uint64(l))
		}
	}
	if len(m.Invites) > 0 {
		for k, v := range m.Invites {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovAclchanges(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovAclchanges(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovAclchanges(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ACLChangeUserState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovAclchanges(uint64(l))
	}
	l = len(m.EncryptionKey)
	if l > 0 {
		n += 1 + l + sovAclchanges(uint64(l))
	}
	if len(m.EncryptedReadKeys) > 0 {
		for _, b := range m.EncryptedReadKeys {
			l = len(b)
			n += 1 + l + sovAclchanges(uint64(l))
		}
	}
	if m.Permissions != 0 {
		n += 1 + sovAclchanges(uint64(m.Permissions))
	}
	if m.IsConfirmed {
		n += 2
	}
	return n
}

func (m *ACLChangeUserAdd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovAclchanges(uint64(l))
	}
	l = len(m.EncryptionKey)
	if l > 0 {
		n += 1 + l + sovAclchanges(uint64(l))
	}
	if len(m.EncryptedReadKeys) > 0 {
		for _, b := range m.EncryptedReadKeys {
			l = len(b)
			n += 1 + l + sovAclchanges(uint64(l))
		}
	}
	if m.Permissions != 0 {
		n += 1 + sovAclchanges(uint64(m.Permissions))
	}
	return n
}

func (m *ACLChangeUserConfirm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovAclchanges(uint64(l))
	}
	l = len(m.UserAddId)
	if l > 0 {
		n += 1 + l + sovAclchanges(uint64(l))
	}
	return n
}

func (m *ACLChangeUserInvite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AcceptPublicKey)
	if l > 0 {
		n += 1 + l + sovAclchanges(uint64(l))
	}
	l = len(m.EncryptPublicKey)
	if l > 0 {
		n += 1 + l + sovAclchanges(uint64(l))
	}
	if len(m.EncryptedReadKeys) > 0 {
		for _, b := range m.EncryptedReadKeys {
			l = len(b)
			n += 1 + l + sovAclchanges(uint64(l))
		}
	}
	if m.Permissions != 0 {
		n += 1 + sovAclchanges(uint64(m.Permissions))
	}
	l = len(m.InviteId)
	if l > 0 {
		n += 1 + l + sovAclchanges(uint64(l))
	}
	return n
}

func (m *ACLChangeUserJoin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovAclchanges(uint64(l))
	}
	l = len(m.EncryptionKey)
	if l > 0 {
		n += 1 + l + sovAclchanges(uint64(l))
	}
	l = len(m.AcceptSignature)
	if l > 0 {
		n += 1 + l + sovAclchanges(uint64(l))
	}
	l = len(m.UserInviteId)
	if l > 0 {
		n += 1 + l + sovAclchanges(uint64(l))
	}
	if len(m.EncryptedReadKeys) > 0 {
		for _, b := range m.EncryptedReadKeys {
			l = len(b)
			n += 1 + l + sovAclchanges(uint64(l))
		}
	}
	return n
}

func (m *ACLChangeUserRemove) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovAclchanges(uint64(l))
	}
	if len(m.ReadKeyReplaces) > 0 {
		for _, e := range m.ReadKeyReplaces {
			l = e.Size()
			n += 1 + l + sovAclchanges(uint64(l))
		}
	}
	return n
}

func (m *ACLChangeReadKeyReplace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovAclchanges(uint64(l))
	}
	l = len(m.EncryptionKey)
	if l > 0 {
		n += 1 + l + sovAclchanges(uint64(l))
	}
	l = len(m.EncryptedReadKey)
	if l > 0 {
		n += 1 + l + sovAclchanges(uint64(l))
	}
	return n
}

func (m *ACLChangeUserPermissionChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovAclchanges(uint64(l))
	}
	if m.Permissions != 0 {
		n += 1 + sovAclchanges(uint64(m.Permissions))
	}
	return n
}

func (m *Change) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TreeHeadIds) > 0 {
		for _, s := range m.TreeHeadIds {
			l = len(s)
			n += 1 + l + sovAclchanges(uint64(l))
		}
	}
	if len(m.AclHeadIds) > 0 {
		for _, s := range m.AclHeadIds {
			l = len(s)
			n += 1 + l + sovAclchanges(uint64(l))
		}
	}
	l = len(m.SnapshotBaseId)
	if l > 0 {
		n += 1 + l + sovAclchanges(uint64(l))
	}
	l = len(m.ChangesData)
	if l > 0 {
		n += 1 + l + sovAclchanges(uint64(l))
	}
	if m.CurrentReadKeyHash != 0 {
		n += 1 + sovAclchanges(uint64(m.CurrentReadKeyHash))
	}
	if m.Timestamp != 0 {
		n += 1 + sovAclchanges(uint64(m.Timestamp))
	}
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovAclchanges(uint64(l))
	}
	if m.IsSnapshot {
		n += 2
	}
	return n
}

func sovAclchanges(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAclchanges(x uint64) (n int) {
	return sovAclchanges(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RawChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclchanges
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAclchanges(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclchanges
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ACLChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclchanges
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ACLChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ACLChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeHeadIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TreeHeadIds = append(m.TreeHeadIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AclHeadIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AclHeadIds = append(m.AclHeadIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotBaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnapshotBaseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AclData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AclData == nil {
				m.AclData = &ACLChangeACLData{}
			}
			if err := m.AclData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangesData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangesData = append(m.ChangesData[:0], dAtA[iNdEx:postIndex]...)
			if m.ChangesData == nil {
				m.ChangesData = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentReadKeyHash", wireType)
			}
			m.CurrentReadKeyHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentReadKeyHash |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAclchanges(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclchanges
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ACLChangeACLContentValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclchanges
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ACLContentValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ACLContentValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ACLChangeUserAdd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ACLChangeACLContentValueValueOfUserAdd{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserRemove", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ACLChangeUserRemove{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ACLChangeACLContentValueValueOfUserRemove{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPermissionChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ACLChangeUserPermissionChange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ACLChangeACLContentValueValueOfUserPermissionChange{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserInvite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ACLChangeUserInvite{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ACLChangeACLContentValueValueOfUserInvite{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ACLChangeUserJoin{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ACLChangeACLContentValueValueOfUserJoin{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserConfirm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ACLChangeUserConfirm{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ACLChangeACLContentValueValueOfUserConfirm{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAclchanges(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclchanges
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ACLChangeACLData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclchanges
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ACLData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ACLData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AclSnapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AclSnapshot == nil {
				m.AclSnapshot = &ACLChangeACLSnapshot{}
			}
			if err := m.AclSnapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AclContent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AclContent = append(m.AclContent, &ACLChangeACLContentValue{})
			if err := m.AclContent[len(m.AclContent)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAclchanges(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclchanges
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ACLChangeACLSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclchanges
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ACLSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ACLSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AclState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AclState == nil {
				m.AclState = &ACLChangeACLState{}
			}
			if err := m.AclState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAclchanges(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclchanges
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ACLChangeACLState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclchanges
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ACLState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ACLState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAclchanges
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ReadKeyHashes = append(m.ReadKeyHashes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAclchanges
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAclchanges
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthAclchanges
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ReadKeyHashes) == 0 {
					m.ReadKeyHashes = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAclchanges
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ReadKeyHashes = append(m.ReadKeyHashes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadKeyHashes", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserStates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserStates = append(m.UserStates, &ACLChangeUserState{})
			if err := m.UserStates[len(m.UserStates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Invites == nil {
				m.Invites = make(map[string]*ACLChangeUserInvite)
			}
			var mapkey string
			var mapvalue *ACLChangeUserInvite
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAclchanges
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAclchanges
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAclchanges
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAclchanges
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAclchanges
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthAclchanges
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthAclchanges
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ACLChangeUserInvite{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAclchanges(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAclchanges
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Invites[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAclchanges(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclchanges
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ACLChangeUserState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclchanges
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptionKey = append(m.EncryptionKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptionKey == nil {
				m.EncryptionKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedReadKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedReadKeys = append(m.EncryptedReadKeys, make([]byte, postIndex-iNdEx))
			copy(m.EncryptedReadKeys[len(m.EncryptedReadKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			m.Permissions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Permissions |= ACLChangeUserPermissions(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsConfirmed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsConfirmed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAclchanges(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclchanges
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ACLChangeUserAdd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclchanges
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserAdd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserAdd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptionKey = append(m.EncryptionKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptionKey == nil {
				m.EncryptionKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedReadKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedReadKeys = append(m.EncryptedReadKeys, make([]byte, postIndex-iNdEx))
			copy(m.EncryptedReadKeys[len(m.EncryptedReadKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			m.Permissions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Permissions |= ACLChangeUserPermissions(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAclchanges(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclchanges
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ACLChangeUserConfirm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclchanges
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserConfirm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserConfirm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserAddId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserAddId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAclchanges(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclchanges
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ACLChangeUserInvite) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclchanges
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserInvite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserInvite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptPublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AcceptPublicKey = append(m.AcceptPublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.AcceptPublicKey == nil {
				m.AcceptPublicKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptPublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptPublicKey = append(m.EncryptPublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptPublicKey == nil {
				m.EncryptPublicKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedReadKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedReadKeys = append(m.EncryptedReadKeys, make([]byte, postIndex-iNdEx))
			copy(m.EncryptedReadKeys[len(m.EncryptedReadKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			m.Permissions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Permissions |= ACLChangeUserPermissions(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InviteId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InviteId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAclchanges(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclchanges
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ACLChangeUserJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclchanges
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptionKey = append(m.EncryptionKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptionKey == nil {
				m.EncryptionKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AcceptSignature = append(m.AcceptSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.AcceptSignature == nil {
				m.AcceptSignature = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserInviteId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserInviteId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedReadKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedReadKeys = append(m.EncryptedReadKeys, make([]byte, postIndex-iNdEx))
			copy(m.EncryptedReadKeys[len(m.EncryptedReadKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAclchanges(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclchanges
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ACLChangeUserRemove) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclchanges
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRemove: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRemove: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadKeyReplaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadKeyReplaces = append(m.ReadKeyReplaces, &ACLChangeReadKeyReplace{})
			if err := m.ReadKeyReplaces[len(m.ReadKeyReplaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAclchanges(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclchanges
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ACLChangeReadKeyReplace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclchanges
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadKeyReplace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadKeyReplace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptionKey = append(m.EncryptionKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptionKey == nil {
				m.EncryptionKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedReadKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedReadKey = append(m.EncryptedReadKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedReadKey == nil {
				m.EncryptedReadKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAclchanges(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclchanges
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ACLChangeUserPermissionChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclchanges
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserPermissionChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserPermissionChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			m.Permissions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Permissions |= ACLChangeUserPermissions(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAclchanges(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclchanges
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Change) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclchanges
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Change: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Change: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeHeadIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TreeHeadIds = append(m.TreeHeadIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AclHeadIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AclHeadIds = append(m.AclHeadIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotBaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnapshotBaseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangesData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangesData = append(m.ChangesData[:0], dAtA[iNdEx:postIndex]...)
			if m.ChangesData == nil {
				m.ChangesData = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentReadKeyHash", wireType)
			}
			m.CurrentReadKeyHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentReadKeyHash |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAclchanges
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAclchanges
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSnapshot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSnapshot = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAclchanges(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclchanges
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAclchanges(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAclchanges
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAclchanges
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAclchanges
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAclchanges
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAclchanges
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAclchanges        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAclchanges          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAclchanges = fmt.Errorf("proto: unexpected end of group")
)
