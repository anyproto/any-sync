// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/anyproto/any-sync/net/transport (interfaces: Transport,MultiConn)
//
// Generated by this command:
//
//	mockgen -destination mock_transport/mock_transport.go github.com/anyproto/any-sync/net/transport Transport,MultiConn
//
// Package mock_transport is a generated GoMock package.
package mock_transport

import (
	context "context"
	net "net"
	reflect "reflect"

	transport "github.com/anyproto/any-sync/net/transport"
	gomock "go.uber.org/mock/gomock"
)

// MockTransport is a mock of Transport interface.
type MockTransport struct {
	ctrl     *gomock.Controller
	recorder *MockTransportMockRecorder
}

// MockTransportMockRecorder is the mock recorder for MockTransport.
type MockTransportMockRecorder struct {
	mock *MockTransport
}

// NewMockTransport creates a new mock instance.
func NewMockTransport(ctrl *gomock.Controller) *MockTransport {
	mock := &MockTransport{ctrl: ctrl}
	mock.recorder = &MockTransportMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTransport) EXPECT() *MockTransportMockRecorder {
	return m.recorder
}

// Dial mocks base method.
func (m *MockTransport) Dial(arg0 context.Context, arg1 string) (transport.MultiConn, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Dial", arg0, arg1)
	ret0, _ := ret[0].(transport.MultiConn)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Dial indicates an expected call of Dial.
func (mr *MockTransportMockRecorder) Dial(arg0, arg1 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Dial", reflect.TypeOf((*MockTransport)(nil).Dial), arg0, arg1)
}

// SetAccepter mocks base method.
func (m *MockTransport) SetAccepter(arg0 transport.Accepter) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetAccepter", arg0)
}

// SetAccepter indicates an expected call of SetAccepter.
func (mr *MockTransportMockRecorder) SetAccepter(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetAccepter", reflect.TypeOf((*MockTransport)(nil).SetAccepter), arg0)
}

// MockMultiConn is a mock of MultiConn interface.
type MockMultiConn struct {
	ctrl     *gomock.Controller
	recorder *MockMultiConnMockRecorder
}

// MockMultiConnMockRecorder is the mock recorder for MockMultiConn.
type MockMultiConnMockRecorder struct {
	mock *MockMultiConn
}

// NewMockMultiConn creates a new mock instance.
func NewMockMultiConn(ctrl *gomock.Controller) *MockMultiConn {
	mock := &MockMultiConn{ctrl: ctrl}
	mock.recorder = &MockMultiConnMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMultiConn) EXPECT() *MockMultiConnMockRecorder {
	return m.recorder
}

// Accept mocks base method.
func (m *MockMultiConn) Accept() (net.Conn, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Accept")
	ret0, _ := ret[0].(net.Conn)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Accept indicates an expected call of Accept.
func (mr *MockMultiConnMockRecorder) Accept() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Accept", reflect.TypeOf((*MockMultiConn)(nil).Accept))
}

// Addr mocks base method.
func (m *MockMultiConn) Addr() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Addr")
	ret0, _ := ret[0].(string)
	return ret0
}

// Addr indicates an expected call of Addr.
func (mr *MockMultiConnMockRecorder) Addr() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Addr", reflect.TypeOf((*MockMultiConn)(nil).Addr))
}

// Close mocks base method.
func (m *MockMultiConn) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockMultiConnMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockMultiConn)(nil).Close))
}

// CloseChan mocks base method.
func (m *MockMultiConn) CloseChan() <-chan struct{} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CloseChan")
	ret0, _ := ret[0].(<-chan struct{})
	return ret0
}

// CloseChan indicates an expected call of CloseChan.
func (mr *MockMultiConnMockRecorder) CloseChan() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloseChan", reflect.TypeOf((*MockMultiConn)(nil).CloseChan))
}

// Context mocks base method.
func (m *MockMultiConn) Context() context.Context {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Context")
	ret0, _ := ret[0].(context.Context)
	return ret0
}

// Context indicates an expected call of Context.
func (mr *MockMultiConnMockRecorder) Context() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Context", reflect.TypeOf((*MockMultiConn)(nil).Context))
}

// IsClosed mocks base method.
func (m *MockMultiConn) IsClosed() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsClosed")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsClosed indicates an expected call of IsClosed.
func (mr *MockMultiConnMockRecorder) IsClosed() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsClosed", reflect.TypeOf((*MockMultiConn)(nil).IsClosed))
}

// Open mocks base method.
func (m *MockMultiConn) Open(arg0 context.Context) (net.Conn, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Open", arg0)
	ret0, _ := ret[0].(net.Conn)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Open indicates an expected call of Open.
func (mr *MockMultiConnMockRecorder) Open(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Open", reflect.TypeOf((*MockMultiConn)(nil).Open), arg0)
}
